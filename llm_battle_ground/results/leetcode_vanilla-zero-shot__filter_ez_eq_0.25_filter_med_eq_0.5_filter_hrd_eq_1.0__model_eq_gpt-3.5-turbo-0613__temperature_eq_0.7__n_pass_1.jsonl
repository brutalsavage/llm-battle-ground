{"task_input": "\nLeetCode Problem #3\nTitle: Longest Substring Without Repeating Characters\nDescription:\nGiven a string s, find the length of the longest substring without repeating characters. Example 1: Input: s = \"abcabcbb\" Output: 3 Explanation: The answer is \"abc\", with the length of 3. Example 2: Input: s = \"bbbbb\" Output: 1 Explanation: The answer is \"b\", with the length of 1. Example 3: Input: s = \"pwwkew\" Output: 3 Explanation: The answer is \"wke\", with the length of 3. Notice that the answer must be a substring, \"pwke\" is a subsequence and not a substring. Constraints: 0 <= s.length <= 5 * 10e4 s consists of English letters, digits, symbols and spaces.\n", "code_prompt": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        ", "raw_response": "```python\nclass Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        # Create a set to keep track of unique characters\n        char_set = set()\n        # Initialize variables for the start index and maximum length of the substring\n        start = 0\n        max_length = 0\n        \n        # Iterate over the string\n        for end in range(len(s)):\n            # Check if the current character is already in the set\n            while s[end] in char_set:\n                # If it is, remove the characters from the start of the substring until the current character is not in the set anymore\n                char_set.remove(s[start])\n                start += 1\n            \n            # Add the current character to the set\n            char_set.add(s[end])\n            \n            # Update the maximum length of the substring if needed\n            max_length = max(max_length, end - start + 1)\n        \n        return max_length\n```", "cleaned_response": "\nclass Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        # Create a set to keep track of unique characters\n        char_set = set()\n        # Initialize variables for the start index and maximum length of the substring\n        start = 0\n        max_length = 0\n        \n        # Iterate over the string\n        for end in range(len(s)):\n            # Check if the current character is already in the set\n            while s[end] in char_set:\n                # If it is, remove the characters from the start of the substring until the current character is not in the set anymore\n                char_set.remove(s[start])\n                start += 1\n            \n            # Add the current character to the set\n            char_set.add(s[end])\n            \n            # Update the maximum length of the substring if needed\n            max_length = max(max_length, end - start + 1)\n        \n        return max_length\n", "n_pass": 1, "difficulty": 2.0, "frontend_question_id": 3.0, "loc": 2}
{"task_input": "\nLeetCode Problem #4\nTitle: Median of Two Sorted Arrays\nDescription:\nGiven two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)). Example 1: Input: nums1 = [1, 3], nums2 = [2] Output: 2. 00000 Explanation: merged array = [1, 2, 3] and median is 2. Example 2: Input: nums1 = [1, 2], nums2 = [3, 4] Output: 2. 50000 Explanation: merged array = [1, 2, 3, 4] and median is (2 + 3) / 2 = 2. 5. Constraints: nums1.length == m nums2.length == n 0 <= m <= 1000^0 <= n <= 1000^1 <= m + n <= 2000 -10e6 <= nums1[i], nums2[i] <= 10e6\n", "code_prompt": "class Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n        ", "raw_response": "```python\nclass Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n        m, n = len(nums1), len(nums2)\n        if m > n:\n            nums1, nums2, m, n = nums2, nums1, n, m\n        \n        imin, imax, half_len = 0, m, (m + n + 1) // 2\n        while imin <= imax:\n            i = (imin + imax) // 2\n            j = half_len - i\n            if i < m and nums2[j-1] > nums1[i]:\n                imin = i + 1\n            elif i > 0 and nums1[i-1] > nums2[j]:\n                imax = i - 1\n            else:\n                if i == 0: max_of_left = nums2[j-1]\n                elif j == 0: max_of_left = nums1[i-1]\n                else: max_of_left = max(nums1[i-1], nums2[j-1])\n                if (m + n) % 2 == 1:\n                    return max_of_left\n                if i == m: min_of_right = nums2[j]\n                elif j == n: min_of_right = nums1[i]\n                else: min_of_right = min(nums1[i], nums2[j])\n                return (max_of_left + min_of_right) / 2", "cleaned_response": "\nclass Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n        m, n = len(nums1), len(nums2)\n        if m > n:\n            nums1, nums2, m, n = nums2, nums1, n, m\n        \n        imin, imax, half_len = 0, m, (m + n + 1) // 2\n        while imin <= imax:\n            i = (imin + imax) // 2\n            j = half_len - i\n            if i < m and nums2[j-1] > nums1[i]:\n                imin = i + 1\n            elif i > 0 and nums1[i-1] > nums2[j]:\n                imax = i - 1\n            else:\n                if i == 0: max_of_left = nums2[j-1]\n                elif j == 0: max_of_left = nums1[i-1]\n                else: max_of_left = max(nums1[i-1], nums2[j-1])\n                if (m + n) % 2 == 1:\n                    return max_of_left\n                if i == m: min_of_right = nums2[j]\n                elif j == n: min_of_right = nums1[i]\n                else: min_of_right = min(nums1[i], nums2[j])\n                return (max_of_left + min_of_right) / 2", "n_pass": 1, "difficulty": 3.0, "frontend_question_id": 4.0, "loc": 3}
{"task_input": "\nLeetCode Problem #6\nTitle: Zigzag Conversion\nDescription:\nThe string \"PAYPALISHIRING\" is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)...\n P A H N A P L S I I G Y I R And then read line by line: \"PAHNAPLSIIGYIR\" Write the code that will take a string and make this conversion given a number of rows: string convert(string s, int numRows); Example 1: Input: s = \"PAYPALISHIRING\", numRows = 3 Output: \"PAHNAPLSIIGYIR\" Example 2: Input: s = \"PAYPALISHIRING\", numRows = 4 Output: \"PINALSIGYAHRPI\" Explanation: P I N A L S I G Y A H R P I Example 3: Input: s = \"A\", numRows = 1 Output: \"A\" Constraints: 1 <= s.length <= 1000 s consists of English letters (lower-case and upper-case), ', ' and .. 1 <= numRows <= 1000\n", "code_prompt": "class Solution:\n    def convert(self, s: str, numRows: int) -> str:\n        ", "raw_response": "```python\nclass Solution:\n    def convert(self, s: str, numRows: int) -> str:\n        # edge case: if numRows is 1, the zigzag pattern will be the same as the original string\n        if numRows == 1:\n            return s\n        \n        # create a list of empty strings for each row\n        rows = [''] * numRows\n        \n        # initialize the variables for iterating through the rows\n        index = 0\n        step = 1\n        \n        # iterate through each character in the string\n        for char in s:\n            # add the character to the corresponding row\n            rows[index] += char\n            \n            # if we are at the first or last row, reverse the direction of the step\n            if index == 0:\n                step = 1\n            elif index == numRows - 1:\n                step = -1\n            \n            # move to the next row\n            index += step\n        \n        # combine all the rows into a single string\n        result = ''.join(rows)\n        \n        return result\n```\n\nThe above code defines a class `Solution` with a single method `convert`. This method takes a string `s` and an integer `numRows` as input and returns a string. The goal of the method is to convert the input string into its zigzag pattern with a given number of rows.\n\nThe method begins by handling the edge case where `numRows` is 1. In this case, the zigzag pattern will be the same as the original string, so the method simply returns the original string.\n\nNext, a list `rows` of empty strings is created, with each string representing a row in the zigzag pattern.\n\nThe method then initializes the variables `index` and `step` for iterating through the rows. `index` represents the current row, and `step` represents the direction of movement through the rows. The initial values are `index = 0` and `step = 1`.\n\nThe method then iterates through each character in the input string. For each character, it adds the character to the corresponding row in the `rows` list.\n\nIf the current row is the first row (`index == 0`) or the last row (`index == numRows - 1`), the direction of movement (`step`) is reversed. This ensures that the zigzag pattern is followed correctly.\n\nAfter processing all the characters, the method combines all the rows in the `rows` list into a single string using the `join` method.\n\nFinally, the resulting string is returned as the output of the method.", "cleaned_response": "\nclass Solution:\n    def convert(self, s: str, numRows: int) -> str:\n        # edge case: if numRows is 1, the zigzag pattern will be the same as the original string\n        if numRows == 1:\n            return s\n        \n        # create a list of empty strings for each row\n        rows = [''] * numRows\n        \n        # initialize the variables for iterating through the rows\n        index = 0\n        step = 1\n        \n        # iterate through each character in the string\n        for char in s:\n            # add the character to the corresponding row\n            rows[index] += char\n            \n            # if we are at the first or last row, reverse the direction of the step\n            if index == 0:\n                step = 1\n            elif index == numRows - 1:\n                step = -1\n            \n            # move to the next row\n            index += step\n        \n        # combine all the rows into a single string\n        result = ''.join(rows)\n        \n        return result\n", "n_pass": 1, "difficulty": 2.0, "frontend_question_id": 6.0, "loc": 5}
{"task_input": "\nLeetCode Problem #8\nTitle: String to Integer (atoi)\nDescription:\nImplement the myAtoi(string s) function, which converts a string to a 32-bit signed integer (similar to C/C++'s atoi function). The algorithm for myAtoi(string s) is as follows: Read in and ignore any leading whitespace. Check if the next character (if not already at the end of the string) is '-' or '+'. Read this character in if it is either. This determines if the final result is negative or positive respectively. Assume the result is positive if neither is present. Read in next the characters until the next non-digit character or the end of the input is reached. The rest of the string is ignored. Convert these digits into an integer (i. e. \"123\" -> 123, \"0032\" -> 32 ). If no digits were read, then the integer is 0. Change the sign as necessary (from step 2). If the integer is out of the 32-bit signed integer range [-2^31, 2^31 - 1], then clamp the integer so that it remains in the range. Specifically, integers less than -2^31 should be clamped to -2^31, and integers greater than 2^31 - 1 should be clamped to 2^31 - 1. Return the integer as the final result. Note: Only the space character ' ' is considered a whitespace character. Do not ignore any characters other than the leading whitespace or the rest of the string after the digits. Example 1: Input: s = \"42\" Output: 42 Explanation: The underlined characters are what is read in, the caret is the current reader position. Step 1: \"42\" (no characters read because there is no leading whitespace) ^ Step 2: \"42\" (no characters read because there is neither a '-' nor '+') ^ Step 3: \" 42 \" (\"42\" is read in) ^ The parsed integer is 42. Since 42 is in the range [-2^31, 2^31 - 1], the final result is 42. Example 2: Input: s = \" -42\" Output: -42 Explanation: Step 1: \" -42\" (leading whitespace is read and ignored) ^ Step 2: \" - 42\" ('-' is read, so the result should be negative) ^ Step 3: \" - 42 \" (\"42\" is read in) ^ The parsed integer is -42. Since -42 is in the range [-2^31, 2^31 - 1], the final result is -42. Example 3: Input: s = \"4193 with words\" Output: 4193 Explanation: Step 1: \"4193 with words\" (no characters read because there is no leading whitespace) ^ Step 2: \"4193 with words\" (no characters read because there is neither a '-' nor '+') ^ Step 3: \" 4193 with words\" (\"4193\" is read in; reading stops because the next character is a non-digit) ^ The parsed integer is 4193. Since 4193 is in the range [-2^31, 2^31 - 1], the final result is 4193. Constraints: 0 <= s.length <= 200 s consists of English letters (lower-case and upper-case), digits ( 0-9 ), ' ', '+', '-', and ..\n", "code_prompt": "class Solution:\n    def myAtoi(self, s: str) -> int:\n        ", "raw_response": "```python\nclass Solution:\n    def myAtoi(self, s: str) -> int:\n        # Remove leading whitespace\n        s = s.lstrip()\n        \n        # Check if the first character is a sign and remove it\n        if s and (s[0] == '-' or s[0] == '+'):\n            sign = s[0]\n            s = s[1:]\n        else:\n            sign = \"\"\n        \n        # Check if s is empty after removing sign\n        if not s:\n            return 0\n        \n        # Parse digits until non-digit character is encountered\n        digits = \"\"\n        for char in s:\n            if char.isdigit():\n                digits += char\n            else:\n                break\n        \n        # Check if any digits were parsed\n        if not digits:\n            return 0\n        \n        # Convert digits to integer\n        result = int(sign + digits)\n        \n        # Clamp result to 32-bit integer range\n        INT_MAX = 2 ** 31 - 1\n        INT_MIN = -2 ** 31\n        if result > INT_MAX:\n            return INT_MAX\n        elif result < INT_MIN:\n            return INT_MIN\n        else:\n            return result\n```\n\nThe solution parses the given string to convert it into an integer. It first removes any leading whitespace and checks if the first character is a sign ('-' or '+'). It then removes the sign from the string, if present. Next, it iterates through the remaining characters of the string and parses the digits until a non-digit character is encountered. If no digits are parsed, the result is 0. Otherwise, the digits are converted to an integer, taking into account the sign. Finally, the result is clamped to the 32-bit signed integer range before being returned.", "cleaned_response": "\nclass Solution:\n    def myAtoi(self, s: str) -> int:\n        # Remove leading whitespace\n        s = s.lstrip()\n        \n        # Check if the first character is a sign and remove it\n        if s and (s[0] == '-' or s[0] == '+'):\n            sign = s[0]\n            s = s[1:]\n        else:\n            sign = \"\"\n        \n        # Check if s is empty after removing sign\n        if not s:\n            return 0\n        \n        # Parse digits until non-digit character is encountered\n        digits = \"\"\n        for char in s:\n            if char.isdigit():\n                digits += char\n            else:\n                break\n        \n        # Check if any digits were parsed\n        if not digits:\n            return 0\n        \n        # Convert digits to integer\n        result = int(sign + digits)\n        \n        # Clamp result to 32-bit integer range\n        INT_MAX = 2 ** 31 - 1\n        INT_MIN = -2 ** 31\n        if result > INT_MAX:\n            return INT_MAX\n        elif result < INT_MIN:\n            return INT_MIN\n        else:\n            return result\n", "n_pass": 1, "difficulty": 2.0, "frontend_question_id": 8.0, "loc": 7}
{"task_input": "\nLeetCode Problem #10\nTitle: Regular Expression Matching\nDescription:\nGiven an input string s and a pattern p, implement regular expression matching with support for . and '*' where:...\n . Matches any single character. \u200b\u200b\u200b\u200b '*' Matches zero or more of the preceding element. The matching should cover the entire input string (not partial). Example 1: Input: s = \"aa\", p = \"a\" Output: false Explanation: \"a\" does not match the entire string \"aa\". Example 2: Input: s = \"aa\", p = \"a*\" Output: true Explanation: '*' means zero or more of the preceding element, 'a'. Therefore, by repeating 'a' once, it becomes \"aa\". Example 3: Input: s = \"ab\", p = \". *\" Output: true Explanation: \". *\" means \"zero or more (*) of any character (. )\". Constraints: 1 <= s.length <= 20^1 <= p.length <= 20 s contains only lowercase English letters. p contains only lowercase English letters, ., and '*'. It is guaranteed for each appearance of the character '*', there will be a previous valid character to match.\n", "code_prompt": "class Solution:\n    def isMatch(self, s: str, p: str) -> bool:\n        ", "raw_response": "```python\nclass Solution:\n    def isMatch(self, s: str, p: str) -> bool:\n        # Create a 2D table to store the results of subproblems\n        dp = [[False] * (len(p) + 1) for _ in range(len(s) + 1)]\n        \n        # Empty pattern matches empty string\n        dp[0][0] = True\n        \n        # Deals with patterns like a* or a*b* or a*b*c*\n        for j in range(2, len(p) + 1):\n            if p[j - 1] == '*':\n                dp[0][j] = dp[0][j - 2]\n        \n        # Fill the table row by row\n        for i in range(1, len(s) + 1):\n            for j in range(1, len(p) + 1):\n                # If current characters match or pattern has a '.', then consider it a match\n                if p[j - 1] == s[i - 1] or p[j - 1] == '.':\n                    dp[i][j] = dp[i - 1][j - 1]\n                # If pattern has '*', two cases can arise:\n                # 1. '*' is zero preceding character, then check if pattern without '*' matches current string\n                # 2. '*' represents one or more preceding character, then check if current character matches pattern after '*' and pattern without '*' matches current string\n                elif p[j - 1] == '*':\n                    dp[i][j] = dp[i][j - 2] or (dp[i - 1][j] and (s[i - 1] == p[j - 2] or p[j - 2] == '.'))\n        \n        # The last cell of the table will have the result\n        return dp[-1][-1]\n```\n\nThe time complexity of this solution is O(m * n), where m is the length of the input string `s` and n is the length of the pattern `p`. The space complexity is O(m * n) as well. This solution uses dynamic programming to solve the problem by filling a 2D table. The table represents all possible substrings of `s` and `p` and keeps track of whether they match or not. By using the values from previous subproblems, we can determine whether the entire pattern matches the entire string.", "cleaned_response": "\nclass Solution:\n    def isMatch(self, s: str, p: str) -> bool:\n        # Create a 2D table to store the results of subproblems\n        dp = [[False] * (len(p) + 1) for _ in range(len(s) + 1)]\n        \n        # Empty pattern matches empty string\n        dp[0][0] = True\n        \n        # Deals with patterns like a* or a*b* or a*b*c*\n        for j in range(2, len(p) + 1):\n            if p[j - 1] == '*':\n                dp[0][j] = dp[0][j - 2]\n        \n        # Fill the table row by row\n        for i in range(1, len(s) + 1):\n            for j in range(1, len(p) + 1):\n                # If current characters match or pattern has a '.', then consider it a match\n                if p[j - 1] == s[i - 1] or p[j - 1] == '.':\n                    dp[i][j] = dp[i - 1][j - 1]\n                # If pattern has '*', two cases can arise:\n                # 1. '*' is zero preceding character, then check if pattern without '*' matches current string\n                # 2. '*' represents one or more preceding character, then check if current character matches pattern after '*' and pattern without '*' matches current string\n                elif p[j - 1] == '*':\n                    dp[i][j] = dp[i][j - 2] or (dp[i - 1][j] and (s[i - 1] == p[j - 2] or p[j - 2] == '.'))\n        \n        # The last cell of the table will have the result\n        return dp[-1][-1]\n", "n_pass": 1, "difficulty": 3.0, "frontend_question_id": 10.0, "loc": 9}
{"task_input": "\nLeetCode Problem #16\nTitle: 3Sum Closest\nDescription:\nGiven an integer array nums of length n and an integer target, find three integers in nums such that the sum is closest to target. Return the sum of the three integers. You may assume that each input would have exactly one solution. Example 1: Input: nums = [-1, 2, 1, -4], target = 1 Output: 2 Explanation: The sum that is closest to the target is 2. (-1 + 2 + 1 = 2). Example 2: Input: nums = [0, 0, 0], target = 1 Output: 0 Explanation: The sum that is closest to the target is 0. (0 + 0 + 0 = 0). Constraints: 3 <= nums.length <= 500 -1000 <= nums[i] <= 1000 -10e4 <= target <= 10e4\n", "code_prompt": "class Solution:\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\n        ", "raw_response": "```python\nfrom typing import List\n\nclass Solution:\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\n        # Sort the array\n        nums.sort()\n        # Initialize the closest sum to a large value\n        closest_sum = float('inf')\n        \n        # Iterate through the array\n        for i in range(len(nums)-2):\n            # Set two pointers\n            left = i + 1\n            right = len(nums) - 1\n            \n            while left < right:\n                # Calculate the sum of three integers\n                current_sum = nums[i] + nums[left] + nums[right]\n                \n                # Check if the sum is equal to target\n                if current_sum == target:\n                    return target\n                \n                # Update the closest sum if the current sum is closer to the target\n                if abs(current_sum - target) < abs(closest_sum - target):\n                    closest_sum = current_sum\n                \n                # Update the pointers based on the current sum\n                if current_sum < target:\n                    left += 1\n                else:\n                    right -= 1\n                    \n        return closest_sum\n```\nAlgorithm:\n1. Sort the input array `nums` in ascending order.\n2. Initialize a variable `closest_sum` to store the closest sum to the target. Set it to a large value.\n3. Iterate through the array from index 0 to `len(nums)-2`.\n4. For each element at index `i`, set two pointers `left` and `right` to the next and last indices, respectively.\n5. While `left` is less than `right`, calculate the sum of the three integers at indices `i`, `left`, and `right`.\n6. If the current sum is equal to the target, return the target.\n7. Update the `closest_sum` if the current sum is closer to the target than the previous closest sum.\n8. Move the pointers `left` and `right` based on the current sum. If the current sum is less than the target, increment `left` by 1. Otherwise, decrement `right` by 1.\n9. After finishing the iteration, return the closest sum.", "cleaned_response": "\nfrom typing import List\n\nclass Solution:\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\n        # Sort the array\n        nums.sort()\n        # Initialize the closest sum to a large value\n        closest_sum = float('inf')\n        \n        # Iterate through the array\n        for i in range(len(nums)-2):\n            # Set two pointers\n            left = i + 1\n            right = len(nums) - 1\n            \n            while left < right:\n                # Calculate the sum of three integers\n                current_sum = nums[i] + nums[left] + nums[right]\n                \n                # Check if the sum is equal to target\n                if current_sum == target:\n                    return target\n                \n                # Update the closest sum if the current sum is closer to the target\n                if abs(current_sum - target) < abs(closest_sum - target):\n                    closest_sum = current_sum\n                \n                # Update the pointers based on the current sum\n                if current_sum < target:\n                    left += 1\n                else:\n                    right -= 1\n                    \n        return closest_sum\n", "n_pass": 1, "difficulty": 2.0, "frontend_question_id": 16.0, "loc": 15}
{"task_input": "\nLeetCode Problem #23\nTitle: Merge k Sorted Lists\nDescription:\nYou are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. Example 1: Input: lists = [[1, 4, 5], [1, 3, 4], [2, 6]] Output: [1, 1, 2, 3, 4, 4, 5, 6] Explanation: The linked-lists are: [ 1->4->5, 1->3->4, 2->6 ] merging them into one sorted list: 1->1->2->3->4->4->5->6 Example 2: Input: lists = [] Output: [] Example 3: Input: lists = [[]] Output: [] Constraints: k == lists.length 0 <= k <= 10e4 0 <= lists[i].length <= 500 -10e4 <= lists[i][j] <= 10e4 lists[i] is sorted in ascending order. The sum of lists[i].length will not exceed 10e4.\n", "code_prompt": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\n        ", "raw_response": "```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n\nclass Solution:\n    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\n        def mergeTwoLists(l1, l2):\n            if not l1:\n                return l2\n            if not l2:\n                return l1\n            \n            if l1.val < l2.val:\n                l1.next = mergeTwoLists(l1.next, l2)\n                return l1\n            else:\n                l2.next = mergeTwoLists(l1, l2.next)\n                return l2\n        \n        def merge(lists, start, end):\n            if start == end:\n                return lists[start]\n            if start > end:\n                return None\n            \n            mid = start + (end - start) // 2\n            left = merge(lists, start, mid)\n            right = merge(lists, mid + 1, end)\n            \n            return mergeTwoLists(left, right)\n        \n        return merge(lists, 0, len(lists) - 1)\n```\n\nThe provided code solution is the implementation of the merge sort algorithm. It first defines a helper function `mergeTwoLists` which merges two lists in ascending order. \nThen, it defines another helper function `merge` which recursively divides and merges the input list of lists (where each list is sorted) until we have a single sorted list. \nFinally, the `mergeKLists` function calls the `merge` function with the start and end indices of the input list of lists, and returns the merged sorted list.", "cleaned_response": "\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n\nclass Solution:\n    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\n        def mergeTwoLists(l1, l2):\n            if not l1:\n                return l2\n            if not l2:\n                return l1\n            \n            if l1.val < l2.val:\n                l1.next = mergeTwoLists(l1.next, l2)\n                return l1\n            else:\n                l2.next = mergeTwoLists(l1, l2.next)\n                return l2\n        \n        def merge(lists, start, end):\n            if start == end:\n                return lists[start]\n            if start > end:\n                return None\n            \n            mid = start + (end - start) // 2\n            left = merge(lists, start, mid)\n            right = merge(lists, mid + 1, end)\n            \n            return mergeTwoLists(left, right)\n        \n        return merge(lists, 0, len(lists) - 1)\n", "n_pass": 1, "difficulty": 3.0, "frontend_question_id": 23.0, "loc": 22}
{"task_input": "\nLeetCode Problem #25\nTitle: Reverse Nodes in k-Group\nDescription:\nGiven the head of a linked list, reverse the nodes of the list k at a time, and return the modified list. k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes, in the end, should remain as it is. You may not alter the values in the list's nodes, only nodes themselves may be changed. Example 1: Input: head = [1, 2, 3, 4, 5], k = 2 Output: [2, 1, 4, 3, 5] Example 2: Input: head = [1, 2, 3, 4, 5], k = 3 Output: [3, 2, 1, 4, 5] Constraints: The number of nodes in the list is n. 1 <= k <= n <= 5000^0 <= Node. val <= 1000 Follow-up: Can you solve the problem in O(1) extra memory space?\n", "code_prompt": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        ", "raw_response": "```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        if not head or k == 1:\n            return head\n        \n        def reverse(head, tail):\n            prev = None\n            curr = head\n            while curr != tail:\n                next_node = curr.next\n                curr.next = prev\n                prev = curr\n                curr = next_node\n            return prev\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        \n        i = 0\n        while head:\n            i += 1\n            if i % k == 0:\n                prev = reverse(prev, head.next)\n                head = prev.next\n            else:\n                head = head.next\n                \n        return dummy.next\n```\n\nExplanation:\n\n1. We first create a helper function called `reverse` that reverses a group of k nodes at a time.\n2. Inside the `reverse` function, we use a standard linked list reversal algorithm where we iterate through the nodes and reverse their next pointers.\n3. We initialize a dummy node and set its next pointer to the head of the input linked list. This helps to handle the case when the entire linked list needs to be reversed.\n4. We use a `prev` pointer to keep track of the node before the group of nodes to be reversed.\n5. We initialize a counter `i` to keep track of the number of nodes processed.\n6. We iterate through the linked list using the `head` pointer.\n7. If `i` is a multiple of `k`, we call the `reverse` function to reverse the group of nodes and update the `prev` pointer to point to the new reversed group.\n8. We update the `head` pointer to the next node.\n9. Finally, we return the next pointer of the dummy node, which is the head of the modified linked list.", "cleaned_response": "\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        if not head or k == 1:\n            return head\n        \n        def reverse(head, tail):\n            prev = None\n            curr = head\n            while curr != tail:\n                next_node = curr.next\n                curr.next = prev\n                prev = curr\n                curr = next_node\n            return prev\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        \n        i = 0\n        while head:\n            i += 1\n            if i % k == 0:\n                prev = reverse(prev, head.next)\n                head = prev.next\n            else:\n                head = head.next\n                \n        return dummy.next\n", "n_pass": 1, "difficulty": 3.0, "frontend_question_id": 25.0, "loc": 24}
{"task_input": "\nLeetCode Problem #26\nTitle: Remove Duplicates from Sorted Array\nDescription:\nGiven an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same. Then return the number of unique elements in nums. Consider the number of unique elements of nums to be k, to get accepted, you need to do the following things: Change the array nums such that the first k elements of nums contain the unique elements in the order they were present in nums initially. The remaining elements of nums are not important as well as the size of nums. Return k. Custom Judge: The judge will test your solution with the following code: int[] nums = [. . . ]; // Input array int[] expectedNums = [. . . ]; // The expected answer with correct length int k = removeDuplicates(nums); // Calls your implementation assert k == expectedNums.length; for (int i = 0; i < k; i++) { assert nums[i] == expectedNums[i]; } If all assertions pass, then your solution will be accepted. Example 1: Input: nums = [1, 1, 2] Output: 2, nums = [1, 2, _] Explanation: Your function should return k = 2, with the first two elements of nums being 1 and 2 respectively. It does not matter what you leave beyond the returned k (hence they are underscores). Example 2: Input: nums = [0, 0, 1, 1, 1, 2, 2, 3, 3, 4] Output: 5, nums = [0, 1, 2, 3, 4, _, _, _, _, _] Explanation: Your function should return k = 5, with the first five elements of nums being 0, 1, 2, 3, and 4 respectively. It does not matter what you leave beyond the returned k (hence they are underscores). Constraints: 1 <= nums.length <= 3 * 10e4 -100 <= nums[i] <= 100 nums is sorted in non-decreasing order.\n", "code_prompt": "class Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        ", "raw_response": "```python\nfrom typing import List\n\nclass Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        # Initialize two pointers, i and j\n        i = 0\n        \n        # Iterate through the array\n        for j in range(1, len(nums)):\n            # If the element at j is not equal to the element at i,\n            # update the element at i + 1 with the element at j\n            if nums[i] != nums[j]:\n                nums[i + 1] = nums[j]\n                i += 1\n        \n        # Return the number of unique elements, which is i + 1\n        return i + 1\n```\n\nNote: The given code defines a class `Solution` with a method `removeDuplicates` that takes in a list of integers `nums` and returns an integer. The logic of the code is to use two pointers to iterate through the array. If the element at the current pointer `j` is not equal to the element at the previous pointer `i`, we update the next element at `i + 1` with the current element at `j`. Then, we increment `i` by 1. Finally, we return the number of unique elements, which is `i + 1`.", "cleaned_response": "\nfrom typing import List\n\nclass Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        # Initialize two pointers, i and j\n        i = 0\n        \n        # Iterate through the array\n        for j in range(1, len(nums)):\n            # If the element at j is not equal to the element at i,\n            # update the element at i + 1 with the element at j\n            if nums[i] != nums[j]:\n                nums[i + 1] = nums[j]\n                i += 1\n        \n        # Return the number of unique elements, which is i + 1\n        return i + 1\n", "n_pass": 1, "difficulty": 1.0, "frontend_question_id": 26.0, "loc": 25}
{"task_input": "\nLeetCode Problem #30\nTitle: Substring with Concatenation of All Words\nDescription:\nYou are given a string s and an array of strings words. All the strings of words are of the same length. A concatenated substring in s is a substring that contains all the strings of any permutation of words concatenated. For example, if words = [\"ab\", \"cd\", \"ef\"], then \"abcdef\", \"abefcd\", \"cdabef\", \"cdefab\", \"efabcd\", and \"efcdab\" are all concatenated strings. \"acdbef\" is not a concatenated substring because it is not the concatenation of any permutation of words. Return the starting indices of all the concatenated substrings in s. You can return the answer in any order. Example 1: Input: s = \"barfoothefoobarman\", words = [\"foo\", \"bar\"] Output: [0, 9] Explanation: Since words.length == 2 and words[i].length == 3, the concatenated substring has to be of length 6. The substring starting at 0 is \"barfoo\". It is the concatenation of [\"bar\", \"foo\"] which is a permutation of words. The substring starting at 9 is \"foobar\". It is the concatenation of [\"foo\", \"bar\"] which is a permutation of words. The output order does not matter. Returning [9, 0] is fine too. Example 2: Input: s = \"wordgoodgoodgoodbestword\", words = [\"word\", \"good\", \"best\", \"word\"] Output: [] Explanation: Since words.length == 4 and words[i].length == 4, the concatenated substring has to be of length 16. There is no substring of length 16 is s that is equal to the concatenation of any permutation of words. We return an empty array. Example 3: Input: s = \"barfoofoobarthefoobarman\", words = [\"bar\", \"foo\", \"the\"] Output: [6, 9, 12] Explanation: Since words.length == 3 and words[i].length == 3, the concatenated substring has to be of length 9. The substring starting at 6 is \"foobarthe\". It is the concatenation of [\"foo\", \"bar\", \"the\"] which is a permutation of words. The substring starting at 9 is \"barthefoo\". It is the concatenation of [\"bar\", \"the\", \"foo\"] which is a permutation of words. The substring starting at 12 is \"thefoobar\". It is the concatenation of [\"the\", \"foo\", \"bar\"] which is a permutation of words. Constraints: 1 <= s.length <= 10e4 1 <= words.length <= 5000^1 <= words[i].length <= 30 s and words[i] consist of lowercase English letters.\n", "code_prompt": "class Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        ", "raw_response": "```python\nfrom typing import List\n\nclass Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        if not s or not words:\n            return []\n        \n        word_len = len(words[0])\n        total_len = len(words) * word_len\n        \n        # Store word frequency in a dictionary\n        word_count = {}\n        for word in words:\n            if word in word_count:\n                word_count[word] += 1\n            else:\n                word_count[word] = 1\n        \n        res = []\n        \n        # Iterate through all possible starting indices\n        for i in range(len(s) - total_len + 1):\n            curr_count = {}\n            j = 0\n            \n            # Iterate through all words in the current substring\n            while j < total_len:\n                word = s[i + j:i + j + word_len]\n                \n                # If the word is not in words or its frequency in curr_count exceeds the frequency in word_count, break\n                if word not in word_count or curr_count.get(word, 0) == word_count[word]:\n                    break\n                \n                # Update curr_count\n                if word in curr_count:\n                    curr_count[word] += 1\n                else:\n                    curr_count[word] = 1\n                \n                j += word_len\n            \n            # If all words are found, append the starting index to the result\n            if j == total_len:\n                res.append(i)\n        \n        return res\n```", "cleaned_response": "\nfrom typing import List\n\nclass Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        if not s or not words:\n            return []\n        \n        word_len = len(words[0])\n        total_len = len(words) * word_len\n        \n        # Store word frequency in a dictionary\n        word_count = {}\n        for word in words:\n            if word in word_count:\n                word_count[word] += 1\n            else:\n                word_count[word] = 1\n        \n        res = []\n        \n        # Iterate through all possible starting indices\n        for i in range(len(s) - total_len + 1):\n            curr_count = {}\n            j = 0\n            \n            # Iterate through all words in the current substring\n            while j < total_len:\n                word = s[i + j:i + j + word_len]\n                \n                # If the word is not in words or its frequency in curr_count exceeds the frequency in word_count, break\n                if word not in word_count or curr_count.get(word, 0) == word_count[word]:\n                    break\n                \n                # Update curr_count\n                if word in curr_count:\n                    curr_count[word] += 1\n                else:\n                    curr_count[word] = 1\n                \n                j += word_len\n            \n            # If all words are found, append the starting index to the result\n            if j == total_len:\n                res.append(i)\n        \n        return res\n", "n_pass": 1, "difficulty": 3.0, "frontend_question_id": 30.0, "loc": 29}
{"task_input": "\nLeetCode Problem #31\nTitle: Next Permutation\nDescription:\nA permutation of an array of integers is an arrangement of its members into a sequence or linear order. For example, for arr = [1, 2, 3], the following are all the permutations of arr : [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]. The next permutation of an array of integers is the next lexicographically greater permutation of its integer. More formally, if all the permutations of the array are sorted in one container according to their lexicographical order, then the next permutation of that array is the permutation that follows it in the sorted container. If such arrangement is not possible, the array must be rearranged as the lowest possible order (i. e. , sorted in ascending order). For example, the next permutation of arr = [1, 2, 3] is [1, 3, 2]. Similarly, the next permutation of arr = [2, 3, 1] is [3, 1, 2]. While the next permutation of arr = [3, 2, 1] is [1, 2, 3] because [3, 2, 1] does not have a lexicographical larger rearrangement. Given an array of integers nums, find the next permutation of nums. The replacement must be in place and use only constant extra memory. Example 1: Input: nums = [1, 2, 3] Output: [1, 3, 2] Example 2: Input: nums = [3, 2, 1] Output: [1, 2, 3] Example 3: Input: nums = [1, 1, 5] Output: [1, 5, 1] Constraints: 1 <= nums.length <= 100^0 <= nums[i] <= 100\n", "code_prompt": "class Solution:\n    def nextPermutation(self, nums: List[int]) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        ", "raw_response": "```python\nclass Solution:\n    def nextPermutation(self, nums: List[int]) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        # Find the first decreasing element from the right\n        i = len(nums) - 2\n        while i >= 0 and nums[i] >= nums[i+1]:\n            i -= 1\n        \n        # If no such element is found, reverse the whole array\n        if i == -1:\n            nums.reverse()\n            return\n        \n        # Find the smallest element that is greater than nums[i] from the right\n        j = len(nums) - 1\n        while j > i and nums[j] <= nums[i]:\n            j -= 1\n        \n        # Swap nums[i] and nums[j]\n        nums[i], nums[j] = nums[j], nums[i]\n        \n        # Reverse the elements from i+1 to the end\n        start = i + 1\n        end = len(nums) - 1\n        while start < end:\n            nums[start], nums[end] = nums[end], nums[start]\n            start += 1\n            end -= 1\n```\n\nThe above code implements the `nextPermutation` function which finds the next lexicographically greater permutation of the given array of integers `nums`. It modifies the array in place without using any extra memory.\n\nThe approach used in this solution is as follows:\n\n1. Find the first decreasing element from the right. Let's call it `i`. This element will be swapped with a smaller element that is located to its right.\n2. If no such element is found, it means that the array is in descending order, which is the largest possible permutation. In this case, we reverse the whole array to get the smallest possible permutation.\n3. Find the smallest element that is greater than `nums[i]` from the right. Let's call it `j`.\n4. Swap `nums[i]` with `nums[j]`.\n5. Reverse the elements from `i+1` to the end of the array.\n\nThis algorithm guarantees that the resulting permutation will be the next lexicographically greater permutation. If there is no next permutation, the algorithm produces the smallest possible permutation.", "cleaned_response": "\nclass Solution:\n    def nextPermutation(self, nums: List[int]) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        # Find the first decreasing element from the right\n        i = len(nums) - 2\n        while i >= 0 and nums[i] >= nums[i+1]:\n            i -= 1\n        \n        # If no such element is found, reverse the whole array\n        if i == -1:\n            nums.reverse()\n            return\n        \n        # Find the smallest element that is greater than nums[i] from the right\n        j = len(nums) - 1\n        while j > i and nums[j] <= nums[i]:\n            j -= 1\n        \n        # Swap nums[i] and nums[j]\n        nums[i], nums[j] = nums[j], nums[i]\n        \n        # Reverse the elements from i+1 to the end\n        start = i + 1\n        end = len(nums) - 1\n        while start < end:\n            nums[start], nums[end] = nums[end], nums[start]\n            start += 1\n            end -= 1\n", "n_pass": 1, "difficulty": 2.0, "frontend_question_id": 31.0, "loc": 30}
{"task_input": "\nLeetCode Problem #32\nTitle: Longest Valid Parentheses\nDescription:\nGiven a string containing just the characters '(' and ')', return the length of the longest valid (well-formed) parentheses substring. Example 1: Input: s = \"(()\" Output: 2 Explanation: The longest valid parentheses substring is \"()\". Example 2: Input: s = \")()())\" Output: 4 Explanation: The longest valid parentheses substring is \"()()\". Example 3: Input: s = \"\" Output: 0 Constraints: 0 <= s.length <= 3 * 10e4 s[i] is '(', or ')'.\n", "code_prompt": "class Solution:\n    def longestValidParentheses(self, s: str) -> int:\n        ", "raw_response": "```python\nclass Solution:\n    def longestValidParentheses(self, s: str) -> int:\n        stack = [-1]  # Initialize stack with -1 as the base index\n        max_length = 0\n        for i in range(len(s)):\n            if s[i] == '(':\n                stack.append(i)  # Push index to stack\n            else:\n                stack.pop()  # Pop the top element from stack\n                if len(stack) == 0:\n                    stack.append(i)  # Push index to stack\n                else:\n                    max_length = max(max_length, i - stack[-1])  # Calculate the current length of valid parentheses\n        return max_length\n```\nThe above implementation uses a stack to keep track of the indices of opening parentheses. We initialize the stack with -1 as the base index to handle the case when the first character is ')'. We iterate through each character in the string and if we encounter an opening parenthesis '(' we push the index to the stack. If we encounter a closing parenthesis ')', we remove the top element from the stack. If the stack becomes empty, it means we have reached the end of a valid parentheses substring, so we push the current index to the stack. Otherwise, we calculate the current length of the valid parentheses substring by subtracting the top element of the stack from the current index and update the maximum length accordingly. Finally, we return the maximum length of valid parentheses found.", "cleaned_response": "\nclass Solution:\n    def longestValidParentheses(self, s: str) -> int:\n        stack = [-1]  # Initialize stack with -1 as the base index\n        max_length = 0\n        for i in range(len(s)):\n            if s[i] == '(':\n                stack.append(i)  # Push index to stack\n            else:\n                stack.pop()  # Pop the top element from stack\n                if len(stack) == 0:\n                    stack.append(i)  # Push index to stack\n                else:\n                    max_length = max(max_length, i - stack[-1])  # Calculate the current length of valid parentheses\n        return max_length\n", "n_pass": 1, "difficulty": 3.0, "frontend_question_id": 32.0, "loc": 31}
{"task_input": "\nLeetCode Problem #33\nTitle: Search in Rotated Sorted Array\nDescription:\nThere is an integer array nums sorted in ascending order (with distinct values). Prior to being passed to your function, nums is possibly rotated at an unknown pivot index k ( 1 <= k < nums.length ) such that the resulting array is [nums[k], nums[k+1],. . . , nums[n-1], nums[0], nums[1],. . . , nums[k-1]] ( 0-indexed ). For example, [0, 1, 2, 4, 5, 6, 7] might be rotated at pivot index 3 and become [4, 5, 6, 7, 0, 1, 2]. Given the array nums after the possible rotation and an integer target, return the index of target if it is in nums, or -1 if it is not in nums. You must write an algorithm with O(log n) runtime complexity. Example 1: Input: nums = [4, 5, 6, 7, 0, 1, 2], target = 0 Output: 4 Example 2: Input: nums = [4, 5, 6, 7, 0, 1, 2], target = 3 Output: -1 Example 3: Input: nums = [1], target = 0 Output: -1 Constraints: 1 <= nums.length <= 5000 -10e4 <= nums[i] <= 10e4 All values of nums are unique. nums is an ascending array that is possibly rotated. -10e4 <= target <= 10e4\n", "code_prompt": "class Solution:\n    def search(self, nums: List[int], target: int) -> int:\n        ", "raw_response": "```python\nfrom typing import List\n\nclass Solution:\n    def search(self, nums: List[int], target: int) -> int:\n        if not nums:\n            return -1\n        \n        left = 0\n        right = len(nums) - 1\n        \n        # Find the pivot index\n        while left < right:\n            mid = (left + right) // 2\n            if nums[mid] > nums[right]:\n                left = mid + 1\n            else:\n                right = mid\n        \n        pivot = left\n        left = 0\n        right = len(nums) - 1\n        \n        # Determine which side of the pivot the target is on and perform binary search\n        if target >= nums[pivot] and target <= nums[right]:\n            left = pivot\n        else:\n            right = pivot - 1\n        \n        # Perform binary search\n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        \n        return -1\n```", "cleaned_response": "\nfrom typing import List\n\nclass Solution:\n    def search(self, nums: List[int], target: int) -> int:\n        if not nums:\n            return -1\n        \n        left = 0\n        right = len(nums) - 1\n        \n        # Find the pivot index\n        while left < right:\n            mid = (left + right) // 2\n            if nums[mid] > nums[right]:\n                left = mid + 1\n            else:\n                right = mid\n        \n        pivot = left\n        left = 0\n        right = len(nums) - 1\n        \n        # Determine which side of the pivot the target is on and perform binary search\n        if target >= nums[pivot] and target <= nums[right]:\n            left = pivot\n        else:\n            right = pivot - 1\n        \n        # Perform binary search\n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        \n        return -1\n", "n_pass": 1, "difficulty": 2.0, "frontend_question_id": 33.0, "loc": 32}
{"task_input": "\nLeetCode Problem #36\nTitle: Valid Sudoku\nDescription:\nDetermine if a 9 x 9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules :...\n Each row must contain the digits 1-9 without repetition. Each column must contain the digits 1-9 without repetition. Each of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without repetition. Note: A Sudoku board (partially filled) could be valid but is not necessarily solvable. Only the filled cells need to be validated according to the mentioned rules. Example 1: Input: board = [[\"5\", \"3\", \". \", \". \", \"7\", \". \", \". \", \". \", \". \"], [\"6\", \". \", \". \", \"1\", \"9\", \"5\", \". \", \". \", \". \"], [\". \", \"9\", \"8\", \". \", \". \", \". \", \". \", \"6\", \". \"], [\"8\", \". \", \". \", \". \", \"6\", \". \", \". \", \". \", \"3\"], [\"4\", \". \", \". \", \"8\", \". \", \"3\", \". \", \". \", \"1\"], [\"7\", \". \", \". \", \". \", \"2\", \". \", \". \", \". \", \"6\"], [\". \", \"6\", \". \", \". \", \". \", \". \", \"2\", \"8\", \". \"], [\". \", \". \", \". \", \"4\", \"1\", \"9\", \". \", \". \", \"5\"], [\". \", \". \", \". \", \". \", \"8\", \". \", \". \", \"7\", \"9\"]] Output: true Example 2: Input: board = [[\"8\", \"3\", \". \", \". \", \"7\", \". \", \". \", \". \", \". \"], [\"6\", \". \", \". \", \"1\", \"9\", \"5\", \". \", \". \", \". \"], [\". \", \"9\", \"8\", \". \", \". \", \". \", \". \", \"6\", \". \"], [\"8\", \". \", \". \", \". \", \"6\", \". \", \". \", \". \", \"3\"], [\"4\", \". \", \". \", \"8\", \". \", \"3\", \". \", \". \", \"1\"], [\"7\", \". \", \". \", \". \", \"2\", \". \", \". \", \". \", \"6\"], [\". \", \"6\", \". \", \". \", \". \", \". \", \"2\", \"8\", \". \"], [\". \", \". \", \". \", \"4\", \"1\", \"9\", \". \", \". \", \"5\"], [\". \", \". \", \". \", \". \", \"8\", \". \", \". \", \"7\", \"9\"]] Output: false Explanation: Same as Example 1, except with the 5 in the top left corner being modified to 8. Since there are two 8's in the top left 3x3 sub-box, it is invalid. Constraints: board.length == 9 board[i].length == 9 board[i][j] is a digit 1-9 or ..\n", "code_prompt": "class Solution:\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\n        ", "raw_response": "```python\nclass Solution:\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\n        # Check rows\n        for row in board:\n            if not self.isValidSet(row):\n                return False\n        \n        # Check columns\n        for col in range(len(board[0])):\n            column = [row[col] for row in board]\n            if not self.isValidSet(column):\n                return False\n        \n        # Check 3x3 sub-boxes\n        for i in range(0, 9, 3):\n            for j in range(0, 9, 3):\n                sub_box = [board[x][y] for x in range(i, i+3) for y in range(j, j+3)]\n                if not self.isValidSet(sub_box):\n                    return False\n        \n        return True\n    \n    def isValidSet(self, arr: List[str]) -> bool:\n        validSet = set()\n        for num in arr:\n            if num == '.':\n                continue\n            if num in validSet:\n                return False\n            validSet.add(num)\n        \n        return True\n```", "cleaned_response": "\nclass Solution:\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\n        # Check rows\n        for row in board:\n            if not self.isValidSet(row):\n                return False\n        \n        # Check columns\n        for col in range(len(board[0])):\n            column = [row[col] for row in board]\n            if not self.isValidSet(column):\n                return False\n        \n        # Check 3x3 sub-boxes\n        for i in range(0, 9, 3):\n            for j in range(0, 9, 3):\n                sub_box = [board[x][y] for x in range(i, i+3) for y in range(j, j+3)]\n                if not self.isValidSet(sub_box):\n                    return False\n        \n        return True\n    \n    def isValidSet(self, arr: List[str]) -> bool:\n        validSet = set()\n        for num in arr:\n            if num == '.':\n                continue\n            if num in validSet:\n                return False\n            validSet.add(num)\n        \n        return True\n", "n_pass": 1, "difficulty": 2.0, "frontend_question_id": 36.0, "loc": 35}
{"task_input": "\nLeetCode Problem #37\nTitle: Sudoku Solver\nDescription:\nWrite a program to solve a Sudoku puzzle by filling the empty cells. A sudoku solution must satisfy all of the following rules : Each of the digits 1-9 must occur exactly once in each row. Each of the digits 1-9 must occur exactly once in each column. Each of the digits 1-9 must occur exactly once in each of the 9 3x3 sub-boxes of the grid. The . character indicates empty cells. Example 1: Input: board = [[\"5\", \"3\", \". \", \". \", \"7\", \". \", \". \", \". \", \". \"], [\"6\", \". \", \". \", \"1\", \"9\", \"5\", \". \", \". \", \". \"], [\". \", \"9\", \"8\", \". \", \". \", \". \", \". \", \"6\", \". \"], [\"8\", \". \", \". \", \". \", \"6\", \". \", \". \", \". \", \"3\"], [\"4\", \". \", \". \", \"8\", \". \", \"3\", \". \", \". \", \"1\"], [\"7\", \". \", \". \", \". \", \"2\", \". \", \". \", \". \", \"6\"], [\". \", \"6\", \". \", \". \", \". \", \". \", \"2\", \"8\", \". \"], [\". \", \". \", \". \", \"4\", \"1\", \"9\", \". \", \". \", \"5\"], [\". \", \". \", \". \", \". \", \"8\", \". \", \". \", \"7\", \"9\"]] Output: [[\"5\", \"3\", \"4\", \"6\", \"7\", \"8\", \"9\", \"1\", \"2\"], [\"6\", \"7\", \"2\", \"1\", \"9\", \"5\", \"3\", \"4\", \"8\"], [\"1\", \"9\", \"8\", \"3\", \"4\", \"2\", \"5\", \"6\", \"7\"], [\"8\", \"5\", \"9\", \"7\", \"6\", \"1\", \"4\", \"2\", \"3\"], [\"4\", \"2\", \"6\", \"8\", \"5\", \"3\", \"7\", \"9\", \"1\"], [\"7\", \"1\", \"3\", \"9\", \"2\", \"4\", \"8\", \"5\", \"6\"], [\"9\", \"6\", \"1\", \"5\", \"3\", \"7\", \"2\", \"8\", \"4\"], [\"2\", \"8\", \"7\", \"4\", \"1\", \"9\", \"6\", \"3\", \"5\"], [\"3\", \"4\", \"5\", \"2\", \"8\", \"6\", \"1\", \"7\", \"9\"]] Explanation: The input board is shown above and the only valid solution is shown below: Constraints: board.length == 9 board[i].length == 9 board[i][j] is a digit or .. It is guaranteed that the input board has only one solution.\n", "code_prompt": "class Solution:\n    def solveSudoku(self, board: List[List[str]]) -> None:\n        \"\"\"\n        Do not return anything, modify board in-place instead.\n        \"\"\"\n        ", "raw_response": "```python\nclass Solution:\n    def solveSudoku(self, board: List[List[str]]) -> None:\n        \"\"\"\n        Do not return anything, modify board in-place instead.\n        \"\"\"\n        # Define a helper function to check if a value is valid in a given position\n        def isValid(board, row, col, val):\n            # Check if the value is already present in the same row\n            for i in range(9):\n                if board[row][i] == val:\n                    return False\n            # Check if the value is already present in the same column\n            for j in range(9):\n                if board[j][col] == val:\n                    return False\n            # Check if the value is already present in the same 3x3 sub-grid\n            startRow = (row // 3) * 3  # Starting row of the sub-grid\n            startCol = (col // 3) * 3  # Starting column of the sub-grid\n            for i in range(3):\n                for j in range(3):\n                    if board[startRow + i][startCol + j] == val:\n                        return False\n            return True\n\n        # Define a recursive backtracking function to solve the Sudoku puzzle\n        def solve(board):\n            # Iterate through each cell in the board\n            for row in range(9):\n                for col in range(9):\n                    # If the cell is empty\n                    if board[row][col] == \".\":\n                        # Try every possible digit from 1 to 9\n                        for val in \"123456789\":\n                            # Check if the current digit is valid in the current position\n                            if isValid(board, row, col, val):\n                                # Place the current digit in the current position\n                                board[row][col] = val\n                                # Recursively solve the puzzle\n                                if solve(board):\n                                    return True\n                                # If the puzzle cannot be solved with the current digit,\n                                # remove the digit from the current position\n                                board[row][col] = \".\"\n                        # If none of the digits is valid in the current position,\n                        # backtrack to the previous position\n                        return False\n            # If all cells are filled, the puzzle is solved\n            return True\n\n        # Call the backtracking function to solve the Sudoku puzzle\n        solve(board)\n```\n\nThe above code defines a `Solution` class with a method `solveSudoku` that takes in a Sudoku board as a parameter and modifies it in-place to solve the puzzle. It uses a recursive backtracking algorithm to try every possible digit from 1 to 9 in each empty cell, and checks if it is valid in the current position. If a valid digit is found, it is placed in the current position and the puzzle is recursively solved. If no valid digit is found, the algorithm backtracks to the previous position.\n\nThe `isValid` function is a helper function that checks if a given value is valid in a given position by checking if it already exists in the same row, column, or 3x3 sub-grid.\n\nThe main `solve` function iterates through each cell in the board and checks if it is empty. If the cell is empty, it tries every possible digit and recursively solves the puzzle. If a solution is found, the function returns `True`. If none of the digits is valid in the current position, the function returns `False` to trigger backtracking.\n\nThe `solve` function is called with the initial Sudoku board to solve the puzzle in-place.", "cleaned_response": "\nclass Solution:\n    def solveSudoku(self, board: List[List[str]]) -> None:\n        \"\"\"\n        Do not return anything, modify board in-place instead.\n        \"\"\"\n        # Define a helper function to check if a value is valid in a given position\n        def isValid(board, row, col, val):\n            # Check if the value is already present in the same row\n            for i in range(9):\n                if board[row][i] == val:\n                    return False\n            # Check if the value is already present in the same column\n            for j in range(9):\n                if board[j][col] == val:\n                    return False\n            # Check if the value is already present in the same 3x3 sub-grid\n            startRow = (row // 3) * 3  # Starting row of the sub-grid\n            startCol = (col // 3) * 3  # Starting column of the sub-grid\n            for i in range(3):\n                for j in range(3):\n                    if board[startRow + i][startCol + j] == val:\n                        return False\n            return True\n\n        # Define a recursive backtracking function to solve the Sudoku puzzle\n        def solve(board):\n            # Iterate through each cell in the board\n            for row in range(9):\n                for col in range(9):\n                    # If the cell is empty\n                    if board[row][col] == \".\":\n                        # Try every possible digit from 1 to 9\n                        for val in \"123456789\":\n                            # Check if the current digit is valid in the current position\n                            if isValid(board, row, col, val):\n                                # Place the current digit in the current position\n                                board[row][col] = val\n                                # Recursively solve the puzzle\n                                if solve(board):\n                                    return True\n                                # If the puzzle cannot be solved with the current digit,\n                                # remove the digit from the current position\n                                board[row][col] = \".\"\n                        # If none of the digits is valid in the current position,\n                        # backtrack to the previous position\n                        return False\n            # If all cells are filled, the puzzle is solved\n            return True\n\n        # Call the backtracking function to solve the Sudoku puzzle\n        solve(board)\n", "n_pass": 1, "difficulty": 3.0, "frontend_question_id": 37.0, "loc": 36}
{"task_input": "\nLeetCode Problem #38\nTitle: Count and Say\nDescription:\nThe count-and-say sequence is a sequence of digit strings defined by the recursive formula:...\n countAndSay(1) = \"1\" countAndSay(n) is the way you would \"say\" the digit string from countAndSay(n-1), which is then converted into a different digit string. To determine how you \"say\" a digit string, split it into the minimal number of substrings such that each substring contains exactly one unique digit. Then for each substring, say the number of digits, then say the digit. Finally, concatenate every said digit. For example, the saying and conversion for digit string \"3322251\" : Given a positive integer n, return the n th term of the count-and-say sequence. Example 1: Input: n = 1 Output: \"1\" Explanation: This is the base case. Example 2: Input: n = 4 Output: \"1211\" Explanation: countAndSay(1) = \"1\" countAndSay(2) = say \"1\" = one 1 = \"11\" countAndSay(3) = say \"11\" = two 1's = \"21\" countAndSay(4) = say \"21\" = one 2 + one 1 = \"12\" + \"11\" = \"1211\" Constraints: 1 <= n <= 30\n", "code_prompt": "class Solution:\n    def countAndSay(self, n: int) -> str:\n        ", "raw_response": "```python\nclass Solution:\n    def countAndSay(self, n: int) -> str:\n        if n == 1:\n            return \"1\"\n        \n        # Recursive call to obtain the previous number in count-and-say sequence\n        prev = self.countAndSay(n-1)\n        \n        count = 1\n        result = \"\"\n        \n        # Iterate through the previous number\n        for i in range(len(prev)):\n            # If the current digit is the same as the next digit, increment the count\n            if i < len(prev)-1 and prev[i] == prev[i+1]:\n                count += 1\n            # If the current digit is different from the next digit, append the count and digit to the result\n            else:\n                result += str(count) + prev[i]\n                count = 1\n        \n        return result\n```\n\nThis solution uses recursion to obtain the previous number in the count-and-say sequence. It then iterates through the previous number and counts the consecutive occurrences of each digit, appending the count and digit to the result. The final result is returned.", "cleaned_response": "\nclass Solution:\n    def countAndSay(self, n: int) -> str:\n        if n == 1:\n            return \"1\"\n        \n        # Recursive call to obtain the previous number in count-and-say sequence\n        prev = self.countAndSay(n-1)\n        \n        count = 1\n        result = \"\"\n        \n        # Iterate through the previous number\n        for i in range(len(prev)):\n            # If the current digit is the same as the next digit, increment the count\n            if i < len(prev)-1 and prev[i] == prev[i+1]:\n                count += 1\n            # If the current digit is different from the next digit, append the count and digit to the result\n            else:\n                result += str(count) + prev[i]\n                count = 1\n        \n        return result\n", "n_pass": 1, "difficulty": 2.0, "frontend_question_id": 38.0, "loc": 37}
{"task_input": "\nLeetCode Problem #41\nTitle: First Missing Positive\nDescription:\nGiven an unsorted integer array nums, return the smallest missing positive integer. You must implement an algorithm that runs in O(n) time and uses O(1) auxiliary space. Example 1: Input: nums = [1, 2, 0] Output: 3 Explanation: The numbers in the range [1, 2] are all in the array. Example 2: Input: nums = [3, 4, -1, 1] Output: 2 Explanation: 1 is in the array but 2 is missing. Example 3: Input: nums = [7, 8, 9, 11, 12] Output: 1 Explanation: The smallest positive integer 1 is missing. Constraints: 1 <= nums.length <= 10e5 -2^31 <= nums[i] <= 2^31 - 1\n", "code_prompt": "class Solution:\n    def firstMissingPositive(self, nums: List[int]) -> int:\n        ", "raw_response": "```python\nclass Solution:\n    def firstMissingPositive(self, nums: List[int]) -> int:\n        # First, we need to remove any negative or zero elements from the array\n        # because we only care about positive integers\n        n = len(nums)\n        for i in range(n):\n            if nums[i] <= 0:\n                nums[i] = n + 1\n        \n        # Now, we mark the presence of positive integers by modifying the value at\n        # index nums[i] to be negative if i+1 is present in the array\n        for i in range(n):\n            num = abs(nums[i])\n            if num <= n:\n                nums[num-1] = -abs(nums[num-1])\n        \n        # Finally, we return the index of the first positive value in the array,\n        # which represents the smallest missing positive integer\n        for i in range(n):\n            if nums[i] > 0:\n                return i + 1\n        \n        # If all positive integers are present in the array, then the smallest\n        # missing positive integer is n+1\n        return n + 1\n```\n\nThe above code solves the problem by modifying the input array in-place. It first removes any negative or zero elements, and then marks the presence of positive integers by modifying the value at the corresponding index to be negative. Finally, it returns the index of the first positive value in the modified array, which represents the smallest missing positive integer. If all positive integers are present in the array, then the smallest missing positive integer is `n+1`, where `n` is the length of the array.", "cleaned_response": "\nclass Solution:\n    def firstMissingPositive(self, nums: List[int]) -> int:\n        # First, we need to remove any negative or zero elements from the array\n        # because we only care about positive integers\n        n = len(nums)\n        for i in range(n):\n            if nums[i] <= 0:\n                nums[i] = n + 1\n        \n        # Now, we mark the presence of positive integers by modifying the value at\n        # index nums[i] to be negative if i+1 is present in the array\n        for i in range(n):\n            num = abs(nums[i])\n            if num <= n:\n                nums[num-1] = -abs(nums[num-1])\n        \n        # Finally, we return the index of the first positive value in the array,\n        # which represents the smallest missing positive integer\n        for i in range(n):\n            if nums[i] > 0:\n                return i + 1\n        \n        # If all positive integers are present in the array, then the smallest\n        # missing positive integer is n+1\n        return n + 1\n", "n_pass": 1, "difficulty": 3.0, "frontend_question_id": 41.0, "loc": 40}
{"task_input": "\nLeetCode Problem #42\nTitle: Trapping Rain Water\nDescription:\nGiven n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining. Example 1: Input: height = [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1] Output: 6 Explanation: The above elevation map (black section) is represented by array [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]. In this case, 6 units of rain water (blue section) are being trapped. Example 2: Input: height = [4, 2, 0, 3, 2, 5] Output: 9 Constraints: n == height.length 1 <= n <= 2 * 10e4 0 <= height[i] <= 10e5\n", "code_prompt": "class Solution:\n    def trap(self, height: List[int]) -> int:\n        ", "raw_response": "```python\nfrom typing import List\n\nclass Solution:\n    def trap(self, height: List[int]) -> int:\n        if len(height) < 3:\n            return 0\n        \n        left_max = [0] * len(height)\n        right_max = [0] * len(height)\n        water = 0\n        \n        # Find the maximum height of a bar to the left of each bar\n        left_max[0] = height[0]\n        for i in range(1, len(height)):\n            left_max[i] = max(left_max[i-1], height[i])\n        \n        # Find the maximum height of a bar to the right of each bar\n        right_max[-1] = height[-1]\n        for i in range(len(height)-2, -1, -1):\n            right_max[i] = max(right_max[i+1], height[i])\n        \n        # Calculate the amount of water trapped at each bar\n        for i in range(len(height)):\n            water += min(left_max[i], right_max[i]) - height[i]\n        \n        return water\n```\n\nThe idea is to maintain two lists `left_max` and `right_max` to store the maximum height of bars to the left and right of each bar, respectively. Then, we iterate through the bars and calculate the amount of water trapped at each bar by taking the minimum of `left_max` and `right_max` at that position and subtracting it from the height of the bar. Finally, we return the total amount of water trapped.", "cleaned_response": "\nfrom typing import List\n\nclass Solution:\n    def trap(self, height: List[int]) -> int:\n        if len(height) < 3:\n            return 0\n        \n        left_max = [0] * len(height)\n        right_max = [0] * len(height)\n        water = 0\n        \n        # Find the maximum height of a bar to the left of each bar\n        left_max[0] = height[0]\n        for i in range(1, len(height)):\n            left_max[i] = max(left_max[i-1], height[i])\n        \n        # Find the maximum height of a bar to the right of each bar\n        right_max[-1] = height[-1]\n        for i in range(len(height)-2, -1, -1):\n            right_max[i] = max(right_max[i+1], height[i])\n        \n        # Calculate the amount of water trapped at each bar\n        for i in range(len(height)):\n            water += min(left_max[i], right_max[i]) - height[i]\n        \n        return water\n", "n_pass": 1, "difficulty": 3.0, "frontend_question_id": 42.0, "loc": 41}
{"task_input": "\nLeetCode Problem #44\nTitle: Wildcard Matching\nDescription:\nGiven an input string ( s ) and a pattern ( p ), implement wildcard pattern matching with support for '?' and '*' where:...\n '?' Matches any single character. '*' Matches any sequence of characters (including the empty sequence). The matching should cover the entire input string (not partial). Example 1: Input: s = \"aa\", p = \"a\" Output: false Explanation: \"a\" does not match the entire string \"aa\". Example 2: Input: s = \"aa\", p = \"*\" Output: true Explanation: '*' matches any sequence. Example 3: Input: s = \"cb\", p = \"?a\" Output: false Explanation: '?' matches 'c', but the second letter is 'a', which does not match 'b'. Constraints: 0 <= s.length, p.length <= 2000 s contains only lowercase English letters. p contains only lowercase English letters, '?' or '*'.\n", "code_prompt": "class Solution:\n    def isMatch(self, s: str, p: str) -> bool:\n        ", "raw_response": "```python\nclass Solution:\n    def isMatch(self, s: str, p: str) -> bool:\n        # Create a 2D DP table to store the results of subproblems\n        dp = [[False] * (len(p) + 1) for _ in range(len(s) + 1)]\n        \n        # Empty pattern matches empty string\n        dp[0][0] = True\n        \n        # Take care of patterns with '*' as the first character\n        for j in range(1, len(p) + 1):\n            if p[j-1] == '*':\n                dp[0][j] = dp[0][j-1]\n        \n        # Fill the DP table\n        for i in range(1, len(s) + 1):\n            for j in range(1, len(p) + 1):\n                if p[j-1] == '?' or p[j-1] == s[i-1]:\n                    dp[i][j] = dp[i-1][j-1]\n                elif p[j-1] == '*':\n                    dp[i][j] = dp[i-1][j] or dp[i][j-1]\n        \n        # Return the result\n        return dp[-1][-1]\n```", "cleaned_response": "\nclass Solution:\n    def isMatch(self, s: str, p: str) -> bool:\n        # Create a 2D DP table to store the results of subproblems\n        dp = [[False] * (len(p) + 1) for _ in range(len(s) + 1)]\n        \n        # Empty pattern matches empty string\n        dp[0][0] = True\n        \n        # Take care of patterns with '*' as the first character\n        for j in range(1, len(p) + 1):\n            if p[j-1] == '*':\n                dp[0][j] = dp[0][j-1]\n        \n        # Fill the DP table\n        for i in range(1, len(s) + 1):\n            for j in range(1, len(p) + 1):\n                if p[j-1] == '?' or p[j-1] == s[i-1]:\n                    dp[i][j] = dp[i-1][j-1]\n                elif p[j-1] == '*':\n                    dp[i][j] = dp[i-1][j] or dp[i][j-1]\n        \n        # Return the result\n        return dp[-1][-1]\n", "n_pass": 1, "difficulty": 3.0, "frontend_question_id": 44.0, "loc": 43}
{"task_input": "\nLeetCode Problem #45\nTitle: Jump Game II\nDescription:\nYou are given a 0-indexed array of integers nums of length n. You are initially positioned at nums[0]. Each element nums[i] represents the maximum length of a forward jump from index i. In other words, if you are at nums[i], you can jump to any nums[i + j] where: 0 <= j <= nums[i] and i + j < n Return the minimum number of jumps to reach nums[n - 1]. The test cases are generated such that you can reach nums[n - 1]. Example 1: Input: nums = [2, 3, 1, 1, 4] Output: 2 Explanation: The minimum number of jumps to reach the last index is 2. Jump 1 step from index 0 to 1, then 3 steps to the last index. Example 2: Input: nums = [2, 3, 0, 1, 4] Output: 2 Constraints: 1 <= nums.length <= 10e4 0 <= nums[i] <= 1000 It's guaranteed that you can reach nums[n - 1].\n", "code_prompt": "class Solution:\n    def jump(self, nums: List[int]) -> int:\n        ", "raw_response": "```python\nfrom typing import List\n\nclass Solution:\n    def jump(self, nums: List[int]) -> int:\n        if len(nums) <= 1:\n            return 0\n        \n        max_reach = nums[0] \n        steps = nums[0]\n        jumps = 1\n        \n        for i in range(1, len(nums)):\n            if i == len(nums) - 1:\n                return jumps\n            \n            max_reach = max(max_reach, i + nums[i])\n            steps -= 1\n            \n            if steps == 0:\n                jumps += 1\n                \n                if i >= max_reach:\n                    return -1\n                \n                steps = max_reach - i\n        \n        return -1\n```", "cleaned_response": "\nfrom typing import List\n\nclass Solution:\n    def jump(self, nums: List[int]) -> int:\n        if len(nums) <= 1:\n            return 0\n        \n        max_reach = nums[0] \n        steps = nums[0]\n        jumps = 1\n        \n        for i in range(1, len(nums)):\n            if i == len(nums) - 1:\n                return jumps\n            \n            max_reach = max(max_reach, i + nums[i])\n            steps -= 1\n            \n            if steps == 0:\n                jumps += 1\n                \n                if i >= max_reach:\n                    return -1\n                \n                steps = max_reach - i\n        \n        return -1\n", "n_pass": 1, "difficulty": 2.0, "frontend_question_id": 45.0, "loc": 44}
{"task_input": "\nLeetCode Problem #47\nTitle: Permutations II\nDescription:\nGiven a collection of numbers, nums, that might contain duplicates, return all possible unique permutations in any order. Example 1: Input: nums = [1, 1, 2] Output: [[1, 1, 2], [1, 2, 1], [2, 1, 1]] Example 2: Input: nums = [1, 2, 3] Output: [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]] Constraints: 1 <= nums.length <= 8 -10 <= nums[i] <= 10\n", "code_prompt": "class Solution:\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\n        ", "raw_response": "```python\nclass Solution:\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\n        # Sort the nums list to ensure duplicates are next to each other\n        nums.sort()\n        \n        # Create a list to store the unique permutations\n        unique_permutations = []\n        \n        # Create a helper function to compute permutations recursively\n        def backtrack(perm, counter):\n            # If the current permutation is of the same length as the input array, add it to the list of unique permutations\n            if len(perm) == len(nums):\n                unique_permutations.append(perm)\n                return\n            \n            # Iterate over each unique element in the counter dictionary\n            for num in counter:\n                # If the count of an element is 0, skip it\n                if counter[num] == 0:\n                    continue\n                \n                # Add the current element to the current permutation\n                perm.append(num)\n                \n                # Decrement the count of the current element in the counter dictionary\n                counter[num] -= 1\n                \n                # Recursive call to compute permutations with the updated permutation and counter\n                backtrack(perm, counter)\n                \n                # Remove the current element from the current permutation\n                perm.pop()\n                \n                # Increment the count of the current element in the counter dictionary\n                counter[num] += 1\n                \n        # Create a counter dictionary to track the count of each unique element in the nums list\n        counter = {}\n        \n        # Populate the counter dictionary\n        for num in nums:\n            counter[num] = counter.get(num, 0) + 1\n            \n        # Recursive call to compute permutations with an empty permutation and the counter\n        backtrack([], counter)\n        \n        return unique_permutations\n```\n\nThe above code defines a class `Solution` with a method `permuteUnique` that takes in a list of integers `nums` and returns a list of all possible unique permutations of the input array.\n\nThe code sorts the `nums` list to ensure that duplicate elements are next to each other. Then, it initializes an empty list `unique_permutations` to store the unique permutations.\n\nA helper function `backtrack` is defined to compute the permutations recursively. The function takes in two parameters: `perm` which represents the current permutation being constructed, and `counter` which is a dictionary that tracks the count of each unique element in the `nums` list.\n\nInside the `backtrack` function, if the length of the current permutation is equal to the length of the input array, the current permutation is added to the list of unique permutations.\n\nThe function then iterates over each unique element in the `counter` dictionary. If the count of an element is 0, it is skipped. Otherwise, the element is added to the current permutation, the count of the element is decremented, and a recursive call is made to compute permutations with the updated permutation and counter.\n\nAfter the recursive call, the current element is removed from the current permutation and the count of the element is incremented.\n\nThe code then creates a `counter` dictionary to track the count of each unique element in the `nums` list. It populates the `counter` dictionary by iterating over the `nums` list and adding each element to the dictionary with its count.\n\nFinally, a recursive call is made to the `backtrack` function with an empty permutation and the `counter` dictionary. The function returns the `unique_permutations` list containing all the unique permutations.", "cleaned_response": "\nclass Solution:\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\n        # Sort the nums list to ensure duplicates are next to each other\n        nums.sort()\n        \n        # Create a list to store the unique permutations\n        unique_permutations = []\n        \n        # Create a helper function to compute permutations recursively\n        def backtrack(perm, counter):\n            # If the current permutation is of the same length as the input array, add it to the list of unique permutations\n            if len(perm) == len(nums):\n                unique_permutations.append(perm)\n                return\n            \n            # Iterate over each unique element in the counter dictionary\n            for num in counter:\n                # If the count of an element is 0, skip it\n                if counter[num] == 0:\n                    continue\n                \n                # Add the current element to the current permutation\n                perm.append(num)\n                \n                # Decrement the count of the current element in the counter dictionary\n                counter[num] -= 1\n                \n                # Recursive call to compute permutations with the updated permutation and counter\n                backtrack(perm, counter)\n                \n                # Remove the current element from the current permutation\n                perm.pop()\n                \n                # Increment the count of the current element in the counter dictionary\n                counter[num] += 1\n                \n        # Create a counter dictionary to track the count of each unique element in the nums list\n        counter = {}\n        \n        # Populate the counter dictionary\n        for num in nums:\n            counter[num] = counter.get(num, 0) + 1\n            \n        # Recursive call to compute permutations with an empty permutation and the counter\n        backtrack([], counter)\n        \n        return unique_permutations\n", "n_pass": 1, "difficulty": 2.0, "frontend_question_id": 47.0, "loc": 46}
{"task_input": "\nLeetCode Problem #49\nTitle: Group Anagrams\nDescription:\nGiven an array of strings strs, group the anagrams together. You can return the answer in any order. An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once. Example 1: Input: strs = [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"] Output: [[\"bat\"], [\"nat\", \"tan\"], [\"ate\", \"eat\", \"tea\"]] Example 2: Input: strs = [\"\"] Output: [[\"\"]] Example 3: Input: strs = [\"a\"] Output: [[\"a\"]] Constraints: 1 <= strs.length <= 10e4 0 <= strs[i].length <= 100 strs[i] consists of lowercase English letters.\n", "code_prompt": "class Solution:\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\n        ", "raw_response": "```python\nfrom collections import defaultdict\n\nclass Solution:\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\n        # Create a defaultdict to store the anagrams\n        # The keys will be sorted versions of the words (since anagrams have the same sorted order)\n        # The values will be lists of words that are anagrams of each other\n        anagrams = defaultdict(list)\n        \n        # Iterate through the input list of strings\n        for word in strs:\n            # Sort the word and convert it back to a string\n            sorted_word = \"\".join(sorted(word))\n            \n            # Append the word to the list of anagrams for the sorted word\n            anagrams[sorted_word].append(word)\n        \n        # Convert the dictionary values to a list and return the result\n        return list(anagrams.values())\n```\nThe code uses a `defaultdict` from the `collections` module to store the anagrams. It iterates through the input list of strings and creates a sorted version of each word. This sorted word is then used as a key in the `anagrams` dictionary, and the original word is appended to the list of anagrams for that key. Finally, the function converts the values of the `anagrams` dictionary to a list and returns it.", "cleaned_response": "\nfrom collections import defaultdict\n\nclass Solution:\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\n        # Create a defaultdict to store the anagrams\n        # The keys will be sorted versions of the words (since anagrams have the same sorted order)\n        # The values will be lists of words that are anagrams of each other\n        anagrams = defaultdict(list)\n        \n        # Iterate through the input list of strings\n        for word in strs:\n            # Sort the word and convert it back to a string\n            sorted_word = \"\".join(sorted(word))\n            \n            # Append the word to the list of anagrams for the sorted word\n            anagrams[sorted_word].append(word)\n        \n        # Convert the dictionary values to a list and return the result\n        return list(anagrams.values())\n", "n_pass": 1, "difficulty": 2.0, "frontend_question_id": 49.0, "loc": 48}
{"task_input": "\nLeetCode Problem #51\nTitle: N-Queens\nDescription:\nThe n-queens puzzle is the problem of placing n queens on an n x n chessboard such that no two queens attack each other. Given an integer n, return all distinct solutions to the n-queens puzzle. You may return the answer in any order. Each solution contains a distinct board configuration of the n-queens' placement, where 'Q' and . both indicate a queen and an empty space, respectively. Example 1: Input: n = 4 Output: [[\". Q. . \", \". . . Q\", \"Q. . . \", \". . Q. \"], [\". . Q. \", \"Q. . . \", \". . . Q\", \". Q. . \"]] Explanation: There exist two distinct solutions to the 4-queens puzzle as shown above Example 2: Input: n = 1 Output: [[\"Q\"]] Constraints: 1 <= n <= 9\n", "code_prompt": "class Solution:\n    def solveNQueens(self, n: int) -> List[List[str]]:\n        ", "raw_response": "```python\nclass Solution:\n    def solveNQueens(self, n: int) -> List[List[str]]:\n        # Initialize empty result list\n        result = []\n        \n        # Helper function to check if a queen can be placed at (row, col)\n        def is_valid(board, row, col):\n            # Check if there is a queen in the same column\n            for i in range(row):\n                if board[i][col] == 'Q':\n                    return False\n            \n            # Check if there is a queen in the upper-left diagonal\n            i = row - 1\n            j = col - 1\n            while i >= 0 and j >= 0:\n                if board[i][j] == 'Q':\n                    return False\n                i -= 1\n                j -= 1\n            \n            # Check if there is a queen in the upper-right diagonal\n            i = row - 1\n            j = col + 1\n            while i >= 0 and j < n:\n                if board[i][j] == 'Q':\n                    return False\n                i -= 1\n                j += 1\n            \n            return True\n        \n        # Helper function to convert the board to a list of strings\n        def board_to_list(board):\n            return [''.join(row) for row in board]\n        \n        # Helper function to solve the N-Queens problem recursively\n        def backtrack(row, board):\n            # Base case: All queens are placed\n            if row == n:\n                result.append(board_to_list(board))\n                return\n            \n            # Try placing a queen in each column of the current row\n            for col in range(n):\n                if is_valid(board, row, col):\n                    # Place the queen\n                    board[row][col] = 'Q'\n                    # Recursively solve for the next row\n                    backtrack(row + 1, board)\n                    # Remove the queen (backtracking)\n                    board[row][col] = '.'\n        \n        # Initialize the chessboard as a list of lists\n        board = [['.' for _ in range(n)] for _ in range(n)]\n        \n        # Start the backtracking algorithm from the first row\n        backtrack(0, board)\n        \n        return result\n```", "cleaned_response": "\nclass Solution:\n    def solveNQueens(self, n: int) -> List[List[str]]:\n        # Initialize empty result list\n        result = []\n        \n        # Helper function to check if a queen can be placed at (row, col)\n        def is_valid(board, row, col):\n            # Check if there is a queen in the same column\n            for i in range(row):\n                if board[i][col] == 'Q':\n                    return False\n            \n            # Check if there is a queen in the upper-left diagonal\n            i = row - 1\n            j = col - 1\n            while i >= 0 and j >= 0:\n                if board[i][j] == 'Q':\n                    return False\n                i -= 1\n                j -= 1\n            \n            # Check if there is a queen in the upper-right diagonal\n            i = row - 1\n            j = col + 1\n            while i >= 0 and j < n:\n                if board[i][j] == 'Q':\n                    return False\n                i -= 1\n                j += 1\n            \n            return True\n        \n        # Helper function to convert the board to a list of strings\n        def board_to_list(board):\n            return [''.join(row) for row in board]\n        \n        # Helper function to solve the N-Queens problem recursively\n        def backtrack(row, board):\n            # Base case: All queens are placed\n            if row == n:\n                result.append(board_to_list(board))\n                return\n            \n            # Try placing a queen in each column of the current row\n            for col in range(n):\n                if is_valid(board, row, col):\n                    # Place the queen\n                    board[row][col] = 'Q'\n                    # Recursively solve for the next row\n                    backtrack(row + 1, board)\n                    # Remove the queen (backtracking)\n                    board[row][col] = '.'\n        \n        # Initialize the chessboard as a list of lists\n        board = [['.' for _ in range(n)] for _ in range(n)]\n        \n        # Start the backtracking algorithm from the first row\n        backtrack(0, board)\n        \n        return result\n", "n_pass": 1, "difficulty": 3.0, "frontend_question_id": 51.0, "loc": 50}
{"task_input": "\nLeetCode Problem #52\nTitle: N-Queens II\nDescription:\nThe n-queens puzzle is the problem of placing n queens on an n x n chessboard such that no two queens attack each other. Given an integer n, return the number of distinct solutions to the n-queens puzzle. Example 1: Input: n = 4 Output: 2 Explanation: There are two distinct solutions to the 4-queens puzzle as shown. Example 2: Input: n = 1 Output: 1 Constraints: 1 <= n <= 9\n", "code_prompt": "class Solution:\n    def totalNQueens(self, n: int) -> int:\n        ", "raw_response": "```python\nclass Solution:\n    def totalNQueens(self, n: int) -> int:\n        # Create an empty chessboard of size n x n\n        chessboard = [[\".\"] * n for _ in range(n)]\n        \n        # Define a helper function to check if it is safe to place a queen at given position\n        def is_safe(row, col):\n            # Check for any queens in the same column\n            for i in range(row):\n                if chessboard[i][col] == \"Q\":\n                    return False\n            \n            # Check for any queens in the upper-left diagonal\n            i = row - 1\n            j = col - 1\n            while i >= 0 and j >= 0:\n                if chessboard[i][j] == \"Q\":\n                    return False\n                i -= 1\n                j -= 1\n            \n            # Check for any queens in the upper-right diagonal\n            i = row - 1\n            j = col + 1\n            while i >= 0 and j < n:\n                if chessboard[i][j] == \"Q\":\n                    return False\n                i -= 1\n                j += 1\n            \n            return True\n        \n        # Define a recursive helper function to solve the n-queens puzzle\n        def solve(row):\n            if row == n:\n                # All queens have been placed, increment the count of distinct solutions\n                return 1\n            \n            count = 0\n            \n            # Try placing a queen in each column of the current row\n            for col in range(n):\n                if is_safe(row, col):\n                    chessboard[row][col] = \"Q\"  # Place a queen\n                    count += solve(row + 1)  # Recursively solve for the next row\n                    chessboard[row][col] = \".\"  # Backtrack\n                    \n            return count\n        \n        # Call the recursive helper function to solve the n-queens puzzle\n        return solve(0)\n```", "cleaned_response": "\nclass Solution:\n    def totalNQueens(self, n: int) -> int:\n        # Create an empty chessboard of size n x n\n        chessboard = [[\".\"] * n for _ in range(n)]\n        \n        # Define a helper function to check if it is safe to place a queen at given position\n        def is_safe(row, col):\n            # Check for any queens in the same column\n            for i in range(row):\n                if chessboard[i][col] == \"Q\":\n                    return False\n            \n            # Check for any queens in the upper-left diagonal\n            i = row - 1\n            j = col - 1\n            while i >= 0 and j >= 0:\n                if chessboard[i][j] == \"Q\":\n                    return False\n                i -= 1\n                j -= 1\n            \n            # Check for any queens in the upper-right diagonal\n            i = row - 1\n            j = col + 1\n            while i >= 0 and j < n:\n                if chessboard[i][j] == \"Q\":\n                    return False\n                i -= 1\n                j += 1\n            \n            return True\n        \n        # Define a recursive helper function to solve the n-queens puzzle\n        def solve(row):\n            if row == n:\n                # All queens have been placed, increment the count of distinct solutions\n                return 1\n            \n            count = 0\n            \n            # Try placing a queen in each column of the current row\n            for col in range(n):\n                if is_safe(row, col):\n                    chessboard[row][col] = \"Q\"  # Place a queen\n                    count += solve(row + 1)  # Recursively solve for the next row\n                    chessboard[row][col] = \".\"  # Backtrack\n                    \n            return count\n        \n        # Call the recursive helper function to solve the n-queens puzzle\n        return solve(0)\n", "n_pass": 1, "difficulty": 3.0, "frontend_question_id": 52.0, "loc": 51}
{"task_input": "\nLeetCode Problem #53\nTitle: Maximum Subarray\nDescription:\nGiven an integer array nums, find the subarray with the largest sum, and return its sum. Example 1: Input: nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4] Output: 6 Explanation: The subarray [4, -1, 2, 1] has the largest sum 6. Example 2: Input: nums = [1] Output: 1 Explanation: The subarray [1] has the largest sum 1. Example 3: Input: nums = [5, 4, -1, 7, 8] Output: 23 Explanation: The subarray [5, 4, -1, 7, 8] has the largest sum 23. Constraints: 1 <= nums.length <= 10e5 -10e4 <= nums[i] <= 10e4 Follow up: If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle.\n", "code_prompt": "class Solution:\n    def maxSubArray(self, nums: List[int]) -> int:\n        ", "raw_response": "```python\nfrom typing import List\n\nclass Solution:\n    def maxSubArray(self, nums: List[int]) -> int:\n        if not nums:\n            return 0\n        \n        curr_sum = max_sum = nums[0]\n        \n        for i in range(1, len(nums)):\n            curr_sum = max(nums[i], curr_sum + nums[i])\n            max_sum = max(max_sum, curr_sum)\n        \n        return max_sum\n```", "cleaned_response": "\nfrom typing import List\n\nclass Solution:\n    def maxSubArray(self, nums: List[int]) -> int:\n        if not nums:\n            return 0\n        \n        curr_sum = max_sum = nums[0]\n        \n        for i in range(1, len(nums)):\n            curr_sum = max(nums[i], curr_sum + nums[i])\n            max_sum = max(max_sum, curr_sum)\n        \n        return max_sum\n", "n_pass": 1, "difficulty": 2.0, "frontend_question_id": 53.0, "loc": 52}
{"task_input": "\nLeetCode Problem #54\nTitle: Spiral Matrix\nDescription:\nGiven an m x n matrix, return all elements of the matrix in spiral order. Example 1: Input: matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]] Output: [1, 2, 3, 6, 9, 8, 7, 4, 5] Example 2: Input: matrix = [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]] Output: [1, 2, 3, 4, 8, 12, 11, 10, 9, 5, 6, 7] Constraints: m == matrix.length n == matrix[i].length 1 <= m, n <= 10 -100 <= matrix[i][j] <= 100\n", "code_prompt": "class Solution:\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\n        ", "raw_response": "class Solution:\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\n        if not matrix:\n            return []\n\n        m, n = len(matrix), len(matrix[0])\n        row_start, row_end = 0, m - 1\n        col_start, col_end = 0, n - 1\n        result = []\n\n        while row_start <= row_end and col_start <= col_end:\n            \n            # Traverse right\n            for j in range(col_start, col_end + 1):\n                result.append(matrix[row_start][j])\n            row_start += 1\n            \n            # Traverse down\n            for i in range(row_start, row_end + 1):\n                result.append(matrix[i][col_end])\n            col_end -= 1\n            \n            if row_start <= row_end:\n                # Traverse left\n                for j in range(col_end, col_start - 1, -1):\n                    result.append(matrix[row_end][j])\n                row_end -= 1\n            \n            if col_start <= col_end:\n                # Traverse up\n                for i in range(row_end, row_start - 1, -1):\n                    result.append(matrix[i][col_start])\n                col_start += 1\n                \n        return result", "cleaned_response": "class Solution:\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\n        if not matrix:\n            return []\n\n        m, n = len(matrix), len(matrix[0])\n        row_start, row_end = 0, m - 1\n        col_start, col_end = 0, n - 1\n        result = []\n\n        while row_start <= row_end and col_start <= col_end:\n            \n            # Traverse right\n            for j in range(col_start, col_end + 1):\n                result.append(matrix[row_start][j])\n            row_start += 1\n            \n            # Traverse down\n            for i in range(row_start, row_end + 1):\n                result.append(matrix[i][col_end])\n            col_end -= 1\n            \n            if row_start <= row_end:\n                # Traverse left\n                for j in range(col_end, col_start - 1, -1):\n                    result.append(matrix[row_end][j])\n                row_end -= 1\n            \n            if col_start <= col_end:\n                # Traverse up\n                for i in range(row_end, row_start - 1, -1):\n                    result.append(matrix[i][col_start])\n                col_start += 1\n                \n        return result", "n_pass": 1, "difficulty": 2.0, "frontend_question_id": 54.0, "loc": 53}
{"task_input": "\nLeetCode Problem #57\nTitle: Insert Interval\nDescription:\nYou are given an array of non-overlapping intervals intervals where intervals[i] = [start i, end i ] represent the start and the end of the i th interval and intervals is sorted in ascending order by start i. You are also given an interval newInterval = [start, end] that represents the start and end of another interval. Insert newInterval into intervals such that intervals is still sorted in ascending order by start i and intervals still does not have any overlapping intervals (merge overlapping intervals if necessary). Return intervals after the insertion. Example 1: Input: intervals = [[1, 3], [6, 9]], newInterval = [2, 5] Output: [[1, 5], [6, 9]] Example 2: Input: intervals = [[1, 2], [3, 5], [6, 7], [8, 10], [12, 16]], newInterval = [4, 8] Output: [[1, 2], [3, 10], [12, 16]] Explanation: Because the new interval [4, 8] overlaps with [3, 5], [6, 7], [8, 10]. Constraints: 0 <= intervals.length <= 10e4 intervals[i].length == 2^0 <= start i <= end i <= 10e5 intervals is sorted by start i in ascending order. newInterval.length == 2^0 <= start <= end <= 10e5\n", "code_prompt": "class Solution:\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\n        ", "raw_response": "```python\nclass Solution:\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\n        merged = []\n        i = 0\n        \n        # Add intervals before the newInterval that do not overlap\n        while i < len(intervals) and intervals[i][1] < newInterval[0]:\n            merged.append(intervals[i])\n            i += 1\n        \n        # Merge intervals that overlap with the newInterval\n        while i < len(intervals) and intervals[i][0] <= newInterval[1]:\n            newInterval[0] = min(newInterval[0], intervals[i][0])\n            newInterval[1] = max(newInterval[1], intervals[i][1])\n            i += 1\n        \n        merged.append(newInterval)\n        \n        # Add remaining intervals after the newInterval that do not overlap\n        while i < len(intervals):\n            merged.append(intervals[i])\n            i += 1\n        \n        return merged\n```", "cleaned_response": "\nclass Solution:\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\n        merged = []\n        i = 0\n        \n        # Add intervals before the newInterval that do not overlap\n        while i < len(intervals) and intervals[i][1] < newInterval[0]:\n            merged.append(intervals[i])\n            i += 1\n        \n        # Merge intervals that overlap with the newInterval\n        while i < len(intervals) and intervals[i][0] <= newInterval[1]:\n            newInterval[0] = min(newInterval[0], intervals[i][0])\n            newInterval[1] = max(newInterval[1], intervals[i][1])\n            i += 1\n        \n        merged.append(newInterval)\n        \n        # Add remaining intervals after the newInterval that do not overlap\n        while i < len(intervals):\n            merged.append(intervals[i])\n            i += 1\n        \n        return merged\n", "n_pass": 1, "difficulty": 2.0, "frontend_question_id": 57.0, "loc": 56}
{"task_input": "\nLeetCode Problem #60\nTitle: Permutation Sequence\nDescription:\nThe set [1, 2, 3,. . . , n] contains a total of n! unique permutations. By listing and labeling all of the permutations in order, we get the following sequence for n = 3 : \"123\" \"132\" \"213\" \"231\" \"312\" \"321\" Given n and k, return the k th permutation sequence. Example 1: Input: n = 3, k = 3 Output: \"213\" Example 2: Input: n = 4, k = 9 Output: \"2314\" Example 3: Input: n = 3, k = 1 Output: \"123\" Constraints: 1 <= n <= 9^1 <= k <= n!\n", "code_prompt": "class Solution:\n    def getPermutation(self, n: int, k: int) -> str:\n        ", "raw_response": "```python\nclass Solution:\n    def getPermutation(self, n: int, k: int) -> str:\n        # Create a list of numbers from 1 to n\n        nums = [str(i) for i in range(1, n+1)]\n        \n        # Calculate the factorial of n\n        fact = 1\n        for i in range(1, n+1):\n            fact *= i\n        \n        # Create a list to store the result sequence\n        res = []\n        \n        # Decrement k by 1 to align with list indices\n        k -= 1\n        \n        # Iterate through each digit in the result sequence\n        for i in range(n):\n            # Calculate the index of the current digit in nums\n            index = k // (fact // n)\n            \n            # Add the corresponding digit to the result sequence\n            res.append(nums[index])\n            \n            # Remove the digit from nums\n            nums.pop(index)\n            \n            # Update k and fact for the next iteration\n            k %= fact // n\n            fact //= n\n            n -= 1\n        \n        # Return the result sequence as a string\n        return ''.join(res)\n```", "cleaned_response": "\nclass Solution:\n    def getPermutation(self, n: int, k: int) -> str:\n        # Create a list of numbers from 1 to n\n        nums = [str(i) for i in range(1, n+1)]\n        \n        # Calculate the factorial of n\n        fact = 1\n        for i in range(1, n+1):\n            fact *= i\n        \n        # Create a list to store the result sequence\n        res = []\n        \n        # Decrement k by 1 to align with list indices\n        k -= 1\n        \n        # Iterate through each digit in the result sequence\n        for i in range(n):\n            # Calculate the index of the current digit in nums\n            index = k // (fact // n)\n            \n            # Add the corresponding digit to the result sequence\n            res.append(nums[index])\n            \n            # Remove the digit from nums\n            nums.pop(index)\n            \n            # Update k and fact for the next iteration\n            k %= fact // n\n            fact //= n\n            n -= 1\n        \n        # Return the result sequence as a string\n        return ''.join(res)\n", "n_pass": 1, "difficulty": 3.0, "frontend_question_id": 60.0, "loc": 59}
{"task_input": "\nLeetCode Problem #65\nTitle: Valid Number\nDescription:\nA valid number can be split up into these components (in order):...\n A decimal number or an integer. (Optional) An 'e' or 'E', followed by an integer. A decimal number can be split up into these components (in order): (Optional) A sign character (either '+' or '-' ). One of the following formats: One or more digits, followed by a dot .. One or more digits, followed by a dot ., followed by one or more digits. A dot ., followed by one or more digits. An integer can be split up into these components (in order): (Optional) A sign character (either '+' or '-' ). One or more digits. For example, all the following are valid numbers: [\"2\", \"0089\", \"-0. 1\", \"+3. 14\", \"4. \", \"-. 9\", \"2e10\", \"-90E3\", \"3e+7\", \"+6e-1\", \"53. 5e93\", \"-123. 456e789\"], while the following are not valid numbers: [\"abc\", \"1a\", \"1e\", \"e3\", \"99e2. 5\", \"--6\", \"-+3\", \"95a54e53\"]. Given a string s, return true if s is a valid number. Example 1: Input: s = \"0\" Output: true Example 2: Input: s = \"e\" Output: false Example 3: Input: s = \". \" Output: false Constraints: 1 <= s.length <= 20 s consists of only English letters (both uppercase and lowercase), digits ( 0-9 ), plus '+', minus '-', or dot ..\n", "code_prompt": "class Solution:\n    def isNumber(self, s: str) -> bool:\n        ", "raw_response": "```python\nclass Solution:\n    def isNumber(self, s: str) -> bool:\n        s = s.strip()  # Remove leading and trailing whitespaces\n        \n        # State variables\n        seen_digit = False\n        seen_dot = False\n        seen_exponent = False\n        \n        for i in range(len(s)):\n            if s[i].isdigit():\n                seen_digit = True\n            elif s[i] == '.':\n                # A dot is only valid if we haven't seen one before and we haven't seen an exponent\n                if seen_dot or seen_exponent:\n                    return False\n                seen_dot = True\n            elif s[i] == 'e' or s[i] == 'E':\n                # An exponent is only valid if we haven't seen one before and we have seen at least one digit\n                if seen_exponent or not seen_digit:\n                    return False\n                seen_exponent = True\n                seen_digit = False  # Reset the seen_digit flag for the digits after the exponent\n            elif s[i] == '+' or s[i] == '-':\n                # Plus and minus signs are only valid in the beginning or right after the exponent\n                if i != 0 and s[i-1] != 'e' and s[i-1] != 'E':\n                    return False\n            else:  # Invalid character\n                return False\n        \n        # Check if we have seen at least one digit\n        if not seen_digit:\n            return False\n        \n        return True\n```", "cleaned_response": "\nclass Solution:\n    def isNumber(self, s: str) -> bool:\n        s = s.strip()  # Remove leading and trailing whitespaces\n        \n        # State variables\n        seen_digit = False\n        seen_dot = False\n        seen_exponent = False\n        \n        for i in range(len(s)):\n            if s[i].isdigit():\n                seen_digit = True\n            elif s[i] == '.':\n                # A dot is only valid if we haven't seen one before and we haven't seen an exponent\n                if seen_dot or seen_exponent:\n                    return False\n                seen_dot = True\n            elif s[i] == 'e' or s[i] == 'E':\n                # An exponent is only valid if we haven't seen one before and we have seen at least one digit\n                if seen_exponent or not seen_digit:\n                    return False\n                seen_exponent = True\n                seen_digit = False  # Reset the seen_digit flag for the digits after the exponent\n            elif s[i] == '+' or s[i] == '-':\n                # Plus and minus signs are only valid in the beginning or right after the exponent\n                if i != 0 and s[i-1] != 'e' and s[i-1] != 'E':\n                    return False\n            else:  # Invalid character\n                return False\n        \n        # Check if we have seen at least one digit\n        if not seen_digit:\n            return False\n        \n        return True\n", "n_pass": 1, "difficulty": 3.0, "frontend_question_id": 65.0, "loc": 64}
{"task_input": "\nLeetCode Problem #68\nTitle: Text Justification\nDescription:\nGiven an array of strings words and a width maxWidth, format the text such that each line has exactly maxWidth characters and is fully (left and right) justified. You should pack your words in a greedy approach; that is, pack as many words as you can in each line. Pad extra spaces ' ' when necessary so that each line has exactly maxWidth characters. Extra spaces between words should be distributed as evenly as possible. If the number of spaces on a line does not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right. For the last line of text, it should be left-justified, and no extra space is inserted between words. Note: A word is defined as a character sequence consisting of non-space characters only. Each word's length is guaranteed to be greater than 0 and not exceed maxWidth. The input array words contains at least one word. Example 1: Input: words = [\"This\", \"is\", \"an\", \"example\", \"of\", \"text\", \"justification. \"], maxWidth = 16 Output: [ \"This is an\", \"example of text\", \"justification. \" ] Example 2: Input: words = [\"What\", \"must\", \"be\", \"acknowledgment\", \"shall\", \"be\"], maxWidth = 16 Output: [ \"What must be\", \"acknowledgment \", \"shall be \" ] Explanation: Note that the last line is \"shall be \" instead of \"shall be\", because the last line must be left-justified instead of fully-justified. Note that the second line is also left-justified because it contains only one word. Example 3: Input: words = [\"Science\", \"is\", \"what\", \"we\", \"understand\", \"well\", \"enough\", \"to\", \"explain\", \"to\", \"a\", \"computer. \", \"Art\", \"is\", \"everything\", \"else\", \"we\", \"do\"], maxWidth = 20 Output: [ \"Science is what we\", \"understand well\", \"enough to explain to\", \"a computer. Art is\", \"everything else we\", \"do \" ] Constraints: 1 <= words.length <= 300^1 <= words[i].length <= 20 words[i] consists of only English letters and symbols. 1 <= maxWidth <= 100 words[i].length <= maxWidth\n", "code_prompt": "class Solution:\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\n        ", "raw_response": "```python\nfrom typing import List\n\n\nclass Solution:\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\n        result = []\n        current_line = []\n        current_length = 0\n        \n        for word in words:\n            # If adding the word exceeds the maximum width, justify the current line\n            if current_length + len(current_line) + len(word) > maxWidth:\n                result.append(self.justify_line(current_line, maxWidth))\n                current_line = []\n                current_length = 0\n            \n            current_line.append(word)\n            current_length += len(word)\n        \n        # Last line (left justification)\n        result.append(self.left_justify_line(current_line, maxWidth))\n        \n        return result\n    \n    def justify_line(self, words: List[str], maxWidth: int) -> str:\n        # If the line contains only one word, left justify it\n        if len(words) == 1:\n            return words[0] + \" \" * (maxWidth - len(words[0]))\n        \n        word_length = sum(len(word) for word in words)\n        space_length = maxWidth - word_length\n        space_count = len(words) - 1\n        avg_space_length = space_length // space_count\n        extra_space_count = space_length % space_count\n        \n        line = \"\"\n        for i in range(len(words)):\n            line += words[i]\n            \n            # Add average number of spaces between words\n            if i != len(words) - 1:\n                line += \" \" * avg_space_length\n                \n                # Add extra space if there are remaining\n                if i < extra_space_count:\n                    line += \" \"\n        \n        return line\n    \n    def left_justify_line(self, words: List[str], maxWidth: int) -> str:\n        line = \" \".join(words)\n        line += \" \" * (maxWidth - len(line))\n        \n        return line\n```\n\nThe algorithm above solves the Text Justification problem on LeetCode. The `fullJustify` function takes in a list of words and a maximum width and returns a list of fully justified lines of text.\n\nThe algorithm works by iterating through each word in the input list. It maintains a `current_line` list and a `current_length` variable to keep track of the words and their combined length on the current line.\n\nIf adding the next word to the current line exceeds the maximum width, the `justify_line` function is called to fully justify the line and add it to the result list. Then, a new line is started with the current word.\n\nAfter processing all words, the last line is left justified using the `left_justify_line` function.\n\nThe `justify_line` function is responsible for distributing the extra spaces between words to ensure that the line has exactly `maxWidth` characters. If the line contains only one word, it is left justified by padding it with spaces on the right.\n\nThe `left_justify_line` function simply joins the words with a single space and adds extra spaces on the right to reach the maximum width.\n\nThe algorithm runs in linear time complexity, as it iterates through each word in the input list exactly once.", "cleaned_response": "\nfrom typing import List\n\n\nclass Solution:\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\n        result = []\n        current_line = []\n        current_length = 0\n        \n        for word in words:\n            # If adding the word exceeds the maximum width, justify the current line\n            if current_length + len(current_line) + len(word) > maxWidth:\n                result.append(self.justify_line(current_line, maxWidth))\n                current_line = []\n                current_length = 0\n            \n            current_line.append(word)\n            current_length += len(word)\n        \n        # Last line (left justification)\n        result.append(self.left_justify_line(current_line, maxWidth))\n        \n        return result\n    \n    def justify_line(self, words: List[str], maxWidth: int) -> str:\n        # If the line contains only one word, left justify it\n        if len(words) == 1:\n            return words[0] + \" \" * (maxWidth - len(words[0]))\n        \n        word_length = sum(len(word) for word in words)\n        space_length = maxWidth - word_length\n        space_count = len(words) - 1\n        avg_space_length = space_length // space_count\n        extra_space_count = space_length % space_count\n        \n        line = \"\"\n        for i in range(len(words)):\n            line += words[i]\n            \n            # Add average number of spaces between words\n            if i != len(words) - 1:\n                line += \" \" * avg_space_length\n                \n                # Add extra space if there are remaining\n                if i < extra_space_count:\n                    line += \" \"\n        \n        return line\n    \n    def left_justify_line(self, words: List[str], maxWidth: int) -> str:\n        line = \" \".join(words)\n        line += \" \" * (maxWidth - len(line))\n        \n        return line\n", "n_pass": 1, "difficulty": 3.0, "frontend_question_id": 68.0, "loc": 67}
{"task_input": "\nLeetCode Problem #71\nTitle: Simplify Path\nDescription:\nGiven a string path, which is an absolute path (starting with a slash '/' ) to a file or directory in a Unix-style file system, convert it to the simplified canonical path. In a Unix-style file system, a period . refers to the current directory, a double period '. . ' refers to the directory up a level, and any multiple consecutive slashes (i. e. '//' ) are treated as a single slash '/'. For this problem, any other format of periods such as '. . . ' are treated as file/directory names. The canonical path should have the following format: The path starts with a single slash '/'. Any two directories are separated by a single slash '/'. The path does not end with a trailing '/'. The path only contains the directories on the path from the root directory to the target file or directory (i. e. , no period . or double period '. . ' ) Return the simplified canonical path. Example 1: Input: path = \"/home/\" Output: \"/home\" Explanation: Note that there is no trailing slash after the last directory name. Example 2: Input: path = \"/. . /\" Output: \"/\" Explanation: Going one level up from the root directory is a no-op, as the root level is the highest level you can go. Example 3: Input: path = \"/home//foo/\" Output: \"/home/foo\" Explanation: In the canonical path, multiple consecutive slashes are replaced by a single one. Constraints: 1 <= path.length <= 3000 path consists of English letters, digits, period ., slash '/' or '_'. path is a valid absolute Unix path.\n", "code_prompt": "class Solution:\n    def simplifyPath(self, path: str) -> str:\n        ", "raw_response": "```python\nclass Solution:\n    def simplifyPath(self, path: str) -> str:\n        stack = []\n        canonical_path = ''\n        \n        # Split the input path by '/'\n        path_list = path.split('/')\n        \n        for directory in path_list:\n            # If the current directory is empty or a period '.', ignore it\n            if directory == '' or directory == '.':\n                continue\n            # If the current directory is a double period '..', go one level up in the directory\n            elif directory == '..':\n                # Check if the stack is empty or the current directory is already at the root level\n                if stack and stack[-1] != '/':\n                    stack.pop()\n            # Otherwise, add the directory to the stack\n            else:\n                stack.append('/' + directory)\n        \n        # Join the directories in the stack to form the canonical path\n        canonical_path = ''.join(stack)\n        \n        # If the canonical path is empty, return the root '/' path\n        if canonical_path == '':\n            return '/'\n        return canonical_path\n```\n\nThe given function definition completes the `simplifyPath` function. It takes a string `path` as input and returns a string that represents the simplified canonical path according to the given requirements.\n\nThe function first creates an empty stack and an empty string `canonical_path` to store the simplified path.\n\nNext, it splits the input `path` by '/' into a list of directories.\n\nThen, it iterates through each directory in the list:\n\n- If the current directory is empty or a period '.', it is ignored and the iteration proceeds to the next directory.\n- If the current directory is a double period '..', it means to go one level up in the directory structure. In that case, the function checks if the stack is empty or if the current directory is already at the root level. If not, it pops the top directory from the stack.\n- Otherwise, the current directory is a valid directory name. It is appended to the stack with a preceding '/'.\n\nAfter iterating through all the directories, the function joins the directories in the stack to form the simplified canonical path.\n\nIf the canonical path is empty, it means that the input path was either empty or contained only periods. In that case, the function returns the root '/' path.\n\nOtherwise, it returns the simplified canonical path.", "cleaned_response": "\nclass Solution:\n    def simplifyPath(self, path: str) -> str:\n        stack = []\n        canonical_path = ''\n        \n        # Split the input path by '/'\n        path_list = path.split('/')\n        \n        for directory in path_list:\n            # If the current directory is empty or a period '.', ignore it\n            if directory == '' or directory == '.':\n                continue\n            # If the current directory is a double period '..', go one level up in the directory\n            elif directory == '..':\n                # Check if the stack is empty or the current directory is already at the root level\n                if stack and stack[-1] != '/':\n                    stack.pop()\n            # Otherwise, add the directory to the stack\n            else:\n                stack.append('/' + directory)\n        \n        # Join the directories in the stack to form the canonical path\n        canonical_path = ''.join(stack)\n        \n        # If the canonical path is empty, return the root '/' path\n        if canonical_path == '':\n            return '/'\n        return canonical_path\n", "n_pass": 1, "difficulty": 2.0, "frontend_question_id": 71.0, "loc": 70}
{"task_input": "\nLeetCode Problem #72\nTitle: Edit Distance\nDescription:\nGiven two strings word1 and word2, return the minimum number of operations required to convert word1 to word2. You have the following three operations permitted on a word: Insert a character Delete a character Replace a character Example 1: Input: word1 = \"horse\", word2 = \"ros\" Output: 3 Explanation: horse -> rorse (replace 'h' with 'r') rorse -> rose (remove 'r') rose -> ros (remove 'e') Example 2: Input: word1 = \"intention\", word2 = \"execution\" Output: 5 Explanation: intention -> inention (remove 't') inention -> enention (replace 'i' with 'e') enention -> exention (replace 'n' with 'x') exention -> exection (replace 'n' with 'c') exection -> execution (insert 'u') Constraints: 0 <= word1.length, word2.length <= 500 word1 and word2 consist of lowercase English letters.\n", "code_prompt": "class Solution:\n    def minDistance(self, word1: str, word2: str) -> int:\n        ", "raw_response": "```python\nclass Solution:\n    def minDistance(self, word1: str, word2: str) -> int:\n        m, n = len(word1), len(word2)\n        \n        # Initialize a dp array with size (m+1) x (n+1)\n        dp = [[0] * (n+1) for _ in range(m+1)]\n        \n        # Fill in the first row and first column of the dp array\n        for i in range(m+1):\n            dp[i][0] = i\n        for j in range(n+1):\n            dp[0][j] = j\n        \n        # Fill in the rest of the dp array based on the characters of word1 and word2\n        for i in range(1, m+1):\n            for j in range(1, n+1):\n                # If the characters are the same, no operation is needed\n                if word1[i-1] == word2[j-1]:\n                    dp[i][j] = dp[i-1][j-1]\n                else:\n                    # Find the minimum number of operations among insert, delete, and replace\n                    dp[i][j] = min(dp[i-1][j] + 1, dp[i][j-1] + 1, dp[i-1][j-1] + 1)\n        \n        # Return the result, which is the value at the bottom right corner of the dp array\n        return dp[m][n]\n```\n\nThe above code generates a dp array to store the minimum number of operations required to convert word1 to word2. It initializes the dp array with size (m+1) x (n+1), where m is the length of word1 and n is the length of word2. Each entry dp[i][j] represents the minimum number of operations required to convert the first i characters of word1 to the first j characters of word2.\n\nWe fill in the first row and first column of the dp array with 0 to represent the minimum number of operations required to convert an empty string to a string of length i or j. Then, we fill in the rest of the dp array by comparing the characters of word1 and word2.\n\nIf the characters at word1[i-1] and word2[j-1] are the same, no operation is needed. In this case, the value at dp[i][j] is the same as the value at dp[i-1][j-1]. Otherwise, we need to perform one of three operations (insert, delete, or replace) to make the characters match. We can take the minimum number of operations among these three options, and add 1 to it. This is represented by the equation dp[i][j] = min(dp[i-1][j] + 1, dp[i][j-1] + 1, dp[i-1][j-1] + 1).\n\nFinally, the result is the value at the bottom right corner of the dp array, which represents the minimum number of operations required to convert word1 to word2.", "cleaned_response": "\nclass Solution:\n    def minDistance(self, word1: str, word2: str) -> int:\n        m, n = len(word1), len(word2)\n        \n        # Initialize a dp array with size (m+1) x (n+1)\n        dp = [[0] * (n+1) for _ in range(m+1)]\n        \n        # Fill in the first row and first column of the dp array\n        for i in range(m+1):\n            dp[i][0] = i\n        for j in range(n+1):\n            dp[0][j] = j\n        \n        # Fill in the rest of the dp array based on the characters of word1 and word2\n        for i in range(1, m+1):\n            for j in range(1, n+1):\n                # If the characters are the same, no operation is needed\n                if word1[i-1] == word2[j-1]:\n                    dp[i][j] = dp[i-1][j-1]\n                else:\n                    # Find the minimum number of operations among insert, delete, and replace\n                    dp[i][j] = min(dp[i-1][j] + 1, dp[i][j-1] + 1, dp[i-1][j-1] + 1)\n        \n        # Return the result, which is the value at the bottom right corner of the dp array\n        return dp[m][n]\n", "n_pass": 1, "difficulty": 2.0, "frontend_question_id": 72.0, "loc": 71}
{"task_input": "\nLeetCode Problem #75\nTitle: Sort Colors\nDescription:\nGiven an array nums with n objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white, and blue. We will use the integers 0, 1, and 2 to represent the color red, white, and blue, respectively. You must solve this problem without using the library's sort function. Example 1: Input: nums = [2, 0, 2, 1, 1, 0] Output: [0, 0, 1, 1, 2, 2] Example 2: Input: nums = [2, 0, 1] Output: [0, 1, 2] Constraints: n == nums.length 1 <= n <= 300 nums[i] is either 0, 1, or 2. Follow up: Could you come up with a one-pass algorithm using only constant extra space?\n", "code_prompt": "class Solution:\n    def sortColors(self, nums: List[int]) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        ", "raw_response": "```python\nfrom typing import List\n\nclass Solution:\n    def sortColors(self, nums: List[int]) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        count = [0, 0, 0]  # counts the occurrences of each color\n        \n        # Count the occurrences of each color\n        for num in nums:\n            count[num] += 1\n            \n        # Update the nums list with sorted colors\n        index = 0\n        for i in range(3):\n            for j in range(count[i]):\n                nums[index] = i\n                index += 1\n```\n", "cleaned_response": "\nfrom typing import List\n\nclass Solution:\n    def sortColors(self, nums: List[int]) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        count = [0, 0, 0]  # counts the occurrences of each color\n        \n        # Count the occurrences of each color\n        for num in nums:\n            count[num] += 1\n            \n        # Update the nums list with sorted colors\n        index = 0\n        for i in range(3):\n            for j in range(count[i]):\n                nums[index] = i\n                index += 1\n", "n_pass": 1, "difficulty": 2.0, "frontend_question_id": 75.0, "loc": 74}
{"task_input": "\nLeetCode Problem #76\nTitle: Minimum Window Substring\nDescription:\nGiven two strings s and t of lengths m and n respectively, return the minimum window substring of s such that every character in t ( including duplicates ) is included in the window. If there is no such substring, return the empty string \"\". The testcases will be generated such that the answer is unique. Example 1: Input: s = \"ADOBECODEBANC\", t = \"ABC\" Output: \"BANC\" Explanation: The minimum window substring \"BANC\" includes 'A', 'B', and 'C' from string t. Example 2: Input: s = \"a\", t = \"a\" Output: \"a\" Explanation: The entire string s is the minimum window. Example 3: Input: s = \"a\", t = \"aa\" Output: \"\" Explanation: Both 'a's from t must be included in the window. Since the largest window of s only has one 'a', return empty string. Constraints: m == s.length n == t.length 1 <= m, n <= 10e5 s and t consist of uppercase and lowercase English letters. Follow up: Could you find an algorithm that runs in O(m + n) time?\n", "code_prompt": "class Solution:\n    def minWindow(self, s: str, t: str) -> str:\n        ", "raw_response": "```python\nclass Solution:\n    def minWindow(self, s: str, t: str) -> str:\n        # Step 1: Create a dictionary to store the frequency of characters in t\n        t_freq = {}\n        for char in t:\n            t_freq[char] = t_freq.get(char, 0) + 1\n        \n        # Step 2: Initialize variables\n        left = 0\n        min_length = float('inf')  # Set initial min length to infinity\n        count = 0  # Count of characters in t found in the window\n        min_window = \"\"  # Resultant minimum window substring\n        \n        # Step 3: Slide the window\n        for right in range(len(s)):\n            # Decrement the frequency of the character in t\n            if s[right] in t_freq:\n                t_freq[s[right]] -= 1\n                # If the frequency becomes 0, it means we have found all occurrences of the character in t\n                if t_freq[s[right]] >= 0:\n                    count += 1\n            \n            # Step 4: Update the window\n            while count == len(t):\n                # Update the minimum window substring if a smaller length is found\n                if right - left + 1 < min_length:\n                    min_length = right - left + 1\n                    min_window = s[left:right+1]\n                \n                # Increment the frequency of the character at the left pointer\n                if s[left] in t_freq:\n                    t_freq[s[left]] += 1\n                    # If the frequency becomes > 0, it means the character is no longer fully covered in the window\n                    if t_freq[s[left]] > 0:\n                        count -= 1\n                \n                # Move the left pointer\n                left += 1\n        \n        # Step 5: Return the minimum window substring\n        return min_window\n```\n\n### Algorithm Explanation:\n\nThis problem can be solved using the sliding window technique. The main idea is to maintain a window that contains all the characters of string t. Initially, the window is empty. We expand the window by moving the right pointer to the right until we find all the characters of t in the window. Then, we try to minimize the window length by moving the left pointer to the right and updating the window.\n\n1. Create a dictionary `t_freq` to store the frequency of characters in t.\n2. Initialize variables: \n   - `left` and `right` pointers to represent the window boundaries.\n   - `min_length` to store the minimum window length found so far (initialized to infinity).\n   - `count` to keep track of the number of characters in t found in the window.\n   - `min_window` to store the resultant minimum window substring.\n3. Slide the window by moving the right pointer to the right:\n   - Decrement the frequency of the character at the right pointer in `t_freq`.\n   - If the frequency becomes 0 or greater, increment `count` by 1.\n4. Update the window:\n   - If `count` is equal to the length of t, it means we have found all the characters of t in the window.\n   - Update the `min_length` and `min_window` if the current window length is smaller.\n   - Move the left pointer to the right and update the window:\n     - Increment the frequency of the character at the left pointer in `t_freq`.\n     - If the frequency becomes greater than 0, decrement `count` by 1.\n5. Return the `min_window`.\n\nThe time complexity of this algorithm is O(m + n), where m is the length of string s and n is the length of string t. This is because we traverse both strings once (using the left and right pointers). The space complexity is O(n) since we use a dictionary to store the frequency of characters in t.", "cleaned_response": "\nclass Solution:\n    def minWindow(self, s: str, t: str) -> str:\n        # Step 1: Create a dictionary to store the frequency of characters in t\n        t_freq = {}\n        for char in t:\n            t_freq[char] = t_freq.get(char, 0) + 1\n        \n        # Step 2: Initialize variables\n        left = 0\n        min_length = float('inf')  # Set initial min length to infinity\n        count = 0  # Count of characters in t found in the window\n        min_window = \"\"  # Resultant minimum window substring\n        \n        # Step 3: Slide the window\n        for right in range(len(s)):\n            # Decrement the frequency of the character in t\n            if s[right] in t_freq:\n                t_freq[s[right]] -= 1\n                # If the frequency becomes 0, it means we have found all occurrences of the character in t\n                if t_freq[s[right]] >= 0:\n                    count += 1\n            \n            # Step 4: Update the window\n            while count == len(t):\n                # Update the minimum window substring if a smaller length is found\n                if right - left + 1 < min_length:\n                    min_length = right - left + 1\n                    min_window = s[left:right+1]\n                \n                # Increment the frequency of the character at the left pointer\n                if s[left] in t_freq:\n                    t_freq[s[left]] += 1\n                    # If the frequency becomes > 0, it means the character is no longer fully covered in the window\n                    if t_freq[s[left]] > 0:\n                        count -= 1\n                \n                # Move the left pointer\n                left += 1\n        \n        # Step 5: Return the minimum window substring\n        return min_window\n", "n_pass": 1, "difficulty": 3.0, "frontend_question_id": 76.0, "loc": 75}
{"task_input": "\nLeetCode Problem #84\nTitle: Largest Rectangle in Histogram\nDescription:\nGiven an array of integers heights representing the histogram's bar height where the width of each bar is 1, return the area of the largest rectangle in the histogram. Example 1: Input: heights = [2, 1, 5, 6, 2, 3] Output: 10 Explanation: The above is a histogram where width of each bar is 1. The largest rectangle is shown in the red area, which has an area = 10 units. Example 2: Input: heights = [2, 4] Output: 4 Constraints: 1 <= heights.length <= 10e5 0 <= heights[i] <= 10e4\n", "code_prompt": "class Solution:\n    def largestRectangleArea(self, heights: List[int]) -> int:\n        ", "raw_response": "```python\nfrom typing import List\n\nclass Solution:\n    def largestRectangleArea(self, heights: List[int]) -> int:\n        # Initialize variables\n        stack = []\n        max_area = 0\n        n = len(heights)\n        i = 0\n        \n        while i < n:\n            # If the stack is empty or the current bar is higher than the bar at the top of the stack, \n            # push the current index onto the stack\n            if not stack or heights[i] >= heights[stack[-1]]:\n                stack.append(i)\n                i += 1\n            else:\n                # If the current bar is lower than the bar at the top of the stack, calculate the area of the rectangle\n                # that can be formed with the bar at the top of the stack as the minimum height\n                # The width of the rectangle is the difference between the current index and the index at the top of the stack \n                # The height of the rectangle is the height of the bar at the top of the stack\n                top = stack.pop()\n                width = i if not stack else i - stack[-1] - 1\n                area = heights[top] * width\n                max_area = max(max_area, area)\n        \n        # After going through all the bars, there might be some bars left in the stack\n        # Calculate the area for each remaining bar in the stack\n        while stack:\n            top = stack.pop()\n            width = i if not stack else n - stack[-1] - 1\n            area = heights[top] * width\n            max_area = max(max_area, area)\n        \n        return max_area\n```\nThe time complexity of this solution is O(n), where n is the length of the heights list.", "cleaned_response": "\nfrom typing import List\n\nclass Solution:\n    def largestRectangleArea(self, heights: List[int]) -> int:\n        # Initialize variables\n        stack = []\n        max_area = 0\n        n = len(heights)\n        i = 0\n        \n        while i < n:\n            # If the stack is empty or the current bar is higher than the bar at the top of the stack, \n            # push the current index onto the stack\n            if not stack or heights[i] >= heights[stack[-1]]:\n                stack.append(i)\n                i += 1\n            else:\n                # If the current bar is lower than the bar at the top of the stack, calculate the area of the rectangle\n                # that can be formed with the bar at the top of the stack as the minimum height\n                # The width of the rectangle is the difference between the current index and the index at the top of the stack \n                # The height of the rectangle is the height of the bar at the top of the stack\n                top = stack.pop()\n                width = i if not stack else i - stack[-1] - 1\n                area = heights[top] * width\n                max_area = max(max_area, area)\n        \n        # After going through all the bars, there might be some bars left in the stack\n        # Calculate the area for each remaining bar in the stack\n        while stack:\n            top = stack.pop()\n            width = i if not stack else n - stack[-1] - 1\n            area = heights[top] * width\n            max_area = max(max_area, area)\n        \n        return max_area\n", "n_pass": 1, "difficulty": 3.0, "frontend_question_id": 84.0, "loc": 83}
{"task_input": "\nLeetCode Problem #85\nTitle: Maximal Rectangle\nDescription:\nGiven a rows x cols binary matrix filled with 0 's and 1 's, find the largest rectangle containing only 1 's and return its area. Example 1: Input: matrix = [[\"1\", \"0\", \"1\", \"0\", \"0\"], [\"1\", \"0\", \"1\", \"1\", \"1\"], [\"1\", \"1\", \"1\", \"1\", \"1\"], [\"1\", \"0\", \"0\", \"1\", \"0\"]] Output: 6 Explanation: The maximal rectangle is shown in the above picture. Example 2: Input: matrix = [[\"0\"]] Output: 0 Example 3: Input: matrix = [[\"1\"]] Output: 1 Constraints: rows == matrix.length cols == matrix[i].length 1 <= row, cols <= 200 matrix[i][j] is '0' or '1'.\n", "code_prompt": "class Solution:\n    def maximalRectangle(self, matrix: List[List[str]]) -> int:\n        ", "raw_response": "```python\nclass Solution:\n    def maximalRectangle(self, matrix: List[List[str]]) -> int:\n        if not matrix:\n            return 0\n        \n        rows = len(matrix)\n        cols = len(matrix[0])\n        \n        # Precompute the heights of each row\n        heights = [0] * cols\n        \n        max_area = 0\n        \n        for i in range(rows):\n            for j in range(cols):\n                if matrix[i][j] == \"1\":\n                    heights[j] += 1\n                else:\n                    heights[j] = 0\n            \n            area = self.largestRectangleArea(heights)\n            max_area = max(max_area, area)\n        \n        return max_area\n    \n    def largestRectangleArea(self, heights: List[int]) -> int:\n        stack = []\n        max_area = 0\n        i = 0\n        \n        # Append 0 to the end of the heights array to handle the remaining elements in the stack\n        heights.append(0)\n        \n        while i < len(heights):\n            if not stack or heights[i] >= heights[stack[-1]]:\n                stack.append(i)\n                i += 1\n            else:\n                top = stack.pop()\n                area = heights[top] * (i - stack[-1] - 1) if stack else heights[top] * i\n                max_area = max(max_area, area)\n        \n        return max_area\n```", "cleaned_response": "\nclass Solution:\n    def maximalRectangle(self, matrix: List[List[str]]) -> int:\n        if not matrix:\n            return 0\n        \n        rows = len(matrix)\n        cols = len(matrix[0])\n        \n        # Precompute the heights of each row\n        heights = [0] * cols\n        \n        max_area = 0\n        \n        for i in range(rows):\n            for j in range(cols):\n                if matrix[i][j] == \"1\":\n                    heights[j] += 1\n                else:\n                    heights[j] = 0\n            \n            area = self.largestRectangleArea(heights)\n            max_area = max(max_area, area)\n        \n        return max_area\n    \n    def largestRectangleArea(self, heights: List[int]) -> int:\n        stack = []\n        max_area = 0\n        i = 0\n        \n        # Append 0 to the end of the heights array to handle the remaining elements in the stack\n        heights.append(0)\n        \n        while i < len(heights):\n            if not stack or heights[i] >= heights[stack[-1]]:\n                stack.append(i)\n                i += 1\n            else:\n                top = stack.pop()\n                area = heights[top] * (i - stack[-1] - 1) if stack else heights[top] * i\n                max_area = max(max_area, area)\n        \n        return max_area\n", "n_pass": 1, "difficulty": 3.0, "frontend_question_id": 85.0, "loc": 84}
{"task_input": "\nLeetCode Problem #86\nTitle: Partition List\nDescription:\nGiven the head of a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x. You should preserve the original relative order of the nodes in each of the two partitions. Example 1: Input: head = [1, 4, 3, 2, 5, 2], x = 3 Output: [1, 2, 2, 4, 3, 5] Example 2: Input: head = [2, 1], x = 2 Output: [1, 2] Constraints: The number of nodes in the list is in the range [0, 200]. -100 <= Node. val <= 100 -200 <= x <= 200\n", "code_prompt": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def partition(self, head: Optional[ListNode], x: int) -> Optional[ListNode]:\n        ", "raw_response": "```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def partition(self, head: Optional[ListNode], x: int) -> Optional[ListNode]:\n        # create two dummy nodes for two partitions\n        dummy1 = ListNode(0)\n        dummy2 = ListNode(0)\n        \n        # create two pointers for two partitions\n        curr1 = dummy1\n        curr2 = dummy2\n        \n        # iterate through the linked list\n        while head:\n            if head.val < x:\n                # add the node to the first partition\n                curr1.next = head\n                curr1 = curr1.next\n            else:\n                # add the node to the second partition\n                curr2.next = head\n                curr2 = curr2.next\n            head = head.next\n        \n        # connect the two partitions\n        curr1.next = dummy2.next\n        curr2.next = None\n        \n        return dummy1.next\n```", "cleaned_response": "\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def partition(self, head: Optional[ListNode], x: int) -> Optional[ListNode]:\n        # create two dummy nodes for two partitions\n        dummy1 = ListNode(0)\n        dummy2 = ListNode(0)\n        \n        # create two pointers for two partitions\n        curr1 = dummy1\n        curr2 = dummy2\n        \n        # iterate through the linked list\n        while head:\n            if head.val < x:\n                # add the node to the first partition\n                curr1.next = head\n                curr1 = curr1.next\n            else:\n                # add the node to the second partition\n                curr2.next = head\n                curr2 = curr2.next\n            head = head.next\n        \n        # connect the two partitions\n        curr1.next = dummy2.next\n        curr2.next = None\n        \n        return dummy1.next\n", "n_pass": 1, "difficulty": 2.0, "frontend_question_id": 86.0, "loc": 85}
{"task_input": "\nLeetCode Problem #87\nTitle: Scramble String\nDescription:\nWe can scramble a string s to get a string t using the following algorithm:...\n If the length of the string is 1, stop. If the length of the string is > 1, do the following: Split the string into two non-empty substrings at a random index, i. e. , if the string is s, divide it to x and y where s = x + y. Randomly decide to swap the two substrings or to keep them in the same order. i. e. , after this step, s may become s = x + y or s = y + x. Apply step 1 recursively on each of the two substrings x and y. Given two strings s1 and s2 of the same length, return true if s2 is a scrambled string of s1, otherwise, return false. Example 1: Input: s1 = \"great\", s2 = \"rgeat\" Output: true Explanation: One possible scenario applied on s1 is: \"great\" --> \"gr/eat\" // divide at random index. \"gr/eat\" --> \"gr/eat\" // random decision is not to swap the two substrings and keep them in order. \"gr/eat\" --> \"g/r / e/at\" // apply the same algorithm recursively on both substrings. divide at random index each of them. \"g/r / e/at\" --> \"r/g / e/at\" // random decision was to swap the first substring and to keep the second substring in the same order. \"r/g / e/at\" --> \"r/g / e/ a/t\" // again apply the algorithm recursively, divide \"at\" to \"a/t\". \"r/g / e/ a/t\" --> \"r/g / e/ a/t\" // random decision is to keep both substrings in the same order. The algorithm stops now, and the result string is \"rgeat\" which is s2. As one possible scenario led s1 to be scrambled to s2, we return true. Example 2: Input: s1 = \"abcde\", s2 = \"caebd\" Output: false Example 3: Input: s1 = \"a\", s2 = \"a\" Output: true Constraints: s1.length == s2.length 1 <= s1.length <= 30 s1 and s2 consist of lowercase English letters.\n", "code_prompt": "class Solution:\n    def isScramble(self, s1: str, s2: str) -> bool:\n        ", "raw_response": "To solve this problem, we can use dynamic programming and recursion to build a memoization table to store the results of subproblems. \n\nThe idea is to check if s1 and s2 are scrambled strings by recursively checking all possible splits and combinations of substrings. \n\nHere is the complete function definition:\n\n```python\nclass Solution:\n    def isScramble(self, s1: str, s2: str) -> bool:\n        # Check if strings are equal\n        if s1 == s2:\n            return True\n        \n        # Check if the characters in the two strings have the same frequency\n        if sorted(s1) != sorted(s2):\n            return False\n        \n        n = len(s1)\n        \n        # Create a 3D array to store the results of subproblems\n        dp = [[[False] * (n + 1) for _ in range(n)] for _ in range(n)]\n        \n        # Iterate through the lengths of substrings\n        for length in range(1, n + 1):\n            # Iterate through the starting indices of substrings in s1 and s2\n            for i in range(n - length + 1):\n                for j in range(n - length + 1):\n                    # If the substrings are the same, set dp[length][i][j] to True\n                    if s1[i:i+length] == s2[j:j+length]:\n                        dp[length][i][j] = True\n                    else:\n                        # Iterate through possible split points of the substrings\n                        for k in range(1, length):\n                            # Check if the substrings are scramble strings\n                            if (dp[k][i][j] and dp[length-k][i+k][j+k]) or (dp[k][i][j+length-k] and dp[length-k][i+k][j]):\n                                dp[length][i][j] = True\n                                break\n        \n        # Return the result of the entire problem\n        return dp[n][0][0]\n```\n\nThis solution has a time complexity of O(n^4) and a space complexity of O(n^3), where n is the length of the strings. The dynamic programming approach reduces redundancy in the recursive calls and improves efficiency.", "cleaned_response": "\nclass Solution:\n    def isScramble(self, s1: str, s2: str) -> bool:\n        # Check if strings are equal\n        if s1 == s2:\n            return True\n        \n        # Check if the characters in the two strings have the same frequency\n        if sorted(s1) != sorted(s2):\n            return False\n        \n        n = len(s1)\n        \n        # Create a 3D array to store the results of subproblems\n        dp = [[[False] * (n + 1) for _ in range(n)] for _ in range(n)]\n        \n        # Iterate through the lengths of substrings\n        for length in range(1, n + 1):\n            # Iterate through the starting indices of substrings in s1 and s2\n            for i in range(n - length + 1):\n                for j in range(n - length + 1):\n                    # If the substrings are the same, set dp[length][i][j] to True\n                    if s1[i:i+length] == s2[j:j+length]:\n                        dp[length][i][j] = True\n                    else:\n                        # Iterate through possible split points of the substrings\n                        for k in range(1, length):\n                            # Check if the substrings are scramble strings\n                            if (dp[k][i][j] and dp[length-k][i+k][j+k]) or (dp[k][i][j+length-k] and dp[length-k][i+k][j]):\n                                dp[length][i][j] = True\n                                break\n        \n        # Return the result of the entire problem\n        return dp[n][0][0]\n", "n_pass": 1, "difficulty": 3.0, "frontend_question_id": 87.0, "loc": 86}
{"task_input": "\nLeetCode Problem #93\nTitle: Restore IP Addresses\nDescription:\nA valid IP address consists of exactly four integers separated by single dots. Each integer is between 0 and 255 ( inclusive ) and cannot have leading zeros. For example, \"0. 1. 2. 201\" and \"192. 168. 1. 1\" are valid IP addresses, but \"0. 011. 255. 245\", \"192. 168. 1. 312\" and \"192. 168@1. 1\" are invalid IP addresses. Given a string s containing only digits, return all possible valid IP addresses that can be formed by inserting dots into s. You are not allowed to reorder or remove any digits in s. You may return the valid IP addresses in any order. Example 1: Input: s = \"25525511135\" Output: [\"255. 255. 11. 135\", \"255. 255. 111. 35\"] Example 2: Input: s = \"0000\" Output: [\"0. 0. 0. 0\"] Example 3: Input: s = \"101023\" Output: [\"1. 0. 10. 23\", \"1. 0. 102. 3\", \"10. 1. 0. 23\", \"10. 10. 2. 3\", \"101. 0. 2. 3\"] Constraints: 1 <= s.length <= 20 s consists of digits only.\n", "code_prompt": "class Solution:\n    def restoreIpAddresses(self, s: str) -> List[str]:\n        ", "raw_response": "```python\nfrom typing import List\n\nclass Solution:\n    def restoreIpAddresses(self, s: str) -> List[str]:\n        def backtrack(index, path, s):\n            # If we have found a valid IP address and used up all digits in s\n            if len(path) == 4 and index == len(s):\n                valid_ips.append('.'.join(path))\n                return\n            \n            # If we have found a valid IP address but there are still unused digits in s\n            if len(path) == 4 or index == len(s):\n                return\n            \n            # Try all possible combinations of digits\n            for i in range(1, 4):\n                # Skip if the current substring is out of range or has a leading zero\n                if index + i > len(s) or (s[index] == '0' and i > 1):\n                    continue\n                \n                # Get the current segment\n                segment = int(s[index:index+i])\n                \n                # Skip if the current segment is out of range\n                if segment > 255:\n                    continue\n                \n                # Append the segment to the path and recursively backtrack\n                path.append(str(segment))\n                backtrack(index+i, path, s)\n                path.pop()\n        \n        valid_ips = []\n        backtrack(0, [], s)\n        return valid_ips\n```", "cleaned_response": "\nfrom typing import List\n\nclass Solution:\n    def restoreIpAddresses(self, s: str) -> List[str]:\n        def backtrack(index, path, s):\n            # If we have found a valid IP address and used up all digits in s\n            if len(path) == 4 and index == len(s):\n                valid_ips.append('.'.join(path))\n                return\n            \n            # If we have found a valid IP address but there are still unused digits in s\n            if len(path) == 4 or index == len(s):\n                return\n            \n            # Try all possible combinations of digits\n            for i in range(1, 4):\n                # Skip if the current substring is out of range or has a leading zero\n                if index + i > len(s) or (s[index] == '0' and i > 1):\n                    continue\n                \n                # Get the current segment\n                segment = int(s[index:index+i])\n                \n                # Skip if the current segment is out of range\n                if segment > 255:\n                    continue\n                \n                # Append the segment to the path and recursively backtrack\n                path.append(str(segment))\n                backtrack(index+i, path, s)\n                path.pop()\n        \n        valid_ips = []\n        backtrack(0, [], s)\n        return valid_ips\n", "n_pass": 1, "difficulty": 2.0, "frontend_question_id": 93.0, "loc": 92}
{"task_input": "\nLeetCode Problem #98\nTitle: Validate Binary Search Tree\nDescription:\nGiven the root of a binary tree, determine if it is a valid binary search tree (BST). A valid BST is defined as follows: The left subtree of a node contains only nodes with keys less than the node's key. The right subtree of a node contains only nodes with keys greater than the node's key. Both the left and right subtrees must also be binary search trees. Example 1: Input: root = [2, 1, 3] Output: true Example 2: Input: root = [5, 1, 4, null, null, 3, 6] Output: false Explanation: The root node's value is 5 but its right child's value is 4. Constraints: The number of nodes in the tree is in the range [1, 10e4 ]. -2^31 <= Node. val <= 2^31 - 1\n", "code_prompt": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def isValidBST(self, root: Optional[TreeNode]) -> bool:\n        ", "raw_response": "```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    def isValidBST(self, root: Optional[TreeNode]) -> bool:\n        def helper(node, lower=float('-inf'), upper=float('inf')):\n            if not node:\n                return True\n            \n            val = node.val\n            if val <= lower or val >= upper:\n                return False\n            \n            if not helper(node.right, val, upper):\n                return False\n            if not helper(node.left, lower, val):\n                return False\n            \n            return True\n        \n        return helper(root)\n```\nExplanation:\n- We define a helper function called `helper` that takes a node, a lower bound, and an upper bound as parameters.\n- The `lower` and `upper` arguments are used to keep track of the valid range for the nodes in the subtree.\n- Inside the `helper` function, we first check if the node is empty. If it is, we return True, as an empty tree is considered a valid BST.\n- Next, we store the value of the current node in the `val` variable.\n- We then check if the value of the current node is not within the valid range defined by the `lower` and `upper` bounds. If it is not, we return False, as the tree is not a valid BST.\n- If the current node passes the above checks, we recursively call the `helper` function on the right subtree with the updated `lower` bound as the value of the current node and the same `upper` bound.\n- Similarly, we recursively call the `helper` function on the left subtree with the same `lower` bound and the value of the current node as the `upper` bound.\n- If either of these recursive calls returns False, we return False.\n- If all the above checks pass, we return True, indicating that the tree is a valid BST.\n- Finally, we call the `helper` function with the root of the tree as the initial node and return its result.", "cleaned_response": "\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    def isValidBST(self, root: Optional[TreeNode]) -> bool:\n        def helper(node, lower=float('-inf'), upper=float('inf')):\n            if not node:\n                return True\n            \n            val = node.val\n            if val <= lower or val >= upper:\n                return False\n            \n            if not helper(node.right, val, upper):\n                return False\n            if not helper(node.left, lower, val):\n                return False\n            \n            return True\n        \n        return helper(root)\n", "n_pass": 1, "difficulty": 2.0, "frontend_question_id": 98.0, "loc": 97}
{"task_input": "\nLeetCode Problem #103\nTitle: Binary Tree Zigzag Level Order Traversal\nDescription:\nGiven the root of a binary tree, return the zigzag level order traversal of its nodes' values. (i. e. , from left to right, then right to left for the next level and alternate between). Example 1: Input: root = [3, 9, 20, null, null, 15, 7] Output: [[3], [20, 9], [15, 7]] Example 2: Input: root = [1] Output: [[1]] Example 3: Input: root = [] Output: [] Constraints: The number of nodes in the tree is in the range [0, 2000]. -100 <= Node. val <= 100\n", "code_prompt": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def zigzagLevelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:\n        ", "raw_response": "```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    def zigzagLevelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:\n        \n        # Initialize an empty result list\n        result = []\n        \n        # Check if the root is None\n        if root is None:\n            return result\n        \n        # Initialize a queue to perform a level order traversal\n        queue = deque([root])\n        \n        # Initialize a variable to keep track of the level\n        level = 0\n        \n        # Perform a level order traversal\n        while queue:\n            \n            # Determine the number of nodes at the current level\n            level_size = len(queue)\n            \n            # Initialize a list to store the nodes at the current level\n            level_nodes = []\n            \n            # Traverse all nodes at the current level\n            for _ in range(level_size):\n                \n                # Pop the node from the queue\n                node = queue.popleft()\n                \n                # Append the node value to the level_nodes list\n                level_nodes.append(node.val)\n                \n                # Append the left child to the queue if it exists\n                if node.left:\n                    queue.append(node.left)\n                \n                # Append the right child to the queue if it exists\n                if node.right:\n                    queue.append(node.right)\n            \n            # Reverse the level_nodes list for odd levels (zigzag order)\n            if level % 2 != 0:\n                level_nodes.reverse()\n            \n            # Append the level_nodes list to the result list\n            result.append(level_nodes)\n            \n            # Increment the level counter\n            level += 1\n        \n        return result\n```", "cleaned_response": "\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    def zigzagLevelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:\n        \n        # Initialize an empty result list\n        result = []\n        \n        # Check if the root is None\n        if root is None:\n            return result\n        \n        # Initialize a queue to perform a level order traversal\n        queue = deque([root])\n        \n        # Initialize a variable to keep track of the level\n        level = 0\n        \n        # Perform a level order traversal\n        while queue:\n            \n            # Determine the number of nodes at the current level\n            level_size = len(queue)\n            \n            # Initialize a list to store the nodes at the current level\n            level_nodes = []\n            \n            # Traverse all nodes at the current level\n            for _ in range(level_size):\n                \n                # Pop the node from the queue\n                node = queue.popleft()\n                \n                # Append the node value to the level_nodes list\n                level_nodes.append(node.val)\n                \n                # Append the left child to the queue if it exists\n                if node.left:\n                    queue.append(node.left)\n                \n                # Append the right child to the queue if it exists\n                if node.right:\n                    queue.append(node.right)\n            \n            # Reverse the level_nodes list for odd levels (zigzag order)\n            if level % 2 != 0:\n                level_nodes.reverse()\n            \n            # Append the level_nodes list to the result list\n            result.append(level_nodes)\n            \n            # Increment the level counter\n            level += 1\n        \n        return result\n", "n_pass": 1, "difficulty": 2.0, "frontend_question_id": 103.0, "loc": 102}
{"task_input": "\nLeetCode Problem #105\nTitle: Construct Binary Tree from Preorder and Inorder Traversal\nDescription:\nGiven two integer arrays preorder and inorder where preorder is the preorder traversal of a binary tree and inorder is the inorder traversal of the same tree, construct and return the binary tree. Example 1: Input: preorder = [3, 9, 20, 15, 7], inorder = [9, 3, 15, 20, 7] Output: [3, 9, 20, null, null, 15, 7] Example 2: Input: preorder = [-1], inorder = [-1] Output: [-1] Constraints: 1 <= preorder.length <= 3000 inorder.length == preorder.length -3000 <= preorder[i], inorder[i] <= 3000 preorder and inorder consist of unique values. Each value of inorder also appears in preorder. preorder is guaranteed to be the preorder traversal of the tree. inorder is guaranteed to be the inorder traversal of the tree.\n", "code_prompt": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:\n        ", "raw_response": "```python\n# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n        \nclass Solution:\n    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:\n        if not preorder or not inorder:\n            return None\n        \n        # Create a dictionary to store the index of each value in the inorder list\n        index_map = {}\n        for i in range(len(inorder)):\n            index_map[inorder[i]] = i\n        \n        def helper(preorder_start, preorder_end, inorder_start, inorder_end):\n            # Base case: if the starting and ending indices are the same, return a new node with that value\n            if preorder_start == preorder_end:\n                return TreeNode(preorder[preorder_start])\n            \n            # Get the root value from the preorder list\n            root_val = preorder[preorder_start]\n            root = TreeNode(root_val)\n            \n            # Get the index of the root value in the inorder list\n            root_index = index_map[root_val]\n            \n            # Get the number of nodes on the left and right subtrees\n            left_subtree_size = root_index - inorder_start\n            right_subtree_size = inorder_end - root_index\n            \n            # Recursively build the left and right subtrees\n            if left_subtree_size > 0:\n                root.left = helper(preorder_start + 1, preorder_start + left_subtree_size,\n                                   inorder_start, root_index - 1)\n            if right_subtree_size > 0:\n                root.right = helper(preorder_start + left_subtree_size + 1, preorder_end,\n                                    root_index + 1, inorder_end)\n            \n            return root\n        \n        # Call the helper function with the initial indices\n        return helper(0, len(preorder) - 1, 0, len(inorder) - 1)\n```", "cleaned_response": "\n# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n        \nclass Solution:\n    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:\n        if not preorder or not inorder:\n            return None\n        \n        # Create a dictionary to store the index of each value in the inorder list\n        index_map = {}\n        for i in range(len(inorder)):\n            index_map[inorder[i]] = i\n        \n        def helper(preorder_start, preorder_end, inorder_start, inorder_end):\n            # Base case: if the starting and ending indices are the same, return a new node with that value\n            if preorder_start == preorder_end:\n                return TreeNode(preorder[preorder_start])\n            \n            # Get the root value from the preorder list\n            root_val = preorder[preorder_start]\n            root = TreeNode(root_val)\n            \n            # Get the index of the root value in the inorder list\n            root_index = index_map[root_val]\n            \n            # Get the number of nodes on the left and right subtrees\n            left_subtree_size = root_index - inorder_start\n            right_subtree_size = inorder_end - root_index\n            \n            # Recursively build the left and right subtrees\n            if left_subtree_size > 0:\n                root.left = helper(preorder_start + 1, preorder_start + left_subtree_size,\n                                   inorder_start, root_index - 1)\n            if right_subtree_size > 0:\n                root.right = helper(preorder_start + left_subtree_size + 1, preorder_end,\n                                    root_index + 1, inorder_end)\n            \n            return root\n        \n        # Call the helper function with the initial indices\n        return helper(0, len(preorder) - 1, 0, len(inorder) - 1)\n", "n_pass": 1, "difficulty": 2.0, "frontend_question_id": 105.0, "loc": 104}
{"task_input": "\nLeetCode Problem #106\nTitle: Construct Binary Tree from Inorder and Postorder Traversal\nDescription:\nGiven two integer arrays inorder and postorder where inorder is the inorder traversal of a binary tree and postorder is the postorder traversal of the same tree, construct and return the binary tree. Example 1: Input: inorder = [9, 3, 15, 20, 7], postorder = [9, 15, 7, 20, 3] Output: [3, 9, 20, null, null, 15, 7] Example 2: Input: inorder = [-1], postorder = [-1] Output: [-1] Constraints: 1 <= inorder.length <= 3000 postorder.length == inorder.length -3000 <= inorder[i], postorder[i] <= 3000 inorder and postorder consist of unique values. Each value of postorder also appears in inorder. inorder is guaranteed to be the inorder traversal of the tree. postorder is guaranteed to be the postorder traversal of the tree.\n", "code_prompt": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def buildTree(self, inorder: List[int], postorder: List[int]) -> Optional[TreeNode]:\n        ", "raw_response": "```python\n# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def buildTree(self, inorder: List[int], postorder: List[int]) -> Optional[TreeNode]:\n        if not inorder or not postorder:\n            return None\n        \n        # get the root value from the last element in postorder\n        root_val = postorder[-1]\n        root = TreeNode(root_val)\n        \n        # find the index of the root value in inorder\n        root_index = inorder.index(root_val)\n        \n        # construct the left and right subtrees recursively\n        root.left = self.buildTree(inorder[:root_index], postorder[:root_index])\n        root.right = self.buildTree(inorder[root_index+1:], postorder[root_index:len(postorder) - 1])\n        \n        return root\n```\nThe algorithm uses a recursive approach to construct the binary tree from the given inorder and postorder traversals. It starts by creating the root node using the last element in the postorder traversal. It then finds the index of the root value in the inorder traversal, which divides the inorder traversal into left and right subtrees. The recursive function is called again with the corresponding sections of the inorder and postorder traversals to construct the left and right subtrees. Finally, it returns the root node of the constructed binary tree.", "cleaned_response": "\n# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def buildTree(self, inorder: List[int], postorder: List[int]) -> Optional[TreeNode]:\n        if not inorder or not postorder:\n            return None\n        \n        # get the root value from the last element in postorder\n        root_val = postorder[-1]\n        root = TreeNode(root_val)\n        \n        # find the index of the root value in inorder\n        root_index = inorder.index(root_val)\n        \n        # construct the left and right subtrees recursively\n        root.left = self.buildTree(inorder[:root_index], postorder[:root_index])\n        root.right = self.buildTree(inorder[root_index+1:], postorder[root_index:len(postorder) - 1])\n        \n        return root\n", "n_pass": 1, "difficulty": 2.0, "frontend_question_id": 106.0, "loc": 105}
{"task_input": "\nLeetCode Problem #110\nTitle: Balanced Binary Tree\nDescription:\nGiven a binary tree, determine if it is height-balanced. Example 1: Input: root = [3, 9, 20, null, null, 15, 7] Output: true Example 2: Input: root = [1, 2, 2, 3, 3, null, null, 4, 4] Output: false Example 3: Input: root = [] Output: true Constraints: The number of nodes in the tree is in the range [0, 5000]. -10e4 <= Node. val <= 10e4\n", "code_prompt": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def isBalanced(self, root: Optional[TreeNode]) -> bool:\n        ", "raw_response": "```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def isBalanced(self, root: Optional[TreeNode]) -> bool:\n        def get_height(node):\n            if not node:\n                return 0\n            left_height = get_height(node.left)\n            right_height = get_height(node.right)\n            return max(left_height, right_height) + 1\n        \n        def is_balanced_helper(node):\n            if not node:\n                return True\n            left_height = get_height(node.left)\n            right_height = get_height(node.right)\n            if abs(left_height - right_height) > 1:\n                return False\n            return is_balanced_helper(node.left) and is_balanced_helper(node.right)\n        \n        return is_balanced_helper(root)\n```\nThe above code defines a `Solution` class with a method `isBalanced` that takes a binary tree `root` as input and returns a boolean indicating whether the tree is height-balanced. The code uses two helper functions: `get_height` and `is_balanced_helper`.\n\nThe `get_height` function calculates the height of a node in the binary tree recursively. It returns the maximum height of its left and right subtrees plus 1.\n\nThe `is_balanced_helper` function recursively checks if a node and its left and right subtrees are height-balanced. It uses the `get_height` function to calculate the heights of the left and right subtrees and compares them. If the absolute difference is greater than 1, the tree is not balanced and `False` is returned. Otherwise, it recursively checks if the left and right subtrees are also height-balanced.\n\nThe `isBalanced` function initially calls the `is_balanced_helper` function with the `root` node and returns the result.", "cleaned_response": "\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def isBalanced(self, root: Optional[TreeNode]) -> bool:\n        def get_height(node):\n            if not node:\n                return 0\n            left_height = get_height(node.left)\n            right_height = get_height(node.right)\n            return max(left_height, right_height) + 1\n        \n        def is_balanced_helper(node):\n            if not node:\n                return True\n            left_height = get_height(node.left)\n            right_height = get_height(node.right)\n            if abs(left_height - right_height) > 1:\n                return False\n            return is_balanced_helper(node.left) and is_balanced_helper(node.right)\n        \n        return is_balanced_helper(root)\n", "n_pass": 1, "difficulty": 1.0, "frontend_question_id": 110.0, "loc": 109}
{"task_input": "\nLeetCode Problem #111\nTitle: Minimum Depth of Binary Tree\nDescription:\nGiven a binary tree, find its minimum depth. The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node. Note: A leaf is a node with no children. Example 1: Input: root = [3, 9, 20, null, null, 15, 7] Output: 2 Example 2: Input: root = [2, null, 3, null, 4, null, 5, null, 6] Output: 5 Constraints: The number of nodes in the tree is in the range [0, 10e5 ]. -1000 <= Node. val <= 1000\n", "code_prompt": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def minDepth(self, root: Optional[TreeNode]) -> int:\n        ", "raw_response": "```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def minDepth(self, root: Optional[TreeNode]) -> int:\n        # If the tree is empty, return 0\n        if not root:\n            return 0\n        \n        # If both the left and right child are None, we have reached a leaf node\n        if not root.left and not root.right:\n            return 1\n        \n        # If left child exists but right child does not exist, recursively find the minimum depth of the left subtree\n        if not root.right:\n            return self.minDepth(root.left) + 1\n        \n        # If right child exists but left child does not exist, recursively find the minimum depth of the right subtree\n        if not root.left:\n            return self.minDepth(root.right) + 1\n        \n        # If both left and right child exist, recursively find the minimum depth of both subtrees and return the minimum\n        return min(self.minDepth(root.left), self.minDepth(root.right)) + 1\n```\n\nThe code above defines a class `Solution` with a method `minDepth` that takes a root node of a binary tree and returns the minimum depth of the tree.\n\nThe function first checks if the tree is empty (i.e., `root` is `None`). If it is, it returns 0, indicating that the tree has no nodes.\n\nIf the tree is not empty, the function proceeds to check if the current node is a leaf node (i.e., both its left and right children are `None`). If it is, it returns 1, indicating that the current node is the nearest leaf node.\n\nIf the current node is not a leaf node, the function checks if the left child exists but the right child does not. In this case, it recursively finds the minimum depth of the left subtree by calling `self.minDepth(root.left)` and adds 1 to account for the current node.\n\nSimilarly, if the right child exists but the left child does not, the function recursively finds the minimum depth of the right subtree by calling `self.minDepth(root.right)` and adds 1 to account for the current node.\n\nFinally, if both the left and right children exist, the function recursively finds the minimum depth of both subtrees using `self.minDepth(root.left)` and `self.minDepth(root.right)`. It then returns the minimum of the two depths plus 1 to account for the current node.\n\nBy recursively applying these rules, the function determines the minimum depth of the binary tree.", "cleaned_response": "\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def minDepth(self, root: Optional[TreeNode]) -> int:\n        # If the tree is empty, return 0\n        if not root:\n            return 0\n        \n        # If both the left and right child are None, we have reached a leaf node\n        if not root.left and not root.right:\n            return 1\n        \n        # If left child exists but right child does not exist, recursively find the minimum depth of the left subtree\n        if not root.right:\n            return self.minDepth(root.left) + 1\n        \n        # If right child exists but left child does not exist, recursively find the minimum depth of the right subtree\n        if not root.left:\n            return self.minDepth(root.right) + 1\n        \n        # If both left and right child exist, recursively find the minimum depth of both subtrees and return the minimum\n        return min(self.minDepth(root.left), self.minDepth(root.right)) + 1\n", "n_pass": 1, "difficulty": 1.0, "frontend_question_id": 111.0, "loc": 110}
{"task_input": "\nLeetCode Problem #113\nTitle: Path Sum II\nDescription:\nGiven the root of a binary tree and an integer targetSum, return all root-to-leaf paths where the sum of the node values in the path equals targetSum. Each path should be returned as a list of the node values, not node references. A root-to-leaf path is a path starting from the root and ending at any leaf node. A leaf is a node with no children. Example 1: Input: root = [5, 4, 8, 11, null, 13, 4, 7, 2, null, null, 5, 1], targetSum = 22 Output: [[5, 4, 11, 2], [5, 8, 4, 5]] Explanation: There are two paths whose sum equals targetSum: 5 + 4 + 11 + 2 = 22^5 + 8 + 4 + 5 = 22 Example 2: Input: root = [1, 2, 3], targetSum = 5 Output: [] Example 3: Input: root = [1, 2], targetSum = 0 Output: [] Constraints: The number of nodes in the tree is in the range [0, 5000]. -1000 <= Node. val <= 1000 -1000 <= targetSum <= 1000\n", "code_prompt": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def pathSum(self, root: Optional[TreeNode], targetSum: int) -> List[List[int]]:\n        ", "raw_response": "```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def pathSum(self, root: Optional[TreeNode], targetSum: int) -> List[List[int]]:\n        # Initialize the result list\n        result = []\n        \n        # Recursive helper function to traverse the tree and find paths\n        def dfs(node, path, curr_sum):\n            # Base case: If node is None, return\n            if not node:\n                return\n            \n            # Update the current sum\n            curr_sum += node.val\n            \n            # Add current node to the path\n            path.append(node.val)\n            \n            # Check if current node is a leaf node and the sum is equal to targetSum\n            if not node.left and not node.right and curr_sum == targetSum:\n                result.append(list(path))  # Append a copy of the path to the result list\n            \n            # Recursively traverse the left and right subtrees\n            dfs(node.left, path, curr_sum)\n            dfs(node.right, path, curr_sum)\n            \n            # Remove the current node from the path\n            path.pop()\n        \n        # Start the DFS traversal from the root node with an empty path and sum 0\n        dfs(root, [], 0)\n        \n        return result\n```", "cleaned_response": "\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def pathSum(self, root: Optional[TreeNode], targetSum: int) -> List[List[int]]:\n        # Initialize the result list\n        result = []\n        \n        # Recursive helper function to traverse the tree and find paths\n        def dfs(node, path, curr_sum):\n            # Base case: If node is None, return\n            if not node:\n                return\n            \n            # Update the current sum\n            curr_sum += node.val\n            \n            # Add current node to the path\n            path.append(node.val)\n            \n            # Check if current node is a leaf node and the sum is equal to targetSum\n            if not node.left and not node.right and curr_sum == targetSum:\n                result.append(list(path))  # Append a copy of the path to the result list\n            \n            # Recursively traverse the left and right subtrees\n            dfs(node.left, path, curr_sum)\n            dfs(node.right, path, curr_sum)\n            \n            # Remove the current node from the path\n            path.pop()\n        \n        # Start the DFS traversal from the root node with an empty path and sum 0\n        dfs(root, [], 0)\n        \n        return result\n", "n_pass": 1, "difficulty": 2.0, "frontend_question_id": 113.0, "loc": 112}
{"task_input": "\nLeetCode Problem #115\nTitle: Distinct Subsequences\nDescription:\nGiven two strings s and t, return the number of distinct subsequences of s which equals t. The test cases are generated so that the answer fits on a 32-bit signed integer. Example 1: Input: s = \"rabbbit\", t = \"rabbit\" Output: 3 Explanation: As shown below, there are 3 ways you can generate \"rabbit\" from s. rabb b it ra b bbit rab b bit Example 2: Input: s = \"babgbag\", t = \"bag\" Output: 5 Explanation: As shown below, there are 5 ways you can generate \"bag\" from s. ba b g bag ba bgba g b abgb ag ba b gb ag babg bag Constraints: 1 <= s.length, t.length <= 1000 s and t consist of English letters.\n", "code_prompt": "class Solution:\n    def numDistinct(self, s: str, t: str) -> int:\n        ", "raw_response": "```python\nclass Solution:\n    def numDistinct(self, s: str, t: str) -> int:\n        # Create a 2-dimensional dp table with dimensions (len(s)+1) x (len(t)+1)\n        dp = [[0] * (len(t)+1) for _ in range(len(s)+1)]\n        \n        # Fill the first column of the dp table with 1's, since there is only one way to form an empty string from any non-empty string\n        for i in range(len(s)+1):\n            dp[i][0] = 1\n        \n        # Iterate through the characters of s and t\n        for i in range(1, len(s)+1):\n            for j in range(1, len(t)+1):\n                # If the current characters of s and t are equal, we have two choices:\n                # 1. Include the current character of s in the subsequence,\n                #    so the number of distinct subsequences is equal to the number of distinct subsequences before excluding the current character of s,\n                #    plus the number of distinct subsequences before including the current character of s in both s and t.\n                # 2. Exclude the current character of s from the subsequence,\n                #    so the number of distinct subsequences is equal to the number of distinct subsequences before excluding the current character of s.\n                if s[i-1] == t[j-1]:\n                    dp[i][j] = dp[i-1][j-1] + dp[i-1][j]\n                # If the current characters of s and t are not equal,\n                # we can only exclude the current character of s from the subsequence,\n                # so the number of distinct subsequences is equal to the number of distinct subsequences before excluding the current character of s.\n                else:\n                    dp[i][j] = dp[i-1][j]\n        \n        # Return the number of distinct subsequences to form t from s, which is the last element of dp\n        return dp[-1][-1]\n```\nThe time complexity of this solution is O(len(s) * len(t)), and the space complexity is O(len(s) * len(t)).", "cleaned_response": "\nclass Solution:\n    def numDistinct(self, s: str, t: str) -> int:\n        # Create a 2-dimensional dp table with dimensions (len(s)+1) x (len(t)+1)\n        dp = [[0] * (len(t)+1) for _ in range(len(s)+1)]\n        \n        # Fill the first column of the dp table with 1's, since there is only one way to form an empty string from any non-empty string\n        for i in range(len(s)+1):\n            dp[i][0] = 1\n        \n        # Iterate through the characters of s and t\n        for i in range(1, len(s)+1):\n            for j in range(1, len(t)+1):\n                # If the current characters of s and t are equal, we have two choices:\n                # 1. Include the current character of s in the subsequence,\n                #    so the number of distinct subsequences is equal to the number of distinct subsequences before excluding the current character of s,\n                #    plus the number of distinct subsequences before including the current character of s in both s and t.\n                # 2. Exclude the current character of s from the subsequence,\n                #    so the number of distinct subsequences is equal to the number of distinct subsequences before excluding the current character of s.\n                if s[i-1] == t[j-1]:\n                    dp[i][j] = dp[i-1][j-1] + dp[i-1][j]\n                # If the current characters of s and t are not equal,\n                # we can only exclude the current character of s from the subsequence,\n                # so the number of distinct subsequences is equal to the number of distinct subsequences before excluding the current character of s.\n                else:\n                    dp[i][j] = dp[i-1][j]\n        \n        # Return the number of distinct subsequences to form t from s, which is the last element of dp\n        return dp[-1][-1]\n", "n_pass": 1, "difficulty": 3.0, "frontend_question_id": 115.0, "loc": 114}
{"task_input": "\nLeetCode Problem #118\nTitle: Pascal's Triangle\nDescription:\nGiven an integer numRows, return the first numRows of Pascal's triangle. In Pascal's triangle, each number is the sum of the two numbers directly above it as shown: Example 1: Input: numRows = 5 Output: [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]] Example 2: Input: numRows = 1 Output: [[1]] Constraints: 1 <= numRows <= 30\n", "code_prompt": "class Solution:\n    def generate(self, numRows: int) -> List[List[int]]:\n        ", "raw_response": "class Solution:\n    def generate(self, numRows: int) -> List[List[int]]:\n        pascal_triangle = []\n        for i in range(numRows):\n            row = [1] * (i+1)\n            for j in range(1, i):\n                row[j] = pascal_triangle[i-1][j-1] + pascal_triangle[i-1][j]\n            pascal_triangle.append(row)\n        return pascal_triangle", "cleaned_response": "class Solution:\n    def generate(self, numRows: int) -> List[List[int]]:\n        pascal_triangle = []\n        for i in range(numRows):\n            row = [1] * (i+1)\n            for j in range(1, i):\n                row[j] = pascal_triangle[i-1][j-1] + pascal_triangle[i-1][j]\n            pascal_triangle.append(row)\n        return pascal_triangle", "n_pass": 1, "difficulty": 1.0, "frontend_question_id": 118.0, "loc": 117}
{"task_input": "\nLeetCode Problem #122\nTitle: Best Time to Buy and Sell Stock II\nDescription:\nYou are given an integer array prices where prices[i] is the price of a given stock on the i th day. On each day, you may decide to buy and/or sell the stock. You can only hold at most one share of the stock at any time. However, you can buy it then immediately sell it on the same day. Find and return the maximum profit you can achieve. Example 1: Input: prices = [7, 1, 5, 3, 6, 4] Output: 7 Explanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4. Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3. Total profit is 4 + 3 = 7. Example 2: Input: prices = [1, 2, 3, 4, 5] Output: 4 Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4. Total profit is 4. Example 3: Input: prices = [7, 6, 4, 3, 1] Output: 0 Explanation: There is no way to make a positive profit, so we never buy the stock to achieve the maximum profit of 0. Constraints: 1 <= prices.length <= 3 * 10e4 0 <= prices[i] <= 10e4\n", "code_prompt": "class Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        ", "raw_response": "```python\nclass Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        if not prices:\n            return 0\n        \n        total_profit = 0\n        \n        for i in range(len(prices)-1):\n            if prices[i+1] > prices[i]:\n                total_profit += prices[i+1] - prices[i]\n        \n        return total_profit\n```", "cleaned_response": "\nclass Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        if not prices:\n            return 0\n        \n        total_profit = 0\n        \n        for i in range(len(prices)-1):\n            if prices[i+1] > prices[i]:\n                total_profit += prices[i+1] - prices[i]\n        \n        return total_profit\n", "n_pass": 1, "difficulty": 2.0, "frontend_question_id": 122.0, "loc": 121}
{"task_input": "\nLeetCode Problem #123\nTitle: Best Time to Buy and Sell Stock III\nDescription:\nYou are given an array prices where prices[i] is the price of a given stock on the i th day. Find the maximum profit you can achieve. You may complete at most two transactions. Note: You may not engage in multiple transactions simultaneously (i. e. , you must sell the stock before you buy again). Example 1: Input: prices = [3, 3, 5, 0, 0, 3, 1, 4] Output: 6 Explanation: Buy on day 4 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3. Then buy on day 7 (price = 1) and sell on day 8 (price = 4), profit = 4-1 = 3. Example 2: Input: prices = [1, 2, 3, 4, 5] Output: 4 Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4. Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are engaging multiple transactions at the same time. You must sell before buying again. Example 3: Input: prices = [7, 6, 4, 3, 1] Output: 0 Explanation: In this case, no transaction is done, i. e. max profit = 0. Constraints: 1 <= prices.length <= 10e5 0 <= prices[i] <= 10e5\n", "code_prompt": "class Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        ", "raw_response": "```python\nfrom typing import List\n\nclass Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        n = len(prices)\n        if n <= 1:\n            return 0\n        \n        max_transactions = 2\n        dp = [[0] * n for _ in range(max_transactions+1)]\n        \n        for t in range(1, max_transactions+1):\n            max_diff = -prices[0]\n            for i in range(1, n):\n                dp[t][i] = max(dp[t][i-1], prices[i] + max_diff)\n                max_diff = max(max_diff, dp[t-1][i] - prices[i])\n        \n        return dp[max_transactions][n-1]\n```", "cleaned_response": "\nfrom typing import List\n\nclass Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        n = len(prices)\n        if n <= 1:\n            return 0\n        \n        max_transactions = 2\n        dp = [[0] * n for _ in range(max_transactions+1)]\n        \n        for t in range(1, max_transactions+1):\n            max_diff = -prices[0]\n            for i in range(1, n):\n                dp[t][i] = max(dp[t][i-1], prices[i] + max_diff)\n                max_diff = max(max_diff, dp[t-1][i] - prices[i])\n        \n        return dp[max_transactions][n-1]\n", "n_pass": 1, "difficulty": 3.0, "frontend_question_id": 123.0, "loc": 122}
{"task_input": "\nLeetCode Problem #124\nTitle: Binary Tree Maximum Path Sum\nDescription:\nA path in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them. A node can only appear in the sequence at most once. Note that the path does not need to pass through the root. The path sum of a path is the sum of the node's values in the path. Given the root of a binary tree, return the maximum path sum of any non-empty path. Example 1: Input: root = [1, 2, 3] Output: 6 Explanation: The optimal path is 2 -> 1 -> 3 with a path sum of 2 + 1 + 3 = 6. Example 2: Input: root = [-10, 9, 20, null, null, 15, 7] Output: 42 Explanation: The optimal path is 15 -> 20 -> 7 with a path sum of 15 + 20 + 7 = 42. Constraints: The number of nodes in the tree is in the range [1, 3 * 10e4 ]. -1000 <= Node. val <= 1000\n", "code_prompt": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxPathSum(self, root: Optional[TreeNode]) -> int:\n        ", "raw_response": "```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    def maxPathSum(self, root: Optional[TreeNode]) -> int:\n        # Helper function to calculate the maximum path sum\n        def maxPathSumHelper(node):\n            nonlocal maxSum\n            if node is None:\n                return 0\n\n            # Recursively find the maximum path sum of the left and right subtrees\n            leftPathSum = max(0, maxPathSumHelper(node.left))\n            rightPathSum = max(0, maxPathSumHelper(node.right))\n\n            # Update the maximum path sum if the current path sum is greater\n            maxSum = max(maxSum, leftPathSum + rightPathSum + node.val)\n\n            # Return the maximum path sum including the current node\n            return max(leftPathSum, rightPathSum) + node.val\n\n        # Initialize the maximum path sum to negative infinity\n        maxSum = float('-inf')\n        \n        # Call the helper function to calculate the maximum path sum\n        maxPathSumHelper(root)\n        \n        # Return the maximum path sum\n        return maxSum\n```\n\nThe code defines a class `Solution` that contains a method `maxPathSum` which takes a binary tree root node as input and returns the maximum path sum of any non-empty path in the tree.\n\nThe helper function `maxPathSumHelper` is used to calculate the maximum path sum recursively. It takes a node as input and returns the maximum path sum of any non-empty path starting from that node.\n\nInside the `maxPathSumHelper` function, we first check if the node is None. If so, we return 0.\n\nThen, we recursively find the maximum path sum of the left and right subtrees using the `maxPathSumHelper` function. We store the maximum path sum of the left subtree in the variable `leftPathSum` and the maximum path sum of the right subtree in the variable `rightPathSum`.\n\nNext, we update the maximum path sum `maxSum` by adding the current node's value to the sum of the left and right path sums, and compare it with the current maximum path sum.\n\nFinally, we return the maximum path sum including the current node by taking the maximum of the left and right path sums and adding the current node's value.\n\nIn the `maxPathSum` method, we initialize the maximum path sum `maxSum` to negative infinity.\n\nThen, we call the `maxPathSumHelper` function with the root node to calculate the maximum path sum.\n\nFinally, we return the maximum path sum.", "cleaned_response": "\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    def maxPathSum(self, root: Optional[TreeNode]) -> int:\n        # Helper function to calculate the maximum path sum\n        def maxPathSumHelper(node):\n            nonlocal maxSum\n            if node is None:\n                return 0\n\n            # Recursively find the maximum path sum of the left and right subtrees\n            leftPathSum = max(0, maxPathSumHelper(node.left))\n            rightPathSum = max(0, maxPathSumHelper(node.right))\n\n            # Update the maximum path sum if the current path sum is greater\n            maxSum = max(maxSum, leftPathSum + rightPathSum + node.val)\n\n            # Return the maximum path sum including the current node\n            return max(leftPathSum, rightPathSum) + node.val\n\n        # Initialize the maximum path sum to negative infinity\n        maxSum = float('-inf')\n        \n        # Call the helper function to calculate the maximum path sum\n        maxPathSumHelper(root)\n        \n        # Return the maximum path sum\n        return maxSum\n", "n_pass": 1, "difficulty": 3.0, "frontend_question_id": 124.0, "loc": 123}
{"task_input": "\nLeetCode Problem #125\nTitle: Valid Palindrome\nDescription:\nA phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. Alphanumeric characters include letters and numbers. Given a string s, return true if it is a palindrome, or false otherwise. Example 1: Input: s = \"A man, a plan, a canal: Panama\" Output: true Explanation: \"amanaplanacanalpanama\" is a palindrome. Example 2: Input: s = \"race a car\" Output: false Explanation: \"raceacar\" is not a palindrome. Example 3: Input: s = \" \" Output: true Explanation: s is an empty string \"\" after removing non-alphanumeric characters. Since an empty string reads the same forward and backward, it is a palindrome. Constraints: 1 <= s.length <= 2 * 10e5 s consists only of printable ASCII characters.\n", "code_prompt": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        ", "raw_response": "```python\nclass Solution:\n    def isPalindrome(self, s: str) -> bool:\n        # Convert all uppercase letters to lowercase\n        s = s.lower()\n        \n        # Remove non-alphanumeric characters\n        s = ''.join(c for c in s if c.isalnum())\n        \n        # Check if the modified string is a palindrome\n        return s == s[::-1]\n```", "cleaned_response": "\nclass Solution:\n    def isPalindrome(self, s: str) -> bool:\n        # Convert all uppercase letters to lowercase\n        s = s.lower()\n        \n        # Remove non-alphanumeric characters\n        s = ''.join(c for c in s if c.isalnum())\n        \n        # Check if the modified string is a palindrome\n        return s == s[::-1]\n", "n_pass": 1, "difficulty": 1.0, "frontend_question_id": 125.0, "loc": 124}
{"task_input": "\nLeetCode Problem #126\nTitle: Word Ladder II\nDescription:\nA transformation sequence from word beginWord to word endWord using a dictionary wordList is a sequence of words beginWord -> s 1 -> s 2 ->. . . -> s k such that:...\n Every adjacent pair of words differs by a single letter. Every s i for 1 <= i <= k is in wordList. Note that beginWord does not need to be in wordList. s k == endWord Given two words, beginWord and endWord, and a dictionary wordList, return all the shortest transformation sequences from beginWord to endWord, or an empty list if no such sequence exists. Each sequence should be returned as a list of the words [beginWord, s 1, s 2,. . . , s k ]. Example 1: Input: beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\", \"dot\", \"dog\", \"lot\", \"log\", \"cog\"] Output: [[\"hit\", \"hot\", \"dot\", \"dog\", \"cog\"], [\"hit\", \"hot\", \"lot\", \"log\", \"cog\"]] Explanation: There are 2 shortest transformation sequences: \"hit\" -> \"hot\" -> \"dot\" -> \"dog\" -> \"cog\" \"hit\" -> \"hot\" -> \"lot\" -> \"log\" -> \"cog\" Example 2: Input: beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\", \"dot\", \"dog\", \"lot\", \"log\"] Output: [] Explanation: The endWord \"cog\" is not in wordList, therefore there is no valid transformation sequence. Constraints: 1 <= beginWord.length <= 5 endWord.length == beginWord.length 1 <= wordList.length <= 500 wordList[i].length == beginWord.length beginWord, endWord, and wordList[i] consist of lowercase English letters. beginWord != endWord All the words in wordList are unique. The sum of all shortest transformation sequences does not exceed 10e5.\n", "code_prompt": "class Solution:\n    def findLadders(self, beginWord: str, endWord: str, wordList: List[str]) -> List[List[str]]:\n        ", "raw_response": "```\nfrom typing import List\nfrom collections import deque\n\nclass Solution:\n    def findLadders(self, beginWord: str, endWord: str, wordList: List[str]) -> List[List[str]]:\n        # Create a set for fast lookup of words in wordList\n        wordSet = set(wordList)\n        \n        # Edge case: If endWord is not in wordList, there is no transformation sequence\n        if endWord not in wordSet:\n            return []\n        \n        # Remove beginWord from wordSet if it is present\n        if beginWord in wordSet:\n            wordSet.remove(beginWord)\n        \n        # Build adjacency list using BFS\n        adjList = self.buildAdjList(beginWord, endWord, wordSet)\n        \n        # Perform BFS to find all shortest transformation sequences\n        sequences = []\n        queue = deque([[beginWord]])\n        visited = set()\n        shortest = float('inf')\n        while queue:\n            path = queue.popleft()\n            currWord = path[-1]\n            if currWord not in visited:\n                visited.add(currWord)\n                if currWord == endWord:\n                    shortest = len(path)\n                    sequences.append(path)\n                elif len(path) < shortest:\n                    for neighbor in adjList[currWord]:\n                        queue.append(path + [neighbor])\n        \n        return sequences\n    \n    # Helper function to build adjacency list\n    def buildAdjList(self, beginWord, endWord, wordSet):\n        adjList = {}\n        queue = deque([beginWord])\n        visited = set()\n        visited.add(beginWord)\n        while queue:\n            currWord = queue.popleft()\n            adjList[currWord] = []\n            for i in range(len(currWord)):\n                for char in 'abcdefghijklmnopqrstuvwxyz':\n                    nextWord = currWord[:i] + char + currWord[i+1:]\n                    if nextWord in wordSet:\n                        adjList[currWord].append(nextWord)\n                        if nextWord not in visited:\n                            queue.append(nextWord)\n                            visited.add(nextWord)\n        return adjList\n\n# Test cases\nsolution = Solution()\nbeginWord = \"hit\"\nendWord = \"cog\"\nwordList = [\"hot\", \"dot\", \"dog\", \"lot\", \"log\", \"cog\"]\nprint(solution.findLadders(beginWord, endWord, wordList))\n# Output: [[\"hit\", \"hot\", \"dot\", \"dog\", \"cog\"], [\"hit\", \"hot\", \"lot\", \"log\", \"cog\"]]\n\nbeginWord = \"hit\"\nendWord = \"cog\"\nwordList = [\"hot\", \"dot\", \"dog\", \"lot\", \"log\"]\nprint(solution.findLadders(beginWord, endWord, wordList))\n# Output: []\n```", "cleaned_response": "\nfrom typing import List\nfrom collections import deque\n\nclass Solution:\n    def findLadders(self, beginWord: str, endWord: str, wordList: List[str]) -> List[List[str]]:\n        # Create a set for fast lookup of words in wordList\n        wordSet = set(wordList)\n        \n        # Edge case: If endWord is not in wordList, there is no transformation sequence\n        if endWord not in wordSet:\n            return []\n        \n        # Remove beginWord from wordSet if it is present\n        if beginWord in wordSet:\n            wordSet.remove(beginWord)\n        \n        # Build adjacency list using BFS\n        adjList = self.buildAdjList(beginWord, endWord, wordSet)\n        \n        # Perform BFS to find all shortest transformation sequences\n        sequences = []\n        queue = deque([[beginWord]])\n        visited = set()\n        shortest = float('inf')\n        while queue:\n            path = queue.popleft()\n            currWord = path[-1]\n            if currWord not in visited:\n                visited.add(currWord)\n                if currWord == endWord:\n                    shortest = len(path)\n                    sequences.append(path)\n                elif len(path) < shortest:\n                    for neighbor in adjList[currWord]:\n                        queue.append(path + [neighbor])\n        \n        return sequences\n    \n    # Helper function to build adjacency list\n    def buildAdjList(self, beginWord, endWord, wordSet):\n        adjList = {}\n        queue = deque([beginWord])\n        visited = set()\n        visited.add(beginWord)\n        while queue:\n            currWord = queue.popleft()\n            adjList[currWord] = []\n            for i in range(len(currWord)):\n                for char in 'abcdefghijklmnopqrstuvwxyz':\n                    nextWord = currWord[:i] + char + currWord[i+1:]\n                    if nextWord in wordSet:\n                        adjList[currWord].append(nextWord)\n                        if nextWord not in visited:\n                            queue.append(nextWord)\n                            visited.add(nextWord)\n        return adjList\n\n# Test cases\nsolution = Solution()\nbeginWord = \"hit\"\nendWord = \"cog\"\nwordList = [\"hot\", \"dot\", \"dog\", \"lot\", \"log\", \"cog\"]\nprint(solution.findLadders(beginWord, endWord, wordList))\n# Output: [[\"hit\", \"hot\", \"dot\", \"dog\", \"cog\"], [\"hit\", \"hot\", \"lot\", \"log\", \"cog\"]]\n\nbeginWord = \"hit\"\nendWord = \"cog\"\nwordList = [\"hot\", \"dot\", \"dog\", \"lot\", \"log\"]\nprint(solution.findLadders(beginWord, endWord, wordList))\n# Output: []\n", "n_pass": 1, "difficulty": 3.0, "frontend_question_id": 126.0, "loc": 125}
{"task_input": "\nLeetCode Problem #127\nTitle: Word Ladder\nDescription:\nA transformation sequence from word beginWord to word endWord using a dictionary wordList is a sequence of words beginWord -> s 1 -> s 2 ->. . . -> s k such that:...\n Every adjacent pair of words differs by a single letter. Every s i for 1 <= i <= k is in wordList. Note that beginWord does not need to be in wordList. s k == endWord Given two words, beginWord and endWord, and a dictionary wordList, return the number of words in the shortest transformation sequence from beginWord to endWord, or 0 if no such sequence exists. Example 1: Input: beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\", \"dot\", \"dog\", \"lot\", \"log\", \"cog\"] Output: 5 Explanation: One shortest transformation sequence is \"hit\" -> \"hot\" -> \"dot\" -> \"dog\" -> cog\", which is 5 words long. Example 2: Input: beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\", \"dot\", \"dog\", \"lot\", \"log\"] Output: 0 Explanation: The endWord \"cog\" is not in wordList, therefore there is no valid transformation sequence. Constraints: 1 <= beginWord.length <= 10 endWord.length == beginWord.length 1 <= wordList.length <= 5000 wordList[i].length == beginWord.length beginWord, endWord, and wordList[i] consist of lowercase English letters. beginWord != endWord All the words in wordList are unique.\n", "code_prompt": "class Solution:\n    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:\n        ", "raw_response": "```python\nclass Solution:\n    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:\n        # Create a set of words in the wordList for easy membership check\n        wordSet = set(wordList)\n        # If the endWord is not in the wordList, there is no valid transformation sequence\n        if endWord not in wordSet:\n            return 0\n        \n        visited = set()  # Set to keep track of visited words\n        queue = [(beginWord, 1)]  # Queue to store words and their corresponding level\n        \n        while queue:\n            word, level = queue.pop(0)  # Pop the first word from the queue\n            \n            # Check if the current word is the end word, if so, return the level\n            if word == endWord:\n                return level\n            \n            # Generate all possible next words by changing one character at a time\n            for i in range(len(word)):\n                for char in 'abcdefghijklmnopqrstuvwxyz':\n                    newWord = word[:i] + char + word[i+1:]\n                    \n                    # If the newWord is in the wordSet and has not been visited before, add it to the queue and mark it as visited\n                    if newWord in wordSet and newWord not in visited:\n                        queue.append((newWord, level+1))\n                        visited.add(newWord)\n        \n        return 0  # If there is no valid transformation sequence, return 0\n```", "cleaned_response": "\nclass Solution:\n    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:\n        # Create a set of words in the wordList for easy membership check\n        wordSet = set(wordList)\n        # If the endWord is not in the wordList, there is no valid transformation sequence\n        if endWord not in wordSet:\n            return 0\n        \n        visited = set()  # Set to keep track of visited words\n        queue = [(beginWord, 1)]  # Queue to store words and their corresponding level\n        \n        while queue:\n            word, level = queue.pop(0)  # Pop the first word from the queue\n            \n            # Check if the current word is the end word, if so, return the level\n            if word == endWord:\n                return level\n            \n            # Generate all possible next words by changing one character at a time\n            for i in range(len(word)):\n                for char in 'abcdefghijklmnopqrstuvwxyz':\n                    newWord = word[:i] + char + word[i+1:]\n                    \n                    # If the newWord is in the wordSet and has not been visited before, add it to the queue and mark it as visited\n                    if newWord in wordSet and newWord not in visited:\n                        queue.append((newWord, level+1))\n                        visited.add(newWord)\n        \n        return 0  # If there is no valid transformation sequence, return 0\n", "n_pass": 1, "difficulty": 3.0, "frontend_question_id": 127.0, "loc": 126}
{"task_input": "\nLeetCode Problem #128\nTitle: Longest Consecutive Sequence\nDescription:\nGiven an unsorted array of integers nums, return the length of the longest consecutive elements sequence. You must write an algorithm that runs in O(n) time. Example 1: Input: nums = [100, 4, 200, 1, 3, 2] Output: 4 Explanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4. Example 2: Input: nums = [0, 3, 7, 2, 5, 8, 4, 6, 0, 1] Output: 9 Constraints: 0 <= nums.length <= 10e5 -10e9 <= nums[i] <= 10e9\n", "code_prompt": "class Solution:\n    def longestConsecutive(self, nums: List[int]) -> int:\n        ", "raw_response": "```python\nclass Solution:\n    def longestConsecutive(self, nums: List[int]) -> int:\n        # Store all numbers from the input array in a set for quick lookup\n        num_set = set(nums)\n        longest_seq = 0\n        \n        # Iterate through each number in the array\n        for num in nums:\n            # Only process the current number if it's the start of a sequence (the previous consecutive number is not present in the set)\n            if num-1 not in num_set:\n                current_num = num\n                current_seq = 1\n                \n                # Find the length of the consecutive sequence\n                while current_num+1 in num_set:\n                    current_num += 1\n                    current_seq += 1\n                \n                # Update the longest sequence if necessary\n                longest_seq = max(longest_seq, current_seq)\n        \n        return longest_seq\n```\nThe code above solves the \"Longest Consecutive Sequence\" problem on LeetCode. It first creates a set from the input array for efficient lookup. Then, it iterates through each number in the array and checks if it is the start of a sequence (i.e., the previous consecutive number is not present in the set). If it is the start of a sequence, it counts the length of the consecutive sequence by incrementing the current number until the next consecutive number is not in the set. Finally, it updates the longest sequence length if necessary and returns the result. The time complexity of this solution is O(n), where n is the length of the input array.", "cleaned_response": "\nclass Solution:\n    def longestConsecutive(self, nums: List[int]) -> int:\n        # Store all numbers from the input array in a set for quick lookup\n        num_set = set(nums)\n        longest_seq = 0\n        \n        # Iterate through each number in the array\n        for num in nums:\n            # Only process the current number if it's the start of a sequence (the previous consecutive number is not present in the set)\n            if num-1 not in num_set:\n                current_num = num\n                current_seq = 1\n                \n                # Find the length of the consecutive sequence\n                while current_num+1 in num_set:\n                    current_num += 1\n                    current_seq += 1\n                \n                # Update the longest sequence if necessary\n                longest_seq = max(longest_seq, current_seq)\n        \n        return longest_seq\n", "n_pass": 1, "difficulty": 2.0, "frontend_question_id": 128.0, "loc": 127}
{"task_input": "\nLeetCode Problem #129\nTitle: Sum Root to Leaf Numbers\nDescription:\nYou are given the root of a binary tree containing digits from 0 to 9 only. Each root-to-leaf path in the tree represents a number. For example, the root-to-leaf path 1 -> 2 -> 3 represents the number 123. Return the total sum of all root-to-leaf numbers. Test cases are generated so that the answer will fit in a 32-bit integer. A leaf node is a node with no children. Example 1: Input: root = [1, 2, 3] Output: 25 Explanation: The root-to-leaf path 1->2 represents the number 12. The root-to-leaf path 1->3 represents the number 13. Therefore, sum = 12 + 13 = 25. Example 2: Input: root = [4, 9, 0, 5, 1] Output: 1026 Explanation: The root-to-leaf path 4->9->5 represents the number 495. The root-to-leaf path 4->9->1 represents the number 491. The root-to-leaf path 4->0 represents the number 40. Therefore, sum = 495 + 491 + 40 = 1026. Constraints: The number of nodes in the tree is in the range [1, 1000]. 0 <= Node. val <= 9 The depth of the tree will not exceed 10.\n", "code_prompt": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\n        ", "raw_response": "```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\n        def helper(node, num):\n            if not node:\n                return 0\n            \n            num = num * 10 + node.val\n            \n            if not node.left and not node.right:\n                return num\n            \n            return helper(node.left, num) + helper(node.right, num)\n        \n        return helper(root, 0)\n```\n\nExplanation:\nThe idea to solve this problem is to perform a depth-first search (DFS) on the binary tree. We maintain a helper function that takes the current node and the current number formed by the root-to-current-node path. If the current node is a leaf node, we return the current number. Otherwise, we recursively call the helper function on the left and right subtrees and return their sum. We also update the current number by multiplying it by 10 and adding the value of the current node.\n\nTime Complexity Analysis:\nThe time complexity for this solution is O(N), where N is the number of nodes in the binary tree. This is because we may need to visit all the nodes in the tree in the worst case.", "cleaned_response": "\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\n        def helper(node, num):\n            if not node:\n                return 0\n            \n            num = num * 10 + node.val\n            \n            if not node.left and not node.right:\n                return num\n            \n            return helper(node.left, num) + helper(node.right, num)\n        \n        return helper(root, 0)\n", "n_pass": 1, "difficulty": 2.0, "frontend_question_id": 129.0, "loc": 128}
{"task_input": "\nLeetCode Problem #130\nTitle: Surrounded Regions\nDescription:\nGiven an m x n matrix board containing 'X' and 'O', capture all regions that are 4-directionally surrounded by 'X'. A region is captured by flipping all 'O' s into 'X' s in that surrounded region. Example 1: Input: board = [[\"X\", \"X\", \"X\", \"X\"], [\"X\", \"O\", \"O\", \"X\"], [\"X\", \"X\", \"O\", \"X\"], [\"X\", \"O\", \"X\", \"X\"]] Output: [[\"X\", \"X\", \"X\", \"X\"], [\"X\", \"X\", \"X\", \"X\"], [\"X\", \"X\", \"X\", \"X\"], [\"X\", \"O\", \"X\", \"X\"]] Explanation: Notice that an 'O' should not be flipped if: - It is on the border, or - It is adjacent to an 'O' that should not be flipped. The bottom 'O' is on the border, so it is not flipped. The other three 'O' form a surrounded region, so they are flipped. Example 2: Input: board = [[\"X\"]] Output: [[\"X\"]] Constraints: m == board.length n == board[i].length 1 <= m, n <= 200 board[i][j] is 'X' or 'O'.\n", "code_prompt": "class Solution:\n    def solve(self, board: List[List[str]]) -> None:\n        \"\"\"\n        Do not return anything, modify board in-place instead.\n        \"\"\"\n        ", "raw_response": "```python\nfrom typing import List\n\nclass Solution:\n    def solve(self, board: List[List[str]]) -> None:\n        \"\"\"\n        Do not return anything, modify board in-place instead.\n        \"\"\"\n        if not board:\n            return\n        \n        m = len(board)\n        n = len(board[0])\n        \n        # Define a helper function to mark the connected 'O's as visited\n        def dfs(i: int, j: int) -> None:\n            # Base Cases\n            if i < 0 or i >= m or j < 0 or j >= n or board[i][j] != 'O':\n                return\n            \n            # Mark the current cell as visited\n            board[i][j] = '#'\n            \n            # Traverse the neighbors\n            dfs(i+1, j)\n            dfs(i-1, j)\n            dfs(i, j+1)\n            dfs(i, j-1)\n        \n        # Traverse the boundary 'O's and mark all connected 'O's as visited\n        for i in range(m):\n            dfs(i, 0)\n            dfs(i, n-1)\n        \n        for j in range(n):\n            dfs(0, j)\n            dfs(m-1, j)\n        \n        # Mark the remaining unvisited 'O's as 'X'\n        for i in range(m):\n            for j in range(n):\n                if board[i][j] == 'O':\n                    board[i][j] = 'X'\n        \n        # Restore the visited cells marked as '#'\n        for i in range(m):\n            for j in range(n):\n                if board[i][j] == '#':\n                    board[i][j] = 'O'\n```\n\nThis solution uses depth-first search (DFS) to mark all the connected 'O's starting from the boundary cells as visited. Then it marks the remaining unvisited 'O's as 'X' and restores the visited cells back to 'O'. The time complexity of this solution is O(m*n), where m is the number of rows and n is the number of columns in the board.", "cleaned_response": "\nfrom typing import List\n\nclass Solution:\n    def solve(self, board: List[List[str]]) -> None:\n        \"\"\"\n        Do not return anything, modify board in-place instead.\n        \"\"\"\n        if not board:\n            return\n        \n        m = len(board)\n        n = len(board[0])\n        \n        # Define a helper function to mark the connected 'O's as visited\n        def dfs(i: int, j: int) -> None:\n            # Base Cases\n            if i < 0 or i >= m or j < 0 or j >= n or board[i][j] != 'O':\n                return\n            \n            # Mark the current cell as visited\n            board[i][j] = '#'\n            \n            # Traverse the neighbors\n            dfs(i+1, j)\n            dfs(i-1, j)\n            dfs(i, j+1)\n            dfs(i, j-1)\n        \n        # Traverse the boundary 'O's and mark all connected 'O's as visited\n        for i in range(m):\n            dfs(i, 0)\n            dfs(i, n-1)\n        \n        for j in range(n):\n            dfs(0, j)\n            dfs(m-1, j)\n        \n        # Mark the remaining unvisited 'O's as 'X'\n        for i in range(m):\n            for j in range(n):\n                if board[i][j] == 'O':\n                    board[i][j] = 'X'\n        \n        # Restore the visited cells marked as '#'\n        for i in range(m):\n            for j in range(n):\n                if board[i][j] == '#':\n                    board[i][j] = 'O'\n", "n_pass": 1, "difficulty": 2.0, "frontend_question_id": 130.0, "loc": 129}
{"task_input": "\nLeetCode Problem #132\nTitle: Palindrome Partitioning II\nDescription:\nGiven a string s, partition s such that every substring of the partition is a palindrome. Return the minimum cuts needed for a palindrome partitioning of s. Example 1: Input: s = \"aab\" Output: 1 Explanation: The palindrome partitioning [\"aa\", \"b\"] could be produced using 1 cut. Example 2: Input: s = \"a\" Output: 0 Example 3: Input: s = \"ab\" Output: 1 Constraints: 1 <= s.length <= 2000 s consists of lowercase English letters only.\n", "code_prompt": "class Solution:\n    def minCut(self, s: str) -> int:\n        ", "raw_response": "```python\nclass Solution:\n    def minCut(self, s: str) -> int:\n        n = len(s)\n        # initialize dp array\n        dp = [[False] * n for _ in range(n)]\n        cuts = [0] * (n+1) # cuts[i] represents the minimum cuts needed for the first i characters\n        \n        # initialize base cases\n        for i in range(n):\n            dp[i][i] = True\n        \n        for j in range(1, n):\n            for i in range(j+1):\n                # check if substring is a palindrome\n                if s[i] == s[j] and (j - i <= 2 or dp[i+1][j-1]):\n                    dp[i][j] = True\n                    # update minimum cuts\n                    if i == 0:\n                        cuts[j] = 0\n                    else:\n                        cuts[j] = min(cuts[j], cuts[i-1]+1)\n        \n        return cuts[n-1]\n```\n\nThe provided code defines a class `Solution` and a method `minCut` that takes a string `s` as input and returns the minimum cuts needed for a palindrome partitioning of `s`. \n\nThe function uses dynamic programming to solve the problem. It first initializes a dp array to store whether a substring is a palindrome. It also initializes a cuts array to store the minimum cuts needed for the first i characters.\n\nIt then iterates over all possible substrings of `s` and checks if each substring is a palindrome. If a substring is a palindrome, it updates the dp array and updates the minimum cuts in the cuts array.\n\nFinally, it returns the minimum cuts needed for the last character of `s`.\n\nThe time complexity of this solution is O(n^2) and the space complexity is O(n), where n is the length of the input string `s`.", "cleaned_response": "\nclass Solution:\n    def minCut(self, s: str) -> int:\n        n = len(s)\n        # initialize dp array\n        dp = [[False] * n for _ in range(n)]\n        cuts = [0] * (n+1) # cuts[i] represents the minimum cuts needed for the first i characters\n        \n        # initialize base cases\n        for i in range(n):\n            dp[i][i] = True\n        \n        for j in range(1, n):\n            for i in range(j+1):\n                # check if substring is a palindrome\n                if s[i] == s[j] and (j - i <= 2 or dp[i+1][j-1]):\n                    dp[i][j] = True\n                    # update minimum cuts\n                    if i == 0:\n                        cuts[j] = 0\n                    else:\n                        cuts[j] = min(cuts[j], cuts[i-1]+1)\n        \n        return cuts[n-1]\n", "n_pass": 1, "difficulty": 3.0, "frontend_question_id": 132.0, "loc": 131}
{"task_input": "\nLeetCode Problem #133\nTitle: Clone Graph\nDescription:\nGiven a reference of a node in a connected undirected graph. Return a deep copy (clone) of the graph. Each node in the graph contains a value ( int ) and a list ( List[Node] ) of its neighbors. class Node { public int val; public List<Node> neighbors; } Test case format: For simplicity, each node's value is the same as the node's index (1-indexed). For example, the first node with val == 1, the second node with val == 2, and so on. The graph is represented in the test case using an adjacency list. An adjacency list is a collection of unordered lists used to represent a finite graph. Each list describes the set of neighbors of a node in the graph. The given node will always be the first node with val = 1. You must return the copy of the given node as a reference to the cloned graph. Example 1: Input: adjList = [[2, 4], [1, 3], [2, 4], [1, 3]] Output: [[2, 4], [1, 3], [2, 4], [1, 3]] Explanation: There are 4 nodes in the graph. 1st node (val = 1)'s neighbors are 2nd node (val = 2) and 4th node (val = 4). 2nd node (val = 2)'s neighbors are 1st node (val = 1) and 3rd node (val = 3). 3rd node (val = 3)'s neighbors are 2nd node (val = 2) and 4th node (val = 4). 4th node (val = 4)'s neighbors are 1st node (val = 1) and 3rd node (val = 3). Example 2: Input: adjList = [[]] Output: [[]] Explanation: Note that the input contains one empty list. The graph consists of only one node with val = 1 and it does not have any neighbors. Example 3: Input: adjList = [] Output: [] Explanation: This an empty graph, it does not have any nodes. Constraints: The number of nodes in the graph is in the range [0, 100]. 1 <= Node. val <= 100 Node. val is unique for each node. There are no repeated edges and no self-loops in the graph. The Graph is connected and all nodes can be visited starting from the given node.\n", "code_prompt": "\"\"\"\n# Definition for a Node.\nclass Node:\n    def __init__(self, val = 0, neighbors = None):\n        self.val = val\n        self.neighbors = neighbors if neighbors is not None else []\n\"\"\"\n\nclass Solution:\n    def cloneGraph(self, node: 'Node') -> 'Node':\n        ", "raw_response": "```python\n# Definition for a Node.\nclass Node:\n    def __init__(self, val = 0, neighbors = None):\n        self.val = val\n        self.neighbors = neighbors if neighbors is not None else []\n\nclass Solution:\n    def cloneGraph(self, node: 'Node') -> 'Node':\n        # Base case: if node is None, return None\n        if node is None:\n            return None\n        \n        # Create a mapping dictionary to store cloned nodes\n        mapping = {}\n        \n        # Create a queue to perform breadth-first search\n        queue = []\n        \n        # Create a cloned node for the starting node and add it to mapping and queue\n        cloned_node = Node(node.val)\n        mapping[node] = cloned_node\n        queue.append(node)\n        \n        # Perform breadth-first search until all nodes are cloned\n        while queue:\n            # Pop the front node from the queue\n            curr_node = queue.pop(0)\n            \n            # Iterate through the neighbors of the current node\n            for neighbor in curr_node.neighbors:\n                # If the neighbor is not cloned yet, create a cloned node for it\n                if neighbor not in mapping:\n                    cloned_neighbor = Node(neighbor.val)\n                    mapping[neighbor] = cloned_neighbor\n                    queue.append(neighbor)\n                \n                # Add the cloned neighbor to the neighbors list of the cloned current node\n                mapping[curr_node].neighbors.append(mapping[neighbor])\n        \n        # Return the cloned node of the starting node\n        return mapping[node]\n```", "cleaned_response": "\n# Definition for a Node.\nclass Node:\n    def __init__(self, val = 0, neighbors = None):\n        self.val = val\n        self.neighbors = neighbors if neighbors is not None else []\n\nclass Solution:\n    def cloneGraph(self, node: 'Node') -> 'Node':\n        # Base case: if node is None, return None\n        if node is None:\n            return None\n        \n        # Create a mapping dictionary to store cloned nodes\n        mapping = {}\n        \n        # Create a queue to perform breadth-first search\n        queue = []\n        \n        # Create a cloned node for the starting node and add it to mapping and queue\n        cloned_node = Node(node.val)\n        mapping[node] = cloned_node\n        queue.append(node)\n        \n        # Perform breadth-first search until all nodes are cloned\n        while queue:\n            # Pop the front node from the queue\n            curr_node = queue.pop(0)\n            \n            # Iterate through the neighbors of the current node\n            for neighbor in curr_node.neighbors:\n                # If the neighbor is not cloned yet, create a cloned node for it\n                if neighbor not in mapping:\n                    cloned_neighbor = Node(neighbor.val)\n                    mapping[neighbor] = cloned_neighbor\n                    queue.append(neighbor)\n                \n                # Add the cloned neighbor to the neighbors list of the cloned current node\n                mapping[curr_node].neighbors.append(mapping[neighbor])\n        \n        # Return the cloned node of the starting node\n        return mapping[node]\n", "n_pass": 1, "difficulty": 2.0, "frontend_question_id": 133.0, "loc": 132}
{"task_input": "\nLeetCode Problem #134\nTitle: Gas Station\nDescription:\nThere are n gas stations along a circular route, where the amount of gas at the i th station is gas[i]. You have a car with an unlimited gas tank and it costs cost[i] of gas to travel from the i th station to its next (i + 1) th station. You begin the journey with an empty tank at one of the gas stations. Given two integer arrays gas and cost, return the starting gas station's index if you can travel around the circuit once in the clockwise direction, otherwise return -1. If there exists a solution, it is guaranteed to be unique Example 1: Input: gas = [1, 2, 3, 4, 5], cost = [3, 4, 5, 1, 2] Output: 3 Explanation: Start at station 3 (index 3) and fill up with 4 unit of gas. Your tank = 0 + 4 = 4 Travel to station 4. Your tank = 4 - 1 + 5 = 8 Travel to station 0. Your tank = 8 - 2 + 1 = 7 Travel to station 1. Your tank = 7 - 3 + 2 = 6 Travel to station 2. Your tank = 6 - 4 + 3 = 5 Travel to station 3. The cost is 5. Your gas is just enough to travel back to station 3. Therefore, return 3 as the starting index. Example 2: Input: gas = [2, 3, 4], cost = [3, 4, 3] Output: -1 Explanation: You can't start at station 0 or 1, as there is not enough gas to travel to the next station. Let's start at station 2 and fill up with 4 unit of gas. Your tank = 0 + 4 = 4 Travel to station 0. Your tank = 4 - 3 + 2 = 3 Travel to station 1. Your tank = 3 - 3 + 3 = 3 You cannot travel back to station 2, as it requires 4 unit of gas but you only have 3. Therefore, you can't travel around the circuit once no matter where you start. Constraints: n == gas.length == cost.length 1 <= n <= 10e5 0 <= gas[i], cost[i] <= 10e4\n", "code_prompt": "class Solution:\n    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:\n        ", "raw_response": "```python\nfrom typing import List\n\nclass Solution:\n    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:\n        total_gas = 0\n        current_gas = 0\n        start_index = 0\n        \n        for i in range(len(gas)):\n            total_gas += gas[i] - cost[i]\n            current_gas += gas[i] - cost[i]\n            \n            if current_gas < 0:\n                start_index = i + 1\n                current_gas = 0\n        \n        if total_gas < 0:\n            return -1\n        \n        return start_index\n```", "cleaned_response": "\nfrom typing import List\n\nclass Solution:\n    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:\n        total_gas = 0\n        current_gas = 0\n        start_index = 0\n        \n        for i in range(len(gas)):\n            total_gas += gas[i] - cost[i]\n            current_gas += gas[i] - cost[i]\n            \n            if current_gas < 0:\n                start_index = i + 1\n                current_gas = 0\n        \n        if total_gas < 0:\n            return -1\n        \n        return start_index\n", "n_pass": 1, "difficulty": 2.0, "frontend_question_id": 134.0, "loc": 133}
{"task_input": "\nLeetCode Problem #135\nTitle: Candy\nDescription:\nThere are n children standing in a line. Each child is assigned a rating value given in the integer array ratings. You are giving candies to these children subjected to the following requirements: Each child must have at least one candy. Children with a higher rating get more candies than their neighbors. Return the minimum number of candies you need to have to distribute the candies to the children. Example 1: Input: ratings = [1, 0, 2] Output: 5 Explanation: You can allocate to the first, second and third child with 2, 1, 2 candies respectively. Example 2: Input: ratings = [1, 2, 2] Output: 4 Explanation: You can allocate to the first, second and third child with 1, 2, 1 candies respectively. The third child gets 1 candy because it satisfies the above two conditions. Constraints: n == ratings.length 1 <= n <= 2 * 10e4 0 <= ratings[i] <= 2 * 10e4\n", "code_prompt": "class Solution:\n    def candy(self, ratings: List[int]) -> int:\n        ", "raw_response": "Re-stating the problem:\n\nYou are given a list of ratings representing the ratings of children standing in a line. Your task is to distribute candies to these children according to the following rules:\n\n1. Each child must have at least one candy.\n2. Children with a higher rating than their neighbors should receive more candies.\n\nYou need to determine the minimum number of candies required to distribute to the children.\n\nExample 1:\nInput: ratings = [1, 0, 2]\nOutput: 5\nExplanation: You can allocate to the first, second and third child with 2, 1, 2 candies respectively.\n\nExample 2:\nInput: ratings = [1, 2, 2]\nOutput: 4\nExplanation: You can allocate to the first, second and third child with 1, 2, 1 candies respectively. The third child gets 1 candy because it satisfies the above two conditions.\n\nConstraints:\n- n == ratings.length\n- 1 <= n <= 2 * 10^4\n- 0 <= ratings[i] <= 2 * 10^4\n\nNow let's provide the solution:", "cleaned_response": "Re-stating the problem:\n\nYou are given a list of ratings representing the ratings of children standing in a line. Your task is to distribute candies to these children according to the following rules:\n\n1. Each child must have at least one candy.\n2. Children with a higher rating than their neighbors should receive more candies.\n\nYou need to determine the minimum number of candies required to distribute to the children.\n\nExample 1:\nInput: ratings = [1, 0, 2]\nOutput: 5\nExplanation: You can allocate to the first, second and third child with 2, 1, 2 candies respectively.\n\nExample 2:\nInput: ratings = [1, 2, 2]\nOutput: 4\nExplanation: You can allocate to the first, second and third child with 1, 2, 1 candies respectively. The third child gets 1 candy because it satisfies the above two conditions.\n\nConstraints:\n- n == ratings.length\n- 1 <= n <= 2 * 10^4\n- 0 <= ratings[i] <= 2 * 10^4\n\nNow let's provide the solution:", "n_pass": 1, "difficulty": 3.0, "frontend_question_id": 135.0, "loc": 134}
{"task_input": "\nLeetCode Problem #137\nTitle: Single Number II\nDescription:\nGiven an integer array nums where every element appears three times except for one, which appears exactly once. Find the single element and return it. You must implement a solution with a linear runtime complexity and use only constant extra space. Example 1: Input: nums = [2, 2, 3, 2] Output: 3 Example 2: Input: nums = [0, 1, 0, 1, 0, 1, 99] Output: 99 Constraints: 1 <= nums.length <= 3 * 10e4 -2^31 <= nums[i] <= 2^31 - 1 Each element in nums appears exactly three times except for one element which appears once.\n", "code_prompt": "class Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        ", "raw_response": "```python\nfrom typing import List\n\nclass Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        # Count the number of 1s in each bit position and ignore the bits whose count is divisible by 3\n        result = 0\n        for i in range(32):\n            count = 0\n            for num in nums:\n                if num >> i & 1:\n                    count += 1\n            if count % 3 != 0:\n                result |= 1 << i\n        return result\n```", "cleaned_response": "\nfrom typing import List\n\nclass Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        # Count the number of 1s in each bit position and ignore the bits whose count is divisible by 3\n        result = 0\n        for i in range(32):\n            count = 0\n            for num in nums:\n                if num >> i & 1:\n                    count += 1\n            if count % 3 != 0:\n                result |= 1 << i\n        return result\n", "n_pass": 1, "difficulty": 2.0, "frontend_question_id": 137.0, "loc": 136}
{"task_input": "\nLeetCode Problem #139\nTitle: Word Break\nDescription:\nGiven a string s and a dictionary of strings wordDict, return true if s can be segmented into a space-separated sequence of one or more dictionary words. Note that the same word in the dictionary may be reused multiple times in the segmentation. Example 1: Input: s = \"leetcode\", wordDict = [\"leet\", \"code\"] Output: true Explanation: Return true because \"leetcode\" can be segmented as \"leet code\". Example 2: Input: s = \"applepenapple\", wordDict = [\"apple\", \"pen\"] Output: true Explanation: Return true because \"applepenapple\" can be segmented as \"apple pen apple\". Note that you are allowed to reuse a dictionary word. Example 3: Input: s = \"catsandog\", wordDict = [\"cats\", \"dog\", \"sand\", \"and\", \"cat\"] Output: false Constraints: 1 <= s.length <= 300^1 <= wordDict.length <= 1000^1 <= wordDict[i].length <= 20 s and wordDict[i] consist of only lowercase English letters. All the strings of wordDict are unique.\n", "code_prompt": "class Solution:\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\n        ", "raw_response": "```python\nfrom typing import List\n\nclass Solution:\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\n        # Create a set of the dictionary words for efficient lookup\n        wordSet = set(wordDict)\n        # Create a list to store whether each index in s can be segmented\n        dp = [False] * (len(s) + 1)\n        # Mark the first index as True since an empty string can always be segmented\n        dp[0] = True\n        \n        for i in range(1, len(s) + 1):\n            # Iterate through each index from 1 to len(s)\n            for j in range(i):\n                # Check if the segment from j to i is a dictionary word\n                if dp[j] and s[j:i] in wordSet:\n                    # If the previous segment can be segmented and the current segment is a dictionary word\n                    # mark the current index as True\n                    dp[i] = True\n                    # Break out of the loop since one possible segmentation is found\n                    break\n        \n        return dp[-1]\n```\nThe time complexity of this solution is O(n^3), where n is the length of the input string s.", "cleaned_response": "\nfrom typing import List\n\nclass Solution:\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\n        # Create a set of the dictionary words for efficient lookup\n        wordSet = set(wordDict)\n        # Create a list to store whether each index in s can be segmented\n        dp = [False] * (len(s) + 1)\n        # Mark the first index as True since an empty string can always be segmented\n        dp[0] = True\n        \n        for i in range(1, len(s) + 1):\n            # Iterate through each index from 1 to len(s)\n            for j in range(i):\n                # Check if the segment from j to i is a dictionary word\n                if dp[j] and s[j:i] in wordSet:\n                    # If the previous segment can be segmented and the current segment is a dictionary word\n                    # mark the current index as True\n                    dp[i] = True\n                    # Break out of the loop since one possible segmentation is found\n                    break\n        \n        return dp[-1]\n", "n_pass": 1, "difficulty": 2.0, "frontend_question_id": 139.0, "loc": 138}
{"task_input": "\nLeetCode Problem #140\nTitle: Word Break II\nDescription:\nGiven a string s and a dictionary of strings wordDict, add spaces in s to construct a sentence where each word is a valid dictionary word. Return all such possible sentences in any order. Note that the same word in the dictionary may be reused multiple times in the segmentation. Example 1: Input: s = \"catsanddog\", wordDict = [\"cat\", \"cats\", \"and\", \"sand\", \"dog\"] Output: [\"cats and dog\", \"cat sand dog\"] Example 2: Input: s = \"pineapplepenapple\", wordDict = [\"apple\", \"pen\", \"applepen\", \"pine\", \"pineapple\"] Output: [\"pine apple pen apple\", \"pineapple pen apple\", \"pine applepen apple\"] Explanation: Note that you are allowed to reuse a dictionary word. Example 3: Input: s = \"catsandog\", wordDict = [\"cats\", \"dog\", \"sand\", \"and\", \"cat\"] Output: [] Constraints: 1 <= s.length <= 20^1 <= wordDict.length <= 1000^1 <= wordDict[i].length <= 10 s and wordDict[i] consist of only lowercase English letters. All the strings of wordDict are unique. Input is generated in a way that the length of the answer doesn't exceed 10e5.\n", "code_prompt": "class Solution:\n    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\n        ", "raw_response": "```python\nfrom typing import List\n\nclass Solution:\n    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\n        memo = {}  # Memoization dictionary to store intermediate results\n        \n        def backtrack(start):\n            # If the start index has reached the end of the string, return an empty list\n            if start == len(s):\n                return []\n\n            # If the result for the current start index is already memoized, return it\n            if start in memo:\n                return memo[start]\n\n            # List to store the valid sentences for the current start index\n            sentences = []\n            \n            # Iterate through each word in the wordDict\n            for word in wordDict:\n                # Check if the current word matches the substring starting from the start index\n                if s.startswith(word, start):\n                    # If the end of the substring matches exactly with the end of the string,\n                    # add the current word as a sentence and append it to the sentences list\n                    if start + len(word) == len(s):\n                        sentences.append(word)\n                    else:\n                        # Recursively backtrack to find more valid sentences\n                        next_sentences = backtrack(start + len(word))\n                        \n                        # Append the current word to each of the next sentences and add them to the sentences list\n                        for next_sentence in next_sentences:\n                            sentences.append(word + \" \" + next_sentence)\n\n            # Memoize the result for the current start index\n            memo[start] = sentences\n            \n            return sentences\n        \n        return backtrack(0)\n```", "cleaned_response": "\nfrom typing import List\n\nclass Solution:\n    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\n        memo = {}  # Memoization dictionary to store intermediate results\n        \n        def backtrack(start):\n            # If the start index has reached the end of the string, return an empty list\n            if start == len(s):\n                return []\n\n            # If the result for the current start index is already memoized, return it\n            if start in memo:\n                return memo[start]\n\n            # List to store the valid sentences for the current start index\n            sentences = []\n            \n            # Iterate through each word in the wordDict\n            for word in wordDict:\n                # Check if the current word matches the substring starting from the start index\n                if s.startswith(word, start):\n                    # If the end of the substring matches exactly with the end of the string,\n                    # add the current word as a sentence and append it to the sentences list\n                    if start + len(word) == len(s):\n                        sentences.append(word)\n                    else:\n                        # Recursively backtrack to find more valid sentences\n                        next_sentences = backtrack(start + len(word))\n                        \n                        # Append the current word to each of the next sentences and add them to the sentences list\n                        for next_sentence in next_sentences:\n                            sentences.append(word + \" \" + next_sentence)\n\n            # Memoize the result for the current start index\n            memo[start] = sentences\n            \n            return sentences\n        \n        return backtrack(0)\n", "n_pass": 1, "difficulty": 3.0, "frontend_question_id": 140.0, "loc": 139}
{"task_input": "\nLeetCode Problem #142\nTitle: Linked List Cycle II\nDescription:\nGiven the head of a linked list, return the node where the cycle begins. If there is no cycle, return null. There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail's next pointer is connected to ( 0-indexed ). It is -1 if there is no cycle. Note that pos is not passed as a parameter. Do not modify the linked list. Example 1: Input: head = [3, 2, 0, -4], pos = 1 Output: tail connects to node index 1 Explanation: There is a cycle in the linked list, where tail connects to the second node. Example 2: Input: head = [1, 2], pos = 0 Output: tail connects to node index 0 Explanation: There is a cycle in the linked list, where tail connects to the first node. Example 3: Input: head = [1], pos = -1 Output: no cycle Explanation: There is no cycle in the linked list. Constraints: The number of the nodes in the list is in the range [0, 10e4 ]. -10e5 <= Node. val <= 10e5 pos is -1 or a valid index in the linked-list. Follow up: Can you solve it using O(1) (i. e. constant) memory?\n", "code_prompt": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        ", "raw_response": "```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        # Check if the linked list is empty or has only one node\n        if not head or not head.next:\n            return None\n        \n        # Step 1: Detect if there is a cycle using Floyd's cycle-finding algorithm\n        slow = head\n        fast = head\n        \n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n            \n            if slow == fast:\n                break\n        else:\n            return None\n        \n        # Step 2: Find the starting point of the cycle\n        slow = head\n        \n        while slow != fast:\n            slow = slow.next\n            fast = fast.next\n        \n        return slow\n```", "cleaned_response": "\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        # Check if the linked list is empty or has only one node\n        if not head or not head.next:\n            return None\n        \n        # Step 1: Detect if there is a cycle using Floyd's cycle-finding algorithm\n        slow = head\n        fast = head\n        \n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n            \n            if slow == fast:\n                break\n        else:\n            return None\n        \n        # Step 2: Find the starting point of the cycle\n        slow = head\n        \n        while slow != fast:\n            slow = slow.next\n            fast = fast.next\n        \n        return slow\n", "n_pass": 1, "difficulty": 2.0, "frontend_question_id": 142.0, "loc": 141}
{"task_input": "\nLeetCode Problem #143\nTitle: Reorder List\nDescription:\nYou are given the head of a singly linked-list. The list can be represented as:...\n L 0 \u2192 L 1 \u2192 \u2026 \u2192 L n - 1 \u2192 L n Reorder the list to be on the following form: L 0 \u2192 L n \u2192 L 1 \u2192 L n - 1 \u2192 L 2 \u2192 L n - 2 \u2192 \u2026 You may not modify the values in the list's nodes. Only nodes themselves may be changed. Example 1: Input: head = [1, 2, 3, 4] Output: [1, 4, 2, 3] Example 2: Input: head = [1, 2, 3, 4, 5] Output: [1, 5, 2, 4, 3] Constraints: The number of nodes in the list is in the range [1, 5 * 10e4 ]. 1 <= Node. val <= 1000\n", "code_prompt": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def reorderList(self, head: Optional[ListNode]) -> None:\n        \"\"\"\n        Do not return anything, modify head in-place instead.\n        \"\"\"\n        ", "raw_response": "```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n\nclass Solution:\n    def reorderList(self, head: Optional[ListNode]) -> None:\n        \"\"\"\n        Do not return anything, modify head in-place instead.\n        \"\"\"\n        # Base case: if the linked list is empty or only contains one node\n        if not head or not head.next:\n            return\n        \n        # Find the midpoint of the linked list using two pointers (slow and fast)\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # Reverse the second half of the linked list\n        prev = None\n        curr = slow.next\n        while curr:\n            next_node = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_node\n        slow.next = None  # Break the link between the first and second halves of the linked list\n        \n        # Merge the two halves of the linked list\n        first = head\n        second = prev\n        while second:\n            next_node = first.next\n            first.next = second\n            second = second.next\n            first.next.next = next_node\n            first = next_node\n```", "cleaned_response": "\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n\nclass Solution:\n    def reorderList(self, head: Optional[ListNode]) -> None:\n        \"\"\"\n        Do not return anything, modify head in-place instead.\n        \"\"\"\n        # Base case: if the linked list is empty or only contains one node\n        if not head or not head.next:\n            return\n        \n        # Find the midpoint of the linked list using two pointers (slow and fast)\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # Reverse the second half of the linked list\n        prev = None\n        curr = slow.next\n        while curr:\n            next_node = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_node\n        slow.next = None  # Break the link between the first and second halves of the linked list\n        \n        # Merge the two halves of the linked list\n        first = head\n        second = prev\n        while second:\n            next_node = first.next\n            first.next = second\n            second = second.next\n            first.next.next = next_node\n            first = next_node\n", "n_pass": 1, "difficulty": 2.0, "frontend_question_id": 143.0, "loc": 142}
{"task_input": "\nLeetCode Problem #145\nTitle: Binary Tree Postorder Traversal\nDescription:\nGiven the root of a binary tree, return the postorder traversal of its nodes' values. Example 1: Input: root = [1, null, 2, 3] Output: [3, 2, 1] Example 2: Input: root = [] Output: [] Example 3: Input: root = [1] Output: [1] Constraints: The number of the nodes in the tree is in the range [0, 100]. -100 <= Node. val <= 100 Follow up: Recursive solution is trivial, could you do it iteratively?\n", "code_prompt": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def postorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\n        ", "raw_response": "```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    def postorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\n        # Create an empty stack\n        stack = []\n        # Result array to store the postorder traversal\n        result = []\n        # Pointer to keep track of the previously visited node\n        prev = None\n        \n        # If the root is None, return an empty list\n        if not root:\n            return result\n        \n        # Add the root node to the stack\n        stack.append(root)\n        # Loop until the stack is empty\n        while stack:\n            # Peek the top of the stack\n            curr = stack[-1]\n            \n            # If the current node doesn't have any children or its children have already been visited\n            if (curr.left is None and curr.right is None) or (prev is not None and (prev is curr.left or prev is curr.right)):\n                # Pop the current node from the stack\n                stack.pop()\n                # Append the current node's value to the result array\n                result.append(curr.val)\n                # Update the previously visited node to be the current node\n                prev = curr\n            \n            # If the current node has a right child and the right child hasn't been visited yet, push it to the stack\n            elif curr.right is not None and prev is not curr.right:\n                stack.append(curr.right)\n            \n            # If the current node has a left child and the left child hasn't been visited yet, push it to the stack\n            elif curr.left is not None and prev is not curr.left:\n                stack.append(curr.left)\n            \n            # If the current node has no children or both of its children have already been visited, pop it from the stack\n            else:\n                stack.pop()\n                # Append the current node's value to the result array\n                result.append(curr.val)\n                # Update the previously visited node to be the current node\n                prev = curr\n        \n        # Return the postorder traversal result\n        return result\n```\nThe code implements an iterative solution to perform postorder traversal of a binary tree. It uses a stack to keep track of the nodes to be visited. The algorithm follows the below steps:\n- Initialize an empty stack, an empty result array, and a variable 'prev' to keep track of the previously visited node.\n- If the root is None, return an empty result array.\n- Push the root node to the stack.\n- Loop until the stack is empty:\n  - Peek the top of the stack.\n  - If the current node doesn't have any children or its children have already been visited, pop it from the stack, append its value to the result array, and update 'prev' to be the current node.\n  - If the current node has a right child and the right child hasn't been visited yet, push it to the stack.\n  - If the current node has a left child and the left child hasn't been visited yet, push it to the stack.\n  - If the current node has no children or both of its children have already been visited, pop it from the stack, append its value to the result array, and update 'prev' to be the current node.\n- Return the result array containing the postorder traversal of the binary tree.", "cleaned_response": "\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    def postorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\n        # Create an empty stack\n        stack = []\n        # Result array to store the postorder traversal\n        result = []\n        # Pointer to keep track of the previously visited node\n        prev = None\n        \n        # If the root is None, return an empty list\n        if not root:\n            return result\n        \n        # Add the root node to the stack\n        stack.append(root)\n        # Loop until the stack is empty\n        while stack:\n            # Peek the top of the stack\n            curr = stack[-1]\n            \n            # If the current node doesn't have any children or its children have already been visited\n            if (curr.left is None and curr.right is None) or (prev is not None and (prev is curr.left or prev is curr.right)):\n                # Pop the current node from the stack\n                stack.pop()\n                # Append the current node's value to the result array\n                result.append(curr.val)\n                # Update the previously visited node to be the current node\n                prev = curr\n            \n            # If the current node has a right child and the right child hasn't been visited yet, push it to the stack\n            elif curr.right is not None and prev is not curr.right:\n                stack.append(curr.right)\n            \n            # If the current node has a left child and the left child hasn't been visited yet, push it to the stack\n            elif curr.left is not None and prev is not curr.left:\n                stack.append(curr.left)\n            \n            # If the current node has no children or both of its children have already been visited, pop it from the stack\n            else:\n                stack.pop()\n                # Append the current node's value to the result array\n                result.append(curr.val)\n                # Update the previously visited node to be the current node\n                prev = curr\n        \n        # Return the postorder traversal result\n        return result\n", "n_pass": 1, "difficulty": 1.0, "frontend_question_id": 145.0, "loc": 144}
{"task_input": "\nLeetCode Problem #146\nTitle: LRU Cache\nDescription:\nDesign a data structure that follows the constraints of a Least Recently Used (LRU) cache. Implement the LRUCache class: LRUCache(int capacity) Initialize the LRU cache with positive size capacity. int get(int key) Return the value of the key if the key exists, otherwise return -1. void put(int key, int value) Update the value of the key if the key exists. Otherwise, add the key-value pair to the cache. If the number of keys exceeds the capacity from this operation, evict the least recently used key. The functions get and put must each run in O(1) average time complexity. Example 1: Input [\"LRUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"put\", \"get\", \"get\", \"get\"] [[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]] Output [null, null, null, 1, null, -1, null, -1, 3, 4] Explanation LRUCache lRUCache = new LRUCache(2); lRUCache. put(1, 1); // cache is {1=1} lRUCache. put(2, 2); // cache is {1=1, 2=2} lRUCache. get(1); // return 1 lRUCache. put(3, 3); // LRU key was 2, evicts key 2, cache is {1=1, 3=3} lRUCache. get(2); // returns -1 (not found) lRUCache. put(4, 4); // LRU key was 1, evicts key 1, cache is {4=4, 3=3} lRUCache. get(1); // return -1 (not found) lRUCache. get(3); // return 3 lRUCache. get(4); // return 4 Constraints: 1 <= capacity <= 3000^0 <= key <= 10e4 0 <= value <= 10e5 At most 2 * 10e5 calls will be made to get and put.\n", "code_prompt": "class LRUCache:\n\n    def __init__(self, capacity: int):\n        \n\n    def get(self, key: int) -> int:\n        \n\n    def put(self, key: int, value: int) -> None:\n        \n\n\n# Your LRUCache object will be instantiated and called as such:\n# obj = LRUCache(capacity)\n# param_1 = obj.get(key)\n# obj.put(key,value)", "raw_response": "```python\nclass ListNode:\n    def __init__(self, key=None, value=None):\n        self.key = key\n        self.value = value\n        self.prev = None\n        self.next = None\n\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.cache = {}\n        self.head = ListNode()\n        self.tail = ListNode()\n        self.head.next = self.tail\n        self.tail.prev = self.head\n\n    def get(self, key: int) -> int:\n        if key in self.cache:\n            node = self.cache[key]\n            self._remove_node_from_list(node)\n            self._add_node_to_head(node)\n            return node.value\n        return -1\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.cache:\n            node = self.cache[key]\n            node.value = value\n            self._remove_node_from_list(node)\n            self._add_node_to_head(node)\n        else:\n            node = ListNode(key, value)\n            self.cache[key] = node\n            self._add_node_to_head(node)\n            if len(self.cache) > self.capacity:\n                tail_node = self.tail.prev\n                self._remove_node_from_list(tail_node)\n                del self.cache[tail_node.key]\n\n    def _remove_node_from_list(self, node):\n        node.prev.next = node.next\n        node.next.prev = node.prev\n\n    def _add_node_to_head(self, node):\n        node.prev = self.head\n        node.next = self.head.next\n        self.head.next.prev = node\n        self.head.next = node\n\n\n# Your LRUCache object will be instantiated and called as such:\n# obj = LRUCache(capacity)\n# param_1 = obj.get(key)\n# obj.put(key,value)\n```", "cleaned_response": "\nclass ListNode:\n    def __init__(self, key=None, value=None):\n        self.key = key\n        self.value = value\n        self.prev = None\n        self.next = None\n\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.cache = {}\n        self.head = ListNode()\n        self.tail = ListNode()\n        self.head.next = self.tail\n        self.tail.prev = self.head\n\n    def get(self, key: int) -> int:\n        if key in self.cache:\n            node = self.cache[key]\n            self._remove_node_from_list(node)\n            self._add_node_to_head(node)\n            return node.value\n        return -1\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.cache:\n            node = self.cache[key]\n            node.value = value\n            self._remove_node_from_list(node)\n            self._add_node_to_head(node)\n        else:\n            node = ListNode(key, value)\n            self.cache[key] = node\n            self._add_node_to_head(node)\n            if len(self.cache) > self.capacity:\n                tail_node = self.tail.prev\n                self._remove_node_from_list(tail_node)\n                del self.cache[tail_node.key]\n\n    def _remove_node_from_list(self, node):\n        node.prev.next = node.next\n        node.next.prev = node.prev\n\n    def _add_node_to_head(self, node):\n        node.prev = self.head\n        node.next = self.head.next\n        self.head.next.prev = node\n        self.head.next = node\n\n\n# Your LRUCache object will be instantiated and called as such:\n# obj = LRUCache(capacity)\n# param_1 = obj.get(key)\n# obj.put(key,value)\n", "n_pass": 1, "difficulty": 2.0, "frontend_question_id": 146.0, "loc": 145}
{"task_input": "\nLeetCode Problem #149\nTitle: Max Points on a Line\nDescription:\nGiven an array of points where points[i] = [x i, y i ] represents a point on the X-Y plane, return the maximum number of points that lie on the same straight line. Example 1: Input: points = [[1, 1], [2, 2], [3, 3]] Output: 3 Example 2: Input: points = [[1, 1], [3, 2], [5, 3], [4, 1], [2, 3], [1, 4]] Output: 4 Constraints: 1 <= points.length <= 300 points[i].length == 2 -10e4 <= x i, y i <= 10e4 All the points are unique.\n", "code_prompt": "class Solution:\n    def maxPoints(self, points: List[List[int]]) -> int:\n        ", "raw_response": "```python\nfrom collections import defaultdict\nfrom typing import List\n\nclass Solution:\n    def maxPoints(self, points: List[List[int]]) -> int:\n        # Function to calculate the greatest common divisor\n        def gcd(a: int, b: int) -> int:\n            while b:\n                a, b = b, a % b\n            return a\n        \n        n = len(points)\n        if n <= 2:\n            return n\n        \n        max_points = 0\n        \n        for i in range(n):\n            slope_dict = defaultdict(int)\n            duplicate = 0\n            current_max = 0\n            \n            for j in range(i + 1, n):\n                dx = points[j][0] - points[i][0]\n                dy = points[j][1] - points[i][1]\n                \n                if dx == 0 and dy == 0:\n                    duplicate += 1\n                    continue\n                \n                # Calculate the greatest common divisor of dx and dy\n                d = gcd(dx, dy)\n                \n                # Simplify the slope by dividing dx and dy by their greatest common divisor\n                dx //= d\n                dy //= d\n                \n                # Update the slope dictionary\n                slope_dict[(dx, dy)] += 1\n                current_max = max(current_max, slope_dict[(dx, dy)])\n            \n            # Update the maximum number of points if necessary\n            max_points = max(max_points, current_max + duplicate + 1)\n        \n        return max_points\n```", "cleaned_response": "\nfrom collections import defaultdict\nfrom typing import List\n\nclass Solution:\n    def maxPoints(self, points: List[List[int]]) -> int:\n        # Function to calculate the greatest common divisor\n        def gcd(a: int, b: int) -> int:\n            while b:\n                a, b = b, a % b\n            return a\n        \n        n = len(points)\n        if n <= 2:\n            return n\n        \n        max_points = 0\n        \n        for i in range(n):\n            slope_dict = defaultdict(int)\n            duplicate = 0\n            current_max = 0\n            \n            for j in range(i + 1, n):\n                dx = points[j][0] - points[i][0]\n                dy = points[j][1] - points[i][1]\n                \n                if dx == 0 and dy == 0:\n                    duplicate += 1\n                    continue\n                \n                # Calculate the greatest common divisor of dx and dy\n                d = gcd(dx, dy)\n                \n                # Simplify the slope by dividing dx and dy by their greatest common divisor\n                dx //= d\n                dy //= d\n                \n                # Update the slope dictionary\n                slope_dict[(dx, dy)] += 1\n                current_max = max(current_max, slope_dict[(dx, dy)])\n            \n            # Update the maximum number of points if necessary\n            max_points = max(max_points, current_max + duplicate + 1)\n        \n        return max_points\n", "n_pass": 1, "difficulty": 3.0, "frontend_question_id": 149.0, "loc": 148}
{"task_input": "\nLeetCode Problem #150\nTitle: Evaluate Reverse Polish Notation\nDescription:\nYou are given an array of strings tokens that represents an arithmetic expression in a Reverse Polish Notation. Evaluate the expression. Return an integer that represents the value of the expression. Note that: The valid operators are '+', '-', '*', and '/'. Each operand may be an integer or another expression. The division between two integers always truncates toward zero. There will not be any division by zero. The input represents a valid arithmetic expression in a reverse polish notation. The answer and all the intermediate calculations can be represented in a 32-bit integer. Example 1: Input: tokens = [\"2\", \"1\", \"+\", \"3\", \"*\"] Output: 9 Explanation: ((2 + 1) * 3) = 9 Example 2: Input: tokens = [\"4\", \"13\", \"5\", \"/\", \"+\"] Output: 6 Explanation: (4 + (13 / 5)) = 6 Example 3: Input: tokens = [\"10\", \"6\", \"9\", \"3\", \"+\", \"-11\", \"*\", \"/\", \"*\", \"17\", \"+\", \"5\", \"+\"] Output: 22 Explanation: ((10 * (6 / ((9 + 3) * -11))) + 17) + 5 = ((10 * (6 / (12 * -11))) + 17) + 5 = ((10 * (6 / -132)) + 17) + 5 = ((10 * 0) + 17) + 5 = (0 + 17) + 5 = 17 + 5 = 22 Constraints: 1 <= tokens.length <= 10e4 tokens[i] is either an operator: \"+\", \"-\", \"*\", or \"/\", or an integer in the range [-200, 200].\n", "code_prompt": "class Solution:\n    def evalRPN(self, tokens: List[str]) -> int:\n        ", "raw_response": "```python\nclass Solution:\n    def evalRPN(self, tokens: List[str]) -> int:\n        stack = []\n        for token in tokens:\n            if token in ['+', '-', '*', '/']:\n                num2 = stack.pop()\n                num1 = stack.pop()\n                if token == '+':\n                    stack.append(num1 + num2)\n                elif token == '-':\n                    stack.append(num1 - num2)\n                elif token == '*':\n                    stack.append(num1 * num2)\n                else:\n                    stack.append(int(num1 / num2))\n            else:\n                stack.append(int(token))\n        return stack[0]\n```", "cleaned_response": "\nclass Solution:\n    def evalRPN(self, tokens: List[str]) -> int:\n        stack = []\n        for token in tokens:\n            if token in ['+', '-', '*', '/']:\n                num2 = stack.pop()\n                num1 = stack.pop()\n                if token == '+':\n                    stack.append(num1 + num2)\n                elif token == '-':\n                    stack.append(num1 - num2)\n                elif token == '*':\n                    stack.append(num1 * num2)\n                else:\n                    stack.append(int(num1 / num2))\n            else:\n                stack.append(int(token))\n        return stack[0]\n", "n_pass": 1, "difficulty": 2.0, "frontend_question_id": 150.0, "loc": 149}
{"task_input": "\nLeetCode Problem #153\nTitle: Find Minimum in Rotated Sorted Array\nDescription:\nSuppose an array of length n sorted in ascending order is rotated between 1 and n times. For example, the array nums = [0, 1, 2, 4, 5, 6, 7] might become:...\n [4, 5, 6, 7, 0, 1, 2] if it was rotated 4 times. [0, 1, 2, 4, 5, 6, 7] if it was rotated 7 times. Notice that rotating an array [a[0], a[1], a[2],. . . , a[n-1]] 1 time results in the array [a[n-1], a[0], a[1], a[2],. . . , a[n-2]]. Given the sorted rotated array nums of unique elements, return the minimum element of this array. You must write an algorithm that runs in O(log n) time. Example 1: Input: nums = [3, 4, 5, 1, 2] Output: 1 Explanation: The original array was [1, 2, 3, 4, 5] rotated 3 times. Example 2: Input: nums = [4, 5, 6, 7, 0, 1, 2] Output: 0 Explanation: The original array was [0, 1, 2, 4, 5, 6, 7] and it was rotated 4 times. Example 3: Input: nums = [11, 13, 15, 17] Output: 11 Explanation: The original array was [11, 13, 15, 17] and it was rotated 4 times. Constraints: n == nums.length 1 <= n <= 5000 -5000 <= nums[i] <= 5000 All the integers of nums are unique. nums is sorted and rotated between 1 and n times.\n", "code_prompt": "class Solution:\n    def findMin(self, nums: List[int]) -> int:\n        ", "raw_response": "```python\nfrom typing import List\n\nclass Solution:\n    def findMin(self, nums: List[int]) -> int:\n        left = 0\n        right = len(nums) - 1\n        \n        while left < right:\n            mid = left + (right - left) // 2\n            \n            if nums[mid] > nums[right]:\n                left = mid + 1\n            else:\n                right = mid\n        \n        return nums[left]\n```", "cleaned_response": "\nfrom typing import List\n\nclass Solution:\n    def findMin(self, nums: List[int]) -> int:\n        left = 0\n        right = len(nums) - 1\n        \n        while left < right:\n            mid = left + (right - left) // 2\n            \n            if nums[mid] > nums[right]:\n                left = mid + 1\n            else:\n                right = mid\n        \n        return nums[left]\n", "n_pass": 1, "difficulty": 2.0, "frontend_question_id": 153.0, "loc": 152}
{"task_input": "\nLeetCode Problem #154\nTitle: Find Minimum in Rotated Sorted Array II\nDescription:\nSuppose an array of length n sorted in ascending order is rotated between 1 and n times. For example, the array nums = [0, 1, 4, 4, 5, 6, 7] might become:...\n [4, 5, 6, 7, 0, 1, 4] if it was rotated 4 times. [0, 1, 4, 4, 5, 6, 7] if it was rotated 7 times. Notice that rotating an array [a[0], a[1], a[2],. . . , a[n-1]] 1 time results in the array [a[n-1], a[0], a[1], a[2],. . . , a[n-2]]. Given the sorted rotated array nums that may contain duplicates, return the minimum element of this array. You must decrease the overall operation steps as much as possible. Example 1: Input: nums = [1, 3, 5] Output: 1 Example 2: Input: nums = [2, 2, 2, 0, 1] Output: 0 Constraints: n == nums.length 1 <= n <= 5000 -5000 <= nums[i] <= 5000 nums is sorted and rotated between 1 and n times. Follow up: This problem is similar to Find Minimum in Rotated Sorted Array, but nums may contain duplicates. Would this affect the runtime complexity? How and why?\n", "code_prompt": "class Solution:\n    def findMin(self, nums: List[int]) -> int:\n        ", "raw_response": "```python\nfrom typing import List\n\nclass Solution:\n    def findMin(self, nums: List[int]) -> int:\n        left = 0\n        right = len(nums) - 1\n        \n        while left < right:\n            mid = left + (right - left) // 2\n            \n            # If the middle element is greater than the rightmost element, the minimum element is in the right half\n            if nums[mid] > nums[right]:\n                left = mid + 1\n            \n            # If the middle element is smaller than the rightmost element, the minimum element is in the left half\n            elif nums[mid] < nums[right]:\n                right = mid\n            \n            # If the middle element is equal to the rightmost element, we can't determine which half the minimum element is in\n            # We can safely ignore the rightmost element since it's a duplicate\n            else:\n                right -= 1\n        \n        return nums[left]\n```\nThe runtime complexity of this solution is O(logN) because we are using binary search to find the minimum element. The presence of duplicates does not affect the runtime complexity because we can safely ignore one of the duplicate elements in each iteration.", "cleaned_response": "\nfrom typing import List\n\nclass Solution:\n    def findMin(self, nums: List[int]) -> int:\n        left = 0\n        right = len(nums) - 1\n        \n        while left < right:\n            mid = left + (right - left) // 2\n            \n            # If the middle element is greater than the rightmost element, the minimum element is in the right half\n            if nums[mid] > nums[right]:\n                left = mid + 1\n            \n            # If the middle element is smaller than the rightmost element, the minimum element is in the left half\n            elif nums[mid] < nums[right]:\n                right = mid\n            \n            # If the middle element is equal to the rightmost element, we can't determine which half the minimum element is in\n            # We can safely ignore the rightmost element since it's a duplicate\n            else:\n                right -= 1\n        \n        return nums[left]\n", "n_pass": 1, "difficulty": 3.0, "frontend_question_id": 154.0, "loc": 153}
{"task_input": "\nLeetCode Problem #162\nTitle: Find Peak Element\nDescription:\nA peak element is an element that is strictly greater than its neighbors. Given a 0-indexed integer array nums, find a peak element, and return its index. If the array contains multiple peaks, return the index to any of the peaks. You may imagine that nums[-1] = nums[n] = -\u221e. In other words, an element is always considered to be strictly greater than a neighbor that is outside the array. You must write an algorithm that runs in O(log n) time. Example 1: Input: nums = [1, 2, 3, 1] Output: 2 Explanation: 3 is a peak element and your function should return the index number 2. Example 2: Input: nums = [1, 2, 1, 3, 5, 6, 4] Output: 5 Explanation: Your function can return either index number 1 where the peak element is 2, or index number 5 where the peak element is 6. Constraints: 1 <= nums.length <= 1000 -2^31 <= nums[i] <= 2^31 - 1 nums[i] != nums[i + 1] for all valid i.\n", "code_prompt": "class Solution:\n    def findPeakElement(self, nums: List[int]) -> int:\n        ", "raw_response": "```python\nfrom typing import List\n\nclass Solution:\n    def findPeakElement(self, nums: List[int]) -> int:\n        left = 0\n        right = len(nums) - 1\n        \n        while left < right:\n            mid = (left + right) // 2\n            \n            if nums[mid] > nums[mid + 1]:\n                right = mid\n            else:\n                left = mid + 1\n        \n        return left\n```\nThe solution uses the binary search algorithm to find a peak element in the given array `nums`. The algorithm initializes two pointers `left` and `right` to the start and end indices of the array, respectively. It then enters a while loop until `left` becomes greater than or equal to `right`. In each iteration, it calculates the middle index `mid` using the formula `(left + right) // 2`. If the element at `mid` is greater than the element at `mid + 1`, it means that a peak element exists on the left side of `mid`, so the `right` pointer is updated to `mid`. Otherwise, a peak element exists on the right side of `mid`, so the `left` pointer is updated to `mid + 1`. After the while loop, the algorithm returns the `left` pointer as the index of a peak element. This solution runs in O(log n) time complexity as it halves the search space in each iteration.", "cleaned_response": "\nfrom typing import List\n\nclass Solution:\n    def findPeakElement(self, nums: List[int]) -> int:\n        left = 0\n        right = len(nums) - 1\n        \n        while left < right:\n            mid = (left + right) // 2\n            \n            if nums[mid] > nums[mid + 1]:\n                right = mid\n            else:\n                left = mid + 1\n        \n        return left\n", "n_pass": 1, "difficulty": 2.0, "frontend_question_id": 162.0, "loc": 156}
{"task_input": "\nLeetCode Problem #164\nTitle: Maximum Gap\nDescription:\nGiven an integer array nums, return the maximum difference between two successive elements in its sorted form. If the array contains less than two elements, return 0. You must write an algorithm that runs in linear time and uses linear extra space. Example 1: Input: nums = [3, 6, 9, 1] Output: 3 Explanation: The sorted form of the array is [1, 3, 6, 9], either (3, 6) or (6, 9) has the maximum difference 3. Example 2: Input: nums = [10] Output: 0 Explanation: The array contains less than 2 elements, therefore return 0. Constraints: 1 <= nums.length <= 10e5 0 <= nums[i] <= 10e9\n", "code_prompt": "class Solution:\n    def maximumGap(self, nums: List[int]) -> int:\n        ", "raw_response": "```python\nclass Solution:\n    def maximumGap(self, nums: List[int]) -> int:\n        if len(nums) < 2:\n            return 0\n        \n        # Sort the array\n        nums.sort()\n        \n        max_gap = 0\n        for i in range(1, len(nums)):\n            # Calculate the difference between current and previous element\n            gap = nums[i] - nums[i-1]\n            max_gap = max(max_gap, gap)\n        \n        return max_gap\n```\n\nThe code first checks if the length of the input array is less than 2, in which case it returns 0 as there can be no maximum gap between less than 2 elements. \n\nThen, it sorts the array using the built-in `sort()` method.\n\nAfter that, it iterates through the sorted array, starting from index 1, and calculates the difference between each element and its previous element. \n\nThe maximum gap is updated whenever a larger gap is found.\n\nFinally, the maximum gap is returned as the result.", "cleaned_response": "\nclass Solution:\n    def maximumGap(self, nums: List[int]) -> int:\n        if len(nums) < 2:\n            return 0\n        \n        # Sort the array\n        nums.sort()\n        \n        max_gap = 0\n        for i in range(1, len(nums)):\n            # Calculate the difference between current and previous element\n            gap = nums[i] - nums[i-1]\n            max_gap = max(max_gap, gap)\n        \n        return max_gap\n", "n_pass": 1, "difficulty": 3.0, "frontend_question_id": 164.0, "loc": 157}
{"task_input": "\nLeetCode Problem #165\nTitle: Compare Version Numbers\nDescription:\nGiven two version numbers, version1 and version2, compare them. Version numbers consist of one or more revisions joined by a dot .. Each revision consists of digits and may contain leading zeros. Every revision contains at least one character. Revisions are 0-indexed from left to right, with the leftmost revision being revision 0, the next revision being revision 1, and so on. For example 2. 5. 33 and 0. 1 are valid version numbers. To compare version numbers, compare their revisions in left-to-right order. Revisions are compared using their integer value ignoring any leading zeros. This means that revisions 1 and 001 are considered equal. If a version number does not specify a revision at an index, then treat the revision as 0. For example, version 1. 0 is less than version 1. 1 because their revision 0s are the same, but their revision 1s are 0 and 1 respectively, and 0 < 1. Return the following: If version1 < version2, return -1. If version1 > version2, return 1. Otherwise, return 0. Example 1: Input: version1 = \"1. 01\", version2 = \"1. 001\" Output: 0 Explanation: Ignoring leading zeroes, both \"01\" and \"001\" represent the same integer \"1\". Example 2: Input: version1 = \"1. 0\", version2 = \"1. 0. 0\" Output: 0 Explanation: version1 does not specify revision 2, which means it is treated as \"0\". Example 3: Input: version1 = \"0. 1\", version2 = \"1. 1\" Output: -1 Explanation: version1's revision 0 is \"0\", while version2's revision 0 is \"1\". 0 < 1, so version1 < version2. Constraints: 1 <= version1.length, version2.length <= 500 version1 and version2 only contain digits and .. version1 and version2 are valid version numbers. All the given revisions in version1 and version2 can be stored in a 32-bit integer.\n", "code_prompt": "class Solution:\n    def compareVersion(self, version1: str, version2: str) -> int:\n        ", "raw_response": "class Solution:\n    def compareVersion(self, version1: str, version2: str) -> int:\n        # Split the version numbers into a list of revisions\n        revs1 = version1.split('.')\n        revs2 = version2.split('.')\n        \n        # Compare the revisions in left-to-right order\n        for i in range(max(len(revs1), len(revs2))):\n            # If a revision is missing, treat it as 0\n            if i >= len(revs1):\n                num1 = 0\n            else:\n                num1 = int(revs1[i])\n            if i >= len(revs2):\n                num2 = 0\n            else:\n                num2 = int(revs2[i])\n            \n            # Compare the revisions\n            if num1 < num2:\n                return -1\n            elif num1 > num2:\n                return 1\n        \n        # If all revisions are equal, return 0\n        return 0", "cleaned_response": "class Solution:\n    def compareVersion(self, version1: str, version2: str) -> int:\n        # Split the version numbers into a list of revisions\n        revs1 = version1.split('.')\n        revs2 = version2.split('.')\n        \n        # Compare the revisions in left-to-right order\n        for i in range(max(len(revs1), len(revs2))):\n            # If a revision is missing, treat it as 0\n            if i >= len(revs1):\n                num1 = 0\n            else:\n                num1 = int(revs1[i])\n            if i >= len(revs2):\n                num2 = 0\n            else:\n                num2 = int(revs2[i])\n            \n            # Compare the revisions\n            if num1 < num2:\n                return -1\n            elif num1 > num2:\n                return 1\n        \n        # If all revisions are equal, return 0\n        return 0", "n_pass": 1, "difficulty": 2.0, "frontend_question_id": 165.0, "loc": 158}
{"task_input": "\nLeetCode Problem #166\nTitle: Fraction to Recurring Decimal\nDescription:\nGiven two integers representing the numerator and denominator of a fraction, return the fraction in string format. If the fractional part is repeating, enclose the repeating part in parentheses. If multiple answers are possible, return any of them. It is guaranteed that the length of the answer string is less than 10e4 for all the given inputs. Example 1: Input: numerator = 1, denominator = 2 Output: \"0. 5\" Example 2: Input: numerator = 2, denominator = 1 Output: \"2\" Example 3: Input: numerator = 4, denominator = 333 Output: \"0. (012)\" Constraints: -2^31 <= numerator, denominator <= 2^31 - 1 denominator != 0\n", "code_prompt": "class Solution:\n    def fractionToDecimal(self, numerator: int, denominator: int) -> str:\n        ", "raw_response": "```python\nclass Solution:\n    def fractionToDecimal(self, numerator: int, denominator: int) -> str:\n        # Handle case when numerator is 0\n        if numerator == 0:\n            return \"0\"\n\n        res = \"\"\n        \n        # If only one of numerator or denominator is negative\n        if (numerator < 0) ^ (denominator < 0):\n            res += \"-\"\n\n        # Convert numerator and denominator to positive\n        numerator = abs(numerator)\n        denominator = abs(denominator)\n\n        # Integer part of the result\n        res += str(numerator // denominator)\n\n        # Check if there is a fractional part\n        if numerator % denominator != 0:\n            res += \".\"\n\n        # Map to store remainders and their positions\n        remainders = {}\n        index = len(res)\n\n        while numerator % denominator != 0:\n            # If the current remainder is already in the map, it means we have a repeating fractional part\n            if numerator % denominator in remainders:\n                # Insert \"(\" at the position where the repeating part starts\n                res = res[:remainders[numerator % denominator]] + \"(\" + res[remainders[numerator % denominator]:] + \")\"\n                break\n            else:\n                # Add current remainder and its position to the map\n                remainders[numerator % denominator] = index\n\n            numerator = numerator % denominator * 10\n            res += str(numerator // denominator)\n            index += 1\n\n        return res\n```\n\nThe function `fractionToDecimal` takes two integers `numerator` and `denominator` as input and returns the fraction in string format. It handles both positive and negative fractions. It first checks if the numerator is 0 and returns \"0\" in that case. It then handles the sign of the fraction and converts both the numerator and denominator to positive. It then calculates the integer part of the result by dividing the numerator by the denominator using integer division. If there is a fractional part (numerator % denominator != 0), it appends a \".\" to the result. \n\nThe function then enters a while loop where it checks if the current remainder (numerator % denominator) is already in the `remainders` map. If it is, it means there is a repeating fractional part and it inserts \"(\" at the position where the repeating part starts. If the current remainder is not in the map, it adds the remainder and its position to the map. It then updates the numerator by taking the remainder and multiplying by 10, and appends the new digit (numerator // denominator) to the result. It also increments the index.\n\nOnce the while loop ends (when numerator % denominator becomes 0), the function returns the final result.", "cleaned_response": "\nclass Solution:\n    def fractionToDecimal(self, numerator: int, denominator: int) -> str:\n        # Handle case when numerator is 0\n        if numerator == 0:\n            return \"0\"\n\n        res = \"\"\n        \n        # If only one of numerator or denominator is negative\n        if (numerator < 0) ^ (denominator < 0):\n            res += \"-\"\n\n        # Convert numerator and denominator to positive\n        numerator = abs(numerator)\n        denominator = abs(denominator)\n\n        # Integer part of the result\n        res += str(numerator // denominator)\n\n        # Check if there is a fractional part\n        if numerator % denominator != 0:\n            res += \".\"\n\n        # Map to store remainders and their positions\n        remainders = {}\n        index = len(res)\n\n        while numerator % denominator != 0:\n            # If the current remainder is already in the map, it means we have a repeating fractional part\n            if numerator % denominator in remainders:\n                # Insert \"(\" at the position where the repeating part starts\n                res = res[:remainders[numerator % denominator]] + \"(\" + res[remainders[numerator % denominator]:] + \")\"\n                break\n            else:\n                # Add current remainder and its position to the map\n                remainders[numerator % denominator] = index\n\n            numerator = numerator % denominator * 10\n            res += str(numerator // denominator)\n            index += 1\n\n        return res\n", "n_pass": 1, "difficulty": 2.0, "frontend_question_id": 166.0, "loc": 159}
{"task_input": "\nLeetCode Problem #167\nTitle: Two Sum II - Input Array Is Sorted\nDescription:\nGiven a 1-indexed array of integers numbers that is already sorted in non-decreasing order, find two numbers such that they add up to a specific target number. Let these two numbers be numbers[index 1 ] and numbers[index 2 ] where 1 <= index 1 < index 2 < numbers.length. Return the indices of the two numbers, index 1 and index 2, added by one as an integer array [index 1, index 2 ] of length 2. The tests are generated such that there is exactly one solution. You may not use the same element twice. Your solution must use only constant extra space. Example 1: Input: numbers = [ 2, 7, 11, 15], target = 9 Output: [1, 2] Explanation: The sum of 2 and 7 is 9. Therefore, index 1 = 1, index 2 = 2. We return [1, 2]. Example 2: Input: numbers = [ 2, 3, 4 ], target = 6 Output: [1, 3] Explanation: The sum of 2 and 4 is 6. Therefore index 1 = 1, index 2 = 3. We return [1, 3]. Example 3: Input: numbers = [ -1, 0 ], target = -1 Output: [1, 2] Explanation: The sum of -1 and 0 is -1. Therefore index 1 = 1, index 2 = 2. We return [1, 2]. Constraints: 2 <= numbers.length <= 3 * 10e4 -1000 <= numbers[i] <= 1000 numbers is sorted in non-decreasing order. -1000 <= target <= 1000 The tests are generated such that there is exactly one solution.\n", "code_prompt": "class Solution:\n    def twoSum(self, numbers: List[int], target: int) -> List[int]:\n        ", "raw_response": "```python\nclass Solution:\n    def twoSum(self, numbers: List[int], target: int) -> List[int]:\n        left = 0\n        right = len(numbers) - 1\n        \n        while left < right:\n            current_sum = numbers[left] + numbers[right]\n            \n            if current_sum == target:\n                return [left + 1, right + 1]\n            elif current_sum < target:\n                left += 1\n            else:\n                right -= 1\n        \n        return []  # No solution found\n```\n\nThis solution uses the two-pointer technique to find the two numbers that add up to the target. We start with a left pointer at the beginning of the array and a right pointer at the end of the array. We iterate until the left pointer is less than the right pointer. At each iteration, we calculate the current sum of the numbers at the left and right pointers. If the current sum is equal to the target, we return the indices of the two numbers. If the current sum is less than the target, we move the left pointer to the right to increase the sum. If the current sum is greater than the target, we move the right pointer to the left to decrease the sum. If we reach the end of the iteration without finding a solution, we return an empty list.", "cleaned_response": "\nclass Solution:\n    def twoSum(self, numbers: List[int], target: int) -> List[int]:\n        left = 0\n        right = len(numbers) - 1\n        \n        while left < right:\n            current_sum = numbers[left] + numbers[right]\n            \n            if current_sum == target:\n                return [left + 1, right + 1]\n            elif current_sum < target:\n                left += 1\n            else:\n                right -= 1\n        \n        return []  # No solution found\n", "n_pass": 1, "difficulty": 2.0, "frontend_question_id": 167.0, "loc": 160}
{"task_input": "\nLeetCode Problem #172\nTitle: Factorial Trailing Zeroes\nDescription:\nGiven an integer n, return the number of trailing zeroes in n!. Note that n! = n * (n - 1) * (n - 2) *. . . * 3 * 2 * 1. Example 1: Input: n = 3 Output: 0 Explanation: 3! = 6, no trailing zero. Example 2: Input: n = 5 Output: 1 Explanation: 5! = 120, one trailing zero. Example 3: Input: n = 0 Output: 0 Constraints: 0 <= n <= 10e4 Follow up: Could you write a solution that works in logarithmic time complexity?\n", "code_prompt": "class Solution:\n    def trailingZeroes(self, n: int) -> int:\n        ", "raw_response": "```python\nclass Solution:\n    def trailingZeroes(self, n: int) -> int:\n        count = 0\n        while n > 0:\n            n = n // 5\n            count += n\n        return count\n```", "cleaned_response": "\nclass Solution:\n    def trailingZeroes(self, n: int) -> int:\n        count = 0\n        while n > 0:\n            n = n // 5\n            count += n\n        return count\n", "n_pass": 1, "difficulty": 2.0, "frontend_question_id": 172.0, "loc": 164}
{"task_input": "\nLeetCode Problem #173\nTitle: Binary Search Tree Iterator\nDescription:\nImplement the BSTIterator class that represents an iterator over the in-order traversal of a binary search tree (BST):...\n BSTIterator(TreeNode root) Initializes an object of the BSTIterator class. The root of the BST is given as part of the constructor. The pointer should be initialized to a non-existent number smaller than any element in the BST. boolean hasNext() Returns true if there exists a number in the traversal to the right of the pointer, otherwise returns false. int next() Moves the pointer to the right, then returns the number at the pointer. Notice that by initializing the pointer to a non-existent smallest number, the first call to next() will return the smallest element in the BST. You may assume that next() calls will always be valid. That is, there will be at least a next number in the in-order traversal when next() is called. Example 1: Input [\"BSTIterator\", \"next\", \"next\", \"hasNext\", \"next\", \"hasNext\", \"next\", \"hasNext\", \"next\", \"hasNext\"] [[[7, 3, 15, null, null, 9, 20]], [], [], [], [], [], [], [], [], []] Output [null, 3, 7, true, 9, true, 15, true, 20, false] Explanation BSTIterator bSTIterator = new BSTIterator([7, 3, 15, null, null, 9, 20]); bSTIterator. next(); // return 3 bSTIterator. next(); // return 7 bSTIterator. hasNext(); // return True bSTIterator. next(); // return 9 bSTIterator. hasNext(); // return True bSTIterator. next(); // return 15 bSTIterator. hasNext(); // return True bSTIterator. next(); // return 20 bSTIterator. hasNext(); // return False Constraints: The number of nodes in the tree is in the range [1, 10e5 ]. 0 <= Node. val <= 10e6 At most 10e5 calls will be made to hasNext, and next. Follow up: Could you implement next() and hasNext() to run in average O(1) time and use O(h) memory, where h is the height of the tree?\n", "code_prompt": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass BSTIterator:\n\n    def __init__(self, root: Optional[TreeNode]):\n        \n\n    def next(self) -> int:\n        \n\n    def hasNext(self) -> bool:\n        \n\n\n# Your BSTIterator object will be instantiated and called as such:\n# obj = BSTIterator(root)\n# param_1 = obj.next()\n# param_2 = obj.hasNext()", "raw_response": "```python\nfrom typing import Optional\n\n# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass BSTIterator:\n\n    def __init__(self, root: Optional[TreeNode]):\n        self.stack = []\n        self._inorder_left(root)\n        \n    def _inorder_left(self, node):\n        while node:\n            self.stack.append(node)\n            node = node.left\n\n    def next(self) -> int:\n        if self.hasNext():\n            node = self.stack.pop()\n            if node.right:\n                self._inorder_left(node.right)\n            return node.val\n\n    def hasNext(self) -> bool:\n        return len(self.stack) > 0\n\n\n# Your BSTIterator object will be instantiated and called as such:\n# obj = BSTIterator(root)\n# param_1 = obj.next()\n# param_2 = obj.hasNext()\n```", "cleaned_response": "\nfrom typing import Optional\n\n# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass BSTIterator:\n\n    def __init__(self, root: Optional[TreeNode]):\n        self.stack = []\n        self._inorder_left(root)\n        \n    def _inorder_left(self, node):\n        while node:\n            self.stack.append(node)\n            node = node.left\n\n    def next(self) -> int:\n        if self.hasNext():\n            node = self.stack.pop()\n            if node.right:\n                self._inorder_left(node.right)\n            return node.val\n\n    def hasNext(self) -> bool:\n        return len(self.stack) > 0\n\n\n# Your BSTIterator object will be instantiated and called as such:\n# obj = BSTIterator(root)\n# param_1 = obj.next()\n# param_2 = obj.hasNext()\n", "n_pass": 1, "difficulty": 2.0, "frontend_question_id": 173.0, "loc": 165}
{"task_input": "\nLeetCode Problem #174\nTitle: Dungeon Game\nDescription:\nThe demons had captured the princess and imprisoned her in the bottom-right corner of a dungeon. The dungeon consists of m x n rooms laid out in a 2D grid. Our valiant knight was initially positioned in the top-left room and must fight his way through dungeon to rescue the princess. The knight has an initial health point represented by a positive integer. If at any point his health point drops to 0 or below, he dies immediately. Some of the rooms are guarded by demons (represented by negative integers), so the knight loses health upon entering these rooms; other rooms are either empty (represented as 0) or contain magic orbs that increase the knight's health (represented by positive integers). To reach the princess as quickly as possible, the knight decides to move only rightward or downward in each step. Return the knight's minimum initial health so that he can rescue the princess. Note that any room can contain threats or power-ups, even the first room the knight enters and the bottom-right room where the princess is imprisoned. Example 1: Input: dungeon = [[-2, -3, 3], [-5, -10, 1], [10, 30, -5]] Output: 7 Explanation: The initial health of the knight must be at least 7 if he follows the optimal path: RIGHT-> RIGHT -> DOWN -> DOWN. Example 2: Input: dungeon = [[0]] Output: 1 Constraints: m == dungeon.length n == dungeon[i].length 1 <= m, n <= 200 -1000 <= dungeon[i][j] <= 1000\n", "code_prompt": "class Solution:\n    def calculateMinimumHP(self, dungeon: List[List[int]]) -> int:\n        ", "raw_response": "```python\nfrom typing import List\n\nclass Solution:\n    def calculateMinimumHP(self, dungeon: List[List[int]]) -> int:\n        rows = len(dungeon)\n        cols = len(dungeon[0])\n        \n        # Create a dp array to store the minimum health points needed to reach the princess\n        dp = [[float('inf')] * (cols + 1) for _ in range(rows + 1)]\n        \n        # Set the bottom-right cell value to 1, since we need at least 1 health point to survive\n        dp[rows][cols-1] = 1\n        dp[rows-1][cols] = 1\n        \n        # Iterate backwards from the bottom-right cell to the top-left cell\n        for row in range(rows-1, -1, -1):\n            for col in range(cols-1, -1, -1):\n                # Calculate the minimum health points needed to reach the princess from the current cell\n                # by taking the minimum value between the right cell and the bottom cell and subtracting the cell value\n                min_hp = min(dp[row][col+1], dp[row+1][col]) - dungeon[row][col]\n                \n                # If the minimum health points is less than or equal to 0, set it to 1 (to survive)\n                if min_hp <= 0:\n                    min_hp = 1\n                \n                # Update the dp array with the minimum health points\n                dp[row][col] = min_hp\n        \n        # Return the minimum health points needed to reach the princess from the top-left cell\n        return dp[0][0]\n```", "cleaned_response": "\nfrom typing import List\n\nclass Solution:\n    def calculateMinimumHP(self, dungeon: List[List[int]]) -> int:\n        rows = len(dungeon)\n        cols = len(dungeon[0])\n        \n        # Create a dp array to store the minimum health points needed to reach the princess\n        dp = [[float('inf')] * (cols + 1) for _ in range(rows + 1)]\n        \n        # Set the bottom-right cell value to 1, since we need at least 1 health point to survive\n        dp[rows][cols-1] = 1\n        dp[rows-1][cols] = 1\n        \n        # Iterate backwards from the bottom-right cell to the top-left cell\n        for row in range(rows-1, -1, -1):\n            for col in range(cols-1, -1, -1):\n                # Calculate the minimum health points needed to reach the princess from the current cell\n                # by taking the minimum value between the right cell and the bottom cell and subtracting the cell value\n                min_hp = min(dp[row][col+1], dp[row+1][col]) - dungeon[row][col]\n                \n                # If the minimum health points is less than or equal to 0, set it to 1 (to survive)\n                if min_hp <= 0:\n                    min_hp = 1\n                \n                # Update the dp array with the minimum health points\n                dp[row][col] = min_hp\n        \n        # Return the minimum health points needed to reach the princess from the top-left cell\n        return dp[0][0]\n", "n_pass": 1, "difficulty": 3.0, "frontend_question_id": 174.0, "loc": 166}
{"task_input": "\nLeetCode Problem #179\nTitle: Largest Number\nDescription:\nGiven a list of non-negative integers nums, arrange them such that they form the largest number and return it. Since the result may be very large, so you need to return a string instead of an integer. Example 1: Input: nums = [10, 2] Output: \"210\" Example 2: Input: nums = [3, 30, 34, 5, 9] Output: \"9534330\" Constraints: 1 <= nums.length <= 100^0 <= nums[i] <= 10e9\n", "code_prompt": "class Solution:\n    def largestNumber(self, nums: List[int]) -> str:\n        ", "raw_response": "```python\nfrom typing import List\n\nclass Solution:\n    def largestNumber(self, nums: List[int]) -> str:\n        nums = [str(num) for num in nums]  # Convert each number to string\n        nums.sort(key=lambda x: x*9, reverse=True)  # Sort the numbers based on their concatenated form\n        \n        # Join the sorted numbers into a single string\n        largest_num = ''.join(nums)\n        \n        # Remove leading zeros\n        largest_num = largest_num.lstrip('0')\n        \n        # Return the largest number as string\n        return largest_num if largest_num else \"0\"\n```", "cleaned_response": "\nfrom typing import List\n\nclass Solution:\n    def largestNumber(self, nums: List[int]) -> str:\n        nums = [str(num) for num in nums]  # Convert each number to string\n        nums.sort(key=lambda x: x*9, reverse=True)  # Sort the numbers based on their concatenated form\n        \n        # Join the sorted numbers into a single string\n        largest_num = ''.join(nums)\n        \n        # Remove leading zeros\n        largest_num = largest_num.lstrip('0')\n        \n        # Return the largest number as string\n        return largest_num if largest_num else \"0\"\n", "n_pass": 1, "difficulty": 2.0, "frontend_question_id": 179.0, "loc": 167}
{"task_input": "\nLeetCode Problem #188\nTitle: Best Time to Buy and Sell Stock IV\nDescription:\nYou are given an integer array prices where prices[i] is the price of a given stock on the i th day, and an integer k. Find the maximum profit you can achieve. You may complete at most k transactions: i. e. you may buy at most k times and sell at most k times. Note: You may not engage in multiple transactions simultaneously (i. e. , you must sell the stock before you buy again). Example 1: Input: k = 2, prices = [2, 4, 1] Output: 2 Explanation: Buy on day 1 (price = 2) and sell on day 2 (price = 4), profit = 4-2 = 2. Example 2: Input: k = 2, prices = [3, 2, 6, 5, 0, 3] Output: 7 Explanation: Buy on day 2 (price = 2) and sell on day 3 (price = 6), profit = 6-2 = 4. Then buy on day 5 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3. Constraints: 1 <= k <= 100^1 <= prices.length <= 1000^0 <= prices[i] <= 1000\n", "code_prompt": "class Solution:\n    def maxProfit(self, k: int, prices: List[int]) -> int:\n        ", "raw_response": "```python\nfrom typing import List\n\nclass Solution:\n    def maxProfit(self, k: int, prices: List[int]) -> int:\n        n = len(prices)\n        \n        # If k is larger than half the length of prices, that means we can do as many transactions as we want\n        # So we can solve this problem using the greedy approach which is to buy at every local minimum and sell at every local maximum\n        if k > n // 2:\n            max_profit = 0\n            for i in range(1, n):\n                if prices[i] > prices[i-1]:\n                    max_profit += prices[i] - prices[i-1]\n            return max_profit\n        \n        # Otherwise, we use dynamic programming to solve the problem\n        # Create a 2D DP table with k+1 rows and n columns\n        dp = [[0] * n for _ in range(k+1)]\n        \n        # Fill in the dp table iteratively\n        for i in range(1, k+1):\n            max_diff = -prices[0]  # the maximum difference between selling price and buying price\n            \n            for j in range(1, n):\n                dp[i][j] = max(dp[i][j-1], prices[j] + max_diff)  # maximum profit at day j with at most i transactions\n                \n                max_diff = max(max_diff, dp[i-1][j] - prices[j])  # update the maximum difference\n                \n        return dp[k][n-1]\n```\n\nThis implementation uses dynamic programming to solve the problem. It starts by checking if the value of k is greater than half the length of the prices array. If it is, we can use a greedy approach and solve the problem in O(n) time complexity.\n\nOtherwise, we create a 2D DP table with k+1 rows and n columns. We fill in the table iteratively by keeping track of the maximum difference between selling price and buying price. At each day j, the maximum profit with at most i transactions is the maximum of either not making a transaction on that day (dp[i][j-1]) or selling the stock on that day (prices[j]) and buying it on a previous day (dp[i-1][j] - prices[j]).\n\nThe final result is the maximum profit with k transactions at the last day (dp[k][n-1]).", "cleaned_response": "\nfrom typing import List\n\nclass Solution:\n    def maxProfit(self, k: int, prices: List[int]) -> int:\n        n = len(prices)\n        \n        # If k is larger than half the length of prices, that means we can do as many transactions as we want\n        # So we can solve this problem using the greedy approach which is to buy at every local minimum and sell at every local maximum\n        if k > n // 2:\n            max_profit = 0\n            for i in range(1, n):\n                if prices[i] > prices[i-1]:\n                    max_profit += prices[i] - prices[i-1]\n            return max_profit\n        \n        # Otherwise, we use dynamic programming to solve the problem\n        # Create a 2D DP table with k+1 rows and n columns\n        dp = [[0] * n for _ in range(k+1)]\n        \n        # Fill in the dp table iteratively\n        for i in range(1, k+1):\n            max_diff = -prices[0]  # the maximum difference between selling price and buying price\n            \n            for j in range(1, n):\n                dp[i][j] = max(dp[i][j-1], prices[j] + max_diff)  # maximum profit at day j with at most i transactions\n                \n                max_diff = max(max_diff, dp[i-1][j] - prices[j])  # update the maximum difference\n                \n        return dp[k][n-1]\n", "n_pass": 1, "difficulty": 3.0, "frontend_question_id": 188.0, "loc": 169}
{"task_input": "\nLeetCode Problem #191\nTitle: Number of 1 Bits\nDescription:\nWrite a function that takes the binary representation of an unsigned integer and returns the number of '1' bits it has (also known as the Hamming weight ). Note: Note that in some languages, such as Java, there is no unsigned integer type. In this case, the input will be given as a signed integer type. It should not affect your implementation, as the integer's internal binary representation is the same, whether it is signed or unsigned. In Java, the compiler represents the signed integers using 2's complement notation. Therefore, in Example 3, the input represents the signed integer. -3. Example 1: Input: n = 00000000000000000000000000001011 Output: 3 Explanation: The input binary string 00000000000000000000000000001011 has a total of three '1' bits. Example 2: Input: n = 00000000000000000000000010000000 Output: 1 Explanation: The input binary string 00000000000000000000000010000000 has a total of one '1' bit. Example 3: Input: n = 11111111111111111111111111111101 Output: 31 Explanation: The input binary string 11111111111111111111111111111101 has a total of thirty one '1' bits. Constraints: The input must be a binary string of length 32. Follow up: If this function is called many times, how would you optimize it?\n", "code_prompt": "class Solution:\n    def hammingWeight(self, n: int) -> int:\n        ", "raw_response": "```python\nclass Solution:\n    def hammingWeight(self, n: int) -> int:\n        count = 0\n        while n != 0:\n            count += n & 1\n            n = n >> 1\n        return count\n```\nTo count the number of '1' bits in the binary representation of the input `n`, we initialize a variable `count` to 0. We then iterate over each bit of `n` by performing a bitwise AND operation with `n` and 1 (which gives 1 if the last bit of `n` is 1, and 0 otherwise). If the result of the AND operation is 1, we increment `count` by 1. We then right shift `n` by 1 to move to the next bit. We repeat this process until `n` becomes 0. Finally, we return the value of `count`, which represents the number of '1' bits in the binary representation of `n`.", "cleaned_response": "\nclass Solution:\n    def hammingWeight(self, n: int) -> int:\n        count = 0\n        while n != 0:\n            count += n & 1\n            n = n >> 1\n        return count\n", "n_pass": 1, "difficulty": 1.0, "frontend_question_id": 191.0, "loc": 172}
{"task_input": "\nLeetCode Problem #198\nTitle: House Robber\nDescription:\nYou are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and it will automatically contact the police if two adjacent houses were broken into on the same night. Given an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police. Example 1: Input: nums = [1, 2, 3, 1] Output: 4 Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3). Total amount you can rob = 1 + 3 = 4. Example 2: Input: nums = [2, 7, 9, 3, 1] Output: 12 Explanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1). Total amount you can rob = 2 + 9 + 1 = 12. Constraints: 1 <= nums.length <= 100^0 <= nums[i] <= 400\n", "code_prompt": "class Solution:\n    def rob(self, nums: List[int]) -> int:\n        ", "raw_response": "```python\nclass Solution:\n    def rob(self, nums: List[int]) -> int:\n        if not nums: # if the list is empty, return 0\n            return 0\n        elif len(nums) == 1: # if there is only one house, return its money\n            return nums[0]\n        elif len(nums) == 2: # if there are only two houses, return the maximum money of the two\n            return max(nums)\n        \n        dp = [0] * len(nums) # initialize the dynamic programming array\n        \n        # base cases\n        dp[0] = nums[0]\n        dp[1] = max(nums[0], nums[1])\n        \n        # fill in the rest of the array using the dynamic programming approach\n        for i in range(2, len(nums)):\n            dp[i] = max(dp[i-2] + nums[i], dp[i-1])\n        \n        return dp[-1] # return the maximum amount of money that can be robbed tonight without alerting the police\n```\nExplanation:\n- In this problem, we can use dynamic programming to solve it efficiently. We will create an array called \"dp\" to store the maximum amount of money that can be robbed up to the ith house.\n- We initialize the first two values of the \"dp\" array based on the base cases: if there is no house, the maximum money is 0; if there is only one house, the maximum money is the money of that house.\n- Then, we iterate through the rest of the houses starting from the third house.\n- At each house, we have two choices: either rob the current house and add its money to the maximum amount of money that can be robbed up to two houses before, or skip the current house and take the maximum amount of money that can be robbed up to the previous house. We choose the maximum of these two choices as the maximum amount of money that can be robbed up to the current house.\n- Finally, we return the last element of the \"dp\" array, which represents the maximum amount of money that can be robbed tonight without alerting the police.", "cleaned_response": "\nclass Solution:\n    def rob(self, nums: List[int]) -> int:\n        if not nums: # if the list is empty, return 0\n            return 0\n        elif len(nums) == 1: # if there is only one house, return its money\n            return nums[0]\n        elif len(nums) == 2: # if there are only two houses, return the maximum money of the two\n            return max(nums)\n        \n        dp = [0] * len(nums) # initialize the dynamic programming array\n        \n        # base cases\n        dp[0] = nums[0]\n        dp[1] = max(nums[0], nums[1])\n        \n        # fill in the rest of the array using the dynamic programming approach\n        for i in range(2, len(nums)):\n            dp[i] = max(dp[i-2] + nums[i], dp[i-1])\n        \n        return dp[-1] # return the maximum amount of money that can be robbed tonight without alerting the police\n", "n_pass": 1, "difficulty": 2.0, "frontend_question_id": 198.0, "loc": 173}
{"task_input": "\nLeetCode Problem #199\nTitle: Binary Tree Right Side View\nDescription:\nGiven the root of a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom. Example 1: Input: root = [1, 2, 3, null, 5, null, 4] Output: [1, 3, 4] Example 2: Input: root = [1, null, 3] Output: [1, 3] Example 3: Input: root = [] Output: [] Constraints: The number of nodes in the tree is in the range [0, 100]. -100 <= Node. val <= 100\n", "code_prompt": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def rightSideView(self, root: Optional[TreeNode]) -> List[int]:\n        ", "raw_response": "```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    def rightSideView(self, root: Optional[TreeNode]) -> List[int]:\n        # Check if the tree is empty\n        if not root:\n            return []\n        \n        # Initialize a list to store the values of the rightmost nodes\n        rightmost_values = []\n        \n        # Define a helper function to traverse the tree in a depth-first search manner\n        def dfs(node: TreeNode, level: int) -> None:\n            # Check if the current level is greater than the length of the list\n            if level > len(rightmost_values):\n                # Add the value of the current node to the list\n                rightmost_values.append(node.val)\n            else:\n                # Update the value at the current level with the value of the current node\n                rightmost_values[level - 1] = node.val\n            \n            # Traverse the right subtree if it exists\n            if node.right:\n                dfs(node.right, level + 1)\n            \n            # Traverse the left subtree if it exists\n            if node.left:\n                dfs(node.left, level + 1)\n        \n        # Start the depth-first search traversal from the root node at level 1\n        dfs(root, 1)\n        \n        # Return the list of rightmost values\n        return rightmost_values \n```", "cleaned_response": "\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    def rightSideView(self, root: Optional[TreeNode]) -> List[int]:\n        # Check if the tree is empty\n        if not root:\n            return []\n        \n        # Initialize a list to store the values of the rightmost nodes\n        rightmost_values = []\n        \n        # Define a helper function to traverse the tree in a depth-first search manner\n        def dfs(node: TreeNode, level: int) -> None:\n            # Check if the current level is greater than the length of the list\n            if level > len(rightmost_values):\n                # Add the value of the current node to the list\n                rightmost_values.append(node.val)\n            else:\n                # Update the value at the current level with the value of the current node\n                rightmost_values[level - 1] = node.val\n            \n            # Traverse the right subtree if it exists\n            if node.right:\n                dfs(node.right, level + 1)\n            \n            # Traverse the left subtree if it exists\n            if node.left:\n                dfs(node.left, level + 1)\n        \n        # Start the depth-first search traversal from the root node at level 1\n        dfs(root, 1)\n        \n        # Return the list of rightmost values\n        return rightmost_values \n", "n_pass": 1, "difficulty": 2.0, "frontend_question_id": 199.0, "loc": 174}
{"task_input": "\nLeetCode Problem #201\nTitle: Bitwise AND of Numbers Range\nDescription:\nGiven two integers left and right that represent the range [left, right], return the bitwise AND of all numbers in this range, inclusive. Example 1: Input: left = 5, right = 7 Output: 4 Example 2: Input: left = 0, right = 0 Output: 0 Example 3: Input: left = 1, right = 2147483647 Output: 0 Constraints: 0 <= left <= right <= 2^31 - 1\n", "code_prompt": "class Solution:\n    def rangeBitwiseAnd(self, left: int, right: int) -> int:\n        ", "raw_response": "```python\nclass Solution:\n    def rangeBitwiseAnd(self, left: int, right: int) -> int:\n        shift = 0\n        while left != right:\n            left >>= 1\n            right >>= 1\n            shift += 1\n        return left << shift\n```\nThe above code uses bitwise shifting to find the common leftmost bits between the left and right numbers. We right shift both numbers until they become equal. The number of right shifts performed is stored in the `shift` variable. Finally, we left shift the left number by `shift` bits to get the bitwise AND of all numbers in the range.", "cleaned_response": "\nclass Solution:\n    def rangeBitwiseAnd(self, left: int, right: int) -> int:\n        shift = 0\n        while left != right:\n            left >>= 1\n            right >>= 1\n            shift += 1\n        return left << shift\n", "n_pass": 1, "difficulty": 2.0, "frontend_question_id": 201.0, "loc": 176}
{"task_input": "\nLeetCode Problem #208\nTitle: Implement Trie (Prefix Tree)\nDescription:\nA trie (pronounced as \"try\") or prefix tree is a tree data structure used to efficiently store and retrieve keys in a dataset of strings. There are various applications of this data structure, such as autocomplete and spellchecker. Implement the Trie class: Trie() Initializes the trie object. void insert(String word) Inserts the string word into the trie. boolean search(String word) Returns true if the string word is in the trie (i. e. , was inserted before), and false otherwise. boolean startsWith(String prefix) Returns true if there is a previously inserted string word that has the prefix prefix, and false otherwise. Example 1: Input [\"Trie\", \"insert\", \"search\", \"search\", \"startsWith\", \"insert\", \"search\"] [[], [\"apple\"], [\"apple\"], [\"app\"], [\"app\"], [\"app\"], [\"app\"]] Output [null, null, true, false, true, null, true] Explanation Trie trie = new Trie(); trie. insert(\"apple\"); trie. search(\"apple\"); // return True trie. search(\"app\"); // return False trie. startsWith(\"app\"); // return True trie. insert(\"app\"); trie. search(\"app\"); // return True Constraints: 1 <= word.length, prefix.length <= 2000 word and prefix consist only of lowercase English letters. At most 3 * 10e4 calls in total will be made to insert, search, and startsWith.\n", "code_prompt": "class Trie:\n\n    def __init__(self):\n        \n\n    def insert(self, word: str) -> None:\n        \n\n    def search(self, word: str) -> bool:\n        \n\n    def startsWith(self, prefix: str) -> bool:\n        \n\n\n# Your Trie object will be instantiated and called as such:\n# obj = Trie()\n# obj.insert(word)\n# param_2 = obj.search(word)\n# param_3 = obj.startsWith(prefix)", "raw_response": "```python\nclass Trie:\n\n    def __init__(self):\n        self.children = {}\n        self.is_word = False\n\n    def insert(self, word: str) -> None:\n        curr = self\n        for char in word:\n            if char not in curr.children:\n                curr.children[char] = Trie()\n            curr = curr.children[char]\n        curr.is_word = True\n\n    def search(self, word: str) -> bool:\n        curr = self\n        for char in word:\n            if char not in curr.children:\n                return False\n            curr = curr.children[char]\n        return curr.is_word\n\n    def startsWith(self, prefix: str) -> bool:\n        curr = self\n        for char in prefix:\n            if char not in curr.children:\n                return False\n            curr = curr.children[char]\n        return True\n\n# Your Trie object will be instantiated and called as such:\n# obj = Trie()\n# obj.insert(word)\n# param_2 = obj.search(word)\n# param_3 = obj.startsWith(prefix)\n```", "cleaned_response": "\nclass Trie:\n\n    def __init__(self):\n        self.children = {}\n        self.is_word = False\n\n    def insert(self, word: str) -> None:\n        curr = self\n        for char in word:\n            if char not in curr.children:\n                curr.children[char] = Trie()\n            curr = curr.children[char]\n        curr.is_word = True\n\n    def search(self, word: str) -> bool:\n        curr = self\n        for char in word:\n            if char not in curr.children:\n                return False\n            curr = curr.children[char]\n        return curr.is_word\n\n    def startsWith(self, prefix: str) -> bool:\n        curr = self\n        for char in prefix:\n            if char not in curr.children:\n                return False\n            curr = curr.children[char]\n        return True\n\n# Your Trie object will be instantiated and called as such:\n# obj = Trie()\n# obj.insert(word)\n# param_2 = obj.search(word)\n# param_3 = obj.startsWith(prefix)\n", "n_pass": 1, "difficulty": 2.0, "frontend_question_id": 208.0, "loc": 183}
{"task_input": "\nLeetCode Problem #209\nTitle: Minimum Size Subarray Sum\nDescription:\nGiven an array of positive integers nums and a positive integer target, return the minimal length of a subarray whose sum is greater than or equal to target. If there is no such subarray, return 0 instead. Example 1: Input: target = 7, nums = [2, 3, 1, 2, 4, 3] Output: 2 Explanation: The subarray [4, 3] has the minimal length under the problem constraint. Example 2: Input: target = 4, nums = [1, 4, 4] Output: 1 Example 3: Input: target = 11, nums = [1, 1, 1, 1, 1, 1, 1, 1] Output: 0 Constraints: 1 <= target <= 10e9 1 <= nums.length <= 10e5 1 <= nums[i] <= 10e4 Follow up: If you have figured out the O(n) solution, try coding another solution of which the time complexity is O(n log(n)).\n", "code_prompt": "class Solution:\n    def minSubArrayLen(self, target: int, nums: List[int]) -> int:\n        ", "raw_response": "```python\nfrom typing import List\n\nclass Solution:\n    def minSubArrayLen(self, target: int, nums: List[int]) -> int:\n        n = len(nums)\n        left = 0\n        minLength = float(\"inf\")\n        currSum = 0\n        \n        for i in range(n):  # iterate through the array\n            currSum += nums[i]  # add the current element to the sum\n            \n            # while the current sum is greater than or equal to the target\n            while currSum >= target:\n                length = i - left + 1  # calculate the length of the subarray\n                minLength = min(minLength, length)  # update the minimum length\n                \n                currSum -= nums[left]  # subtract the leftmost element\n                left += 1  # move the left pointer to the right\n        \n        # if minLength is still infinity, it means no subarray is found\n        return minLength if minLength != float(\"inf\") else 0\n```\nThe given problem can be solved using the sliding window approach. We initialize `left` as 0 and `minLength` as `float(\"inf\")`. Then, we iterate through the array and keep adding the current element to `currSum`. If `currSum` becomes greater than or equal to the target, we update the `minLength` with the minimum length of subarray seen so far. After that, we subtract the leftmost element from `currSum` and move the left pointer to the right until `currSum` becomes less than the target again. Finally, we return the `minLength`, and if it is still `float(\"inf\")`, it means no subarray is found, so we return 0.", "cleaned_response": "\nfrom typing import List\n\nclass Solution:\n    def minSubArrayLen(self, target: int, nums: List[int]) -> int:\n        n = len(nums)\n        left = 0\n        minLength = float(\"inf\")\n        currSum = 0\n        \n        for i in range(n):  # iterate through the array\n            currSum += nums[i]  # add the current element to the sum\n            \n            # while the current sum is greater than or equal to the target\n            while currSum >= target:\n                length = i - left + 1  # calculate the length of the subarray\n                minLength = min(minLength, length)  # update the minimum length\n                \n                currSum -= nums[left]  # subtract the leftmost element\n                left += 1  # move the left pointer to the right\n        \n        # if minLength is still infinity, it means no subarray is found\n        return minLength if minLength != float(\"inf\") else 0\n", "n_pass": 1, "difficulty": 2.0, "frontend_question_id": 209.0, "loc": 184}
{"task_input": "\nLeetCode Problem #211\nTitle: Design Add and Search Words Data Structure\nDescription:\nDesign a data structure that supports adding new words and finding if a string matches any previously added string. Implement the WordDictionary class: WordDictionary() Initializes the object. void addWord(word) Adds word to the data structure, it can be matched later. bool search(word) Returns true if there is any string in the data structure that matches word or false otherwise. word may contain dots . where dots can be matched with any letter. Example: Input [\"WordDictionary\", \"addWord\", \"addWord\", \"addWord\", \"search\", \"search\", \"search\", \"search\"] [[], [\"bad\"], [\"dad\"], [\"mad\"], [\"pad\"], [\"bad\"], [\". ad\"], [\"b. . \"]] Output [null, null, null, null, false, true, true, true] Explanation WordDictionary wordDictionary = new WordDictionary(); wordDictionary. addWord(\"bad\"); wordDictionary. addWord(\"dad\"); wordDictionary. addWord(\"mad\"); wordDictionary. search(\"pad\"); // return False wordDictionary. search(\"bad\"); // return True wordDictionary. search(\". ad\"); // return True wordDictionary. search(\"b. . \"); // return True Constraints: 1 <= word.length <= 25 word in addWord consists of lowercase English letters. word in search consist of . or lowercase English letters. There will be at most 2 dots in word for search queries. At most 10e4 calls will be made to addWord and search.\n", "code_prompt": "class WordDictionary:\n\n    def __init__(self):\n        \n\n    def addWord(self, word: str) -> None:\n        \n\n    def search(self, word: str) -> bool:\n        \n\n\n# Your WordDictionary object will be instantiated and called as such:\n# obj = WordDictionary()\n# obj.addWord(word)\n# param_2 = obj.search(word)", "raw_response": "```python\nclass WordDictionary:\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self.trie = {}\n        \n    def addWord(self, word: str) -> None:\n        \"\"\"\n        Adds a word into the data structure.\n        \"\"\"\n        node = self.trie\n        for ch in word:\n            if ch not in node:\n                node[ch] = {}\n            node = node[ch]\n        node['#'] = True\n        \n    def search(self, word: str) -> bool:\n        \"\"\"\n        Returns if the word is in the data structure. A word could contain the dot character '.' to represent any one letter.\n        \"\"\"\n        def search_in_node(word, node) -> bool:\n            for i, ch in enumerate(word):\n                if ch != '.':\n                    if ch not in node:\n                        return False\n                    node = node[ch]\n                else:\n                    for child in node.values():\n                        if search_in_node(word[i+1:], child):\n                            return True\n                    return False\n            return '#' in node\n        \n        return search_in_node(word, self.trie)\n```\n\n# Your WordDictionary object will be instantiated and called as such:\n# obj = WordDictionary()\n# obj.addWord(word)\n# param_2 = obj.search(word)\n```", "cleaned_response": "\nclass WordDictionary:\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self.trie = {}\n        \n    def addWord(self, word: str) -> None:\n        \"\"\"\n        Adds a word into the data structure.\n        \"\"\"\n        node = self.trie\n        for ch in word:\n            if ch not in node:\n                node[ch] = {}\n            node = node[ch]\n        node['#'] = True\n        \n    def search(self, word: str) -> bool:\n        \"\"\"\n        Returns if the word is in the data structure. A word could contain the dot character '.' to represent any one letter.\n        \"\"\"\n        def search_in_node(word, node) -> bool:\n            for i, ch in enumerate(word):\n                if ch != '.':\n                    if ch not in node:\n                        return False\n                    node = node[ch]\n                else:\n                    for child in node.values():\n                        if search_in_node(word[i+1:], child):\n                            return True\n                    return False\n            return '#' in node\n        \n        return search_in_node(word, self.trie)\n", "n_pass": 1, "difficulty": 2.0, "frontend_question_id": 211.0, "loc": 186}
{"task_input": "\nLeetCode Problem #212\nTitle: Word Search II\nDescription:\nGiven an m x n board of characters and a list of strings words, return all words on the board. Each word must be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once in a word. Example 1: Input: board = [[\"o\", \"a\", \"a\", \"n\"], [\"e\", \"t\", \"a\", \"e\"], [\"i\", \"h\", \"k\", \"r\"], [\"i\", \"f\", \"l\", \"v\"]], words = [\"oath\", \"pea\", \"eat\", \"rain\"] Output: [\"eat\", \"oath\"] Example 2: Input: board = [[\"a\", \"b\"], [\"c\", \"d\"]], words = [\"abcb\"] Output: [] Constraints: m == board.length n == board[i].length 1 <= m, n <= 12 board[i][j] is a lowercase English letter. 1 <= words.length <= 3 * 10e4 1 <= words[i].length <= 10 words[i] consists of lowercase English letters. All the strings of words are unique.\n", "code_prompt": "class Solution:\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\n        ", "raw_response": "```python\nfrom typing import List\n\nclass TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n    \n    def insert(self, word):\n        curr = self.root\n        for ch in word:\n            if ch not in curr.children:\n                curr.children[ch] = TrieNode()\n            curr = curr.children[ch]\n        curr.is_end = True\n\nclass Solution:\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\n        # Initialize trie\n        trie = Trie()\n        \n        # Insert words into trie\n        for word in words:\n            trie.insert(word)\n        \n        # Define directions for DFS\n        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n        def dfs(node, i, j, path, visited, res):\n            # Check if reached end of word\n            if node.is_end:\n                res.append(\"\".join(path))\n                node.is_end = False  # Remove word from trie to avoid duplicates\n\n            if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]):\n                return\n            \n            if (i, j) in visited:\n                return\n            \n            char = board[i][j]\n            if char not in node.children:\n                return\n            \n            visited.add((i, j))\n            path.append(char)\n            \n            for dx, dy in directions:\n                new_i = i + dx\n                new_j = j + dy\n                dfs(node.children[char], new_i, new_j, path, visited, res)\n            \n            path.pop()\n            visited.remove((i, j))\n\n        # Perform DFS on each cell of the board\n        m, n = len(board), len(board[0])\n        res = []\n        for i in range(m):\n            for j in range(n):\n                dfs(trie.root, i, j, [], set(), res)\n        \n        return res\n```\n\nThe above code implements the `findWords` function. It uses a Trie data structure to efficiently store and search for words. The Trie is first populated with the words from the input list. Then, a DFS algorithm is used to search for words on the board. The function `dfs` performs the DFS search starting from a given cell of the board. It checks if the current cell corresponds to a valid letter in the Trie, and if so, continues the search in all possible neighboring cells. If a word is found, it is added to the result list. The function also includes necessary checks to handle boundary conditions and avoid revisiting cells. Finally, the function iterates over all cells in the board and performs the DFS search, returning the list of found words.", "cleaned_response": "\nfrom typing import List\n\nclass TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n    \n    def insert(self, word):\n        curr = self.root\n        for ch in word:\n            if ch not in curr.children:\n                curr.children[ch] = TrieNode()\n            curr = curr.children[ch]\n        curr.is_end = True\n\nclass Solution:\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\n        # Initialize trie\n        trie = Trie()\n        \n        # Insert words into trie\n        for word in words:\n            trie.insert(word)\n        \n        # Define directions for DFS\n        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n        def dfs(node, i, j, path, visited, res):\n            # Check if reached end of word\n            if node.is_end:\n                res.append(\"\".join(path))\n                node.is_end = False  # Remove word from trie to avoid duplicates\n\n            if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]):\n                return\n            \n            if (i, j) in visited:\n                return\n            \n            char = board[i][j]\n            if char not in node.children:\n                return\n            \n            visited.add((i, j))\n            path.append(char)\n            \n            for dx, dy in directions:\n                new_i = i + dx\n                new_j = j + dy\n                dfs(node.children[char], new_i, new_j, path, visited, res)\n            \n            path.pop()\n            visited.remove((i, j))\n\n        # Perform DFS on each cell of the board\n        m, n = len(board), len(board[0])\n        res = []\n        for i in range(m):\n            for j in range(n):\n                dfs(trie.root, i, j, [], set(), res)\n        \n        return res\n", "n_pass": 1, "difficulty": 3.0, "frontend_question_id": 212.0, "loc": 187}
{"task_input": "\nLeetCode Problem #213\nTitle: House Robber II\nDescription:\nYou are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have a security system connected, and it will automatically contact the police if two adjacent houses were broken into on the same night. Given an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police. Example 1: Input: nums = [2, 3, 2] Output: 3 Explanation: You cannot rob house 1 (money = 2) and then rob house 3 (money = 2), because they are adjacent houses. Example 2: Input: nums = [1, 2, 3, 1] Output: 4 Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3). Total amount you can rob = 1 + 3 = 4. Example 3: Input: nums = [1, 2, 3] Output: 3 Constraints: 1 <= nums.length <= 100^0 <= nums[i] <= 1000\n", "code_prompt": "class Solution:\n    def rob(self, nums: List[int]) -> int:\n        ", "raw_response": "```python\nclass Solution:\n    def rob(self, nums: List[int]) -> int:\n        if len(nums) == 1:\n            return nums[0]\n        \n        def helper(nums):\n            dp = [0] * (len(nums) + 1)\n            dp[1] = nums[0]\n            \n            for i in range(2, len(nums) + 1):\n                dp[i] = max(dp[i-1], dp[i-2] + nums[i-1])\n            \n            return dp[-1]\n        \n        return max(helper(nums[1:]), helper(nums[:-1]))\n```\n\nThe above code defines a class called `Solution` with a method `rob` that takes in an integer array `nums` and returns the maximum amount of money that can be robbed without alerting the police.\n\nThe logic of the solution is as follows:\n- If the length of the input array is 1, then we can only rob that house and return its money.\n- We define a helper function `helper` that calculates the maximum amount of money that can be robbed from a given array of numbers.\n- In the `helper` function, we use dynamic programming to calculate the maximum amount of money. We create a DP array `dp` of length `len(nums) + 1` and initialize it with zeros. \n- We iterate over the input array starting from the second element (index 1) and calculate the maximum amount of money that can be robbed at each house. The maximum amount at each house is the maximum of skipping the current house (`dp[i-1]`) and robbing the current house and the house before it (`dp[i-2] + nums[i-1]`).\n- Finally, we return the maximum of robbing houses from the second to the last, and robbing houses from the first to the second last. This is because the houses are arranged in a circle, so robbing the first house prevents us from robbing the last house, and vice versa.", "cleaned_response": "\nclass Solution:\n    def rob(self, nums: List[int]) -> int:\n        if len(nums) == 1:\n            return nums[0]\n        \n        def helper(nums):\n            dp = [0] * (len(nums) + 1)\n            dp[1] = nums[0]\n            \n            for i in range(2, len(nums) + 1):\n                dp[i] = max(dp[i-1], dp[i-2] + nums[i-1])\n            \n            return dp[-1]\n        \n        return max(helper(nums[1:]), helper(nums[:-1]))\n", "n_pass": 1, "difficulty": 2.0, "frontend_question_id": 213.0, "loc": 188}
{"task_input": "\nLeetCode Problem #214\nTitle: Shortest Palindrome\nDescription:\nYou are given a string s. You can convert s to a palindrome by adding characters in front of it. Return the shortest palindrome you can find by performing this transformation. Example 1: Input: s = \"aacecaaa\" Output: \"aaacecaaa\" Example 2: Input: s = \"abcd\" Output: \"dcbabcd\" Constraints: 0 <= s.length <= 5 * 10e4 s consists of lowercase English letters only.\n", "code_prompt": "class Solution:\n    def shortestPalindrome(self, s: str) -> str:\n        ", "raw_response": "class Solution:\n    def shortestPalindrome(self, s: str) -> str:\n        if s == s[::-1]:\n            return s\n        \n        n = len(s)\n        rev = s[::-1]\n        \n        for i in range(n):\n            if s[:n-i] == rev[i:]:\n                return rev[:i] + s\n        return \"\"", "cleaned_response": "class Solution:\n    def shortestPalindrome(self, s: str) -> str:\n        if s == s[::-1]:\n            return s\n        \n        n = len(s)\n        rev = s[::-1]\n        \n        for i in range(n):\n            if s[:n-i] == rev[i:]:\n                return rev[:i] + s\n        return \"\"", "n_pass": 1, "difficulty": 3.0, "frontend_question_id": 214.0, "loc": 189}
{"task_input": "\nLeetCode Problem #216\nTitle: Combination Sum III\nDescription:\nFind all valid combinations of k numbers that sum up to n such that the following conditions are true:...\n Only numbers 1 through 9 are used. Each number is used at most once. Return a list of all possible valid combinations. The list must not contain the same combination twice, and the combinations may be returned in any order. Example 1: Input: k = 3, n = 7 Output: [[1, 2, 4]] Explanation: 1 + 2 + 4 = 7 There are no other valid combinations. Example 2: Input: k = 3, n = 9 Output: [[1, 2, 6], [1, 3, 5], [2, 3, 4]] Explanation: 1 + 2 + 6 = 9^1 + 3 + 5 = 9^2 + 3 + 4 = 9 There are no other valid combinations. Example 3: Input: k = 4, n = 1 Output: [] Explanation: There are no valid combinations. Using 4 different numbers in the range [1, 9], the smallest sum we can get is 1+2+3+4 = 10 and since 10 > 1, there are no valid combination. Constraints: 2 <= k <= 9^1 <= n <= 60\n", "code_prompt": "class Solution:\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\n        ", "raw_response": "```python\nfrom typing import List\n\nclass Solution:\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\n        result = []\n        self.backtrack(k, n, 1, [], result)\n        return result\n    \n    def backtrack(self, k, n, start, path, result):\n        # Base case: if k and n are both 0, append the path to the result\n        if k == 0 and n == 0:\n            result.append(path)\n            return\n        \n        # Base case: if k or n becomes negative, return\n        if k < 0 or n < 0:\n            return\n        \n        # Backtracking recursion\n        for i in range(start, 10):\n            self.backtrack(k - 1, n - i, i + 1, path + [i], result)\n```\n\nThe solution uses a backtracking algorithm to generate all possible combinations. The `combinationSum3` function initializes an empty `result` list and then calls the `backtrack` function with the parameters `k` (the number of numbers to sum), `n` (the target sum), `start` (the starting number for each combination), an empty `path` list to store the current combination, and the `result` list to store all valid combinations.\n\nThe `backtrack` function follows the backtracking algorithm. It has three base cases: if `k` and `n` are both 0, it means that we have found a valid combination and we append the `path` to the `result` list. If `k` or `n` becomes negative, it means that the current combination is not valid and we return. In the recursive case, we iterate from `start` to `9` (since the numbers must be between 1 and 9) and call the `backtrack` function recursively with `k - 1` (since we have used one number), `n - i` (where `i` is the current number), `i + 1` (to ensure that each number is used only once), `path + [i]` (to add the current number to the current combination), and `result` (to store all valid combinations).\n\nFinally, we return the `result` list, which contains all valid combinations.", "cleaned_response": "\nfrom typing import List\n\nclass Solution:\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\n        result = []\n        self.backtrack(k, n, 1, [], result)\n        return result\n    \n    def backtrack(self, k, n, start, path, result):\n        # Base case: if k and n are both 0, append the path to the result\n        if k == 0 and n == 0:\n            result.append(path)\n            return\n        \n        # Base case: if k or n becomes negative, return\n        if k < 0 or n < 0:\n            return\n        \n        # Backtracking recursion\n        for i in range(start, 10):\n            self.backtrack(k - 1, n - i, i + 1, path + [i], result)\n", "n_pass": 1, "difficulty": 2.0, "frontend_question_id": 216.0, "loc": 191}
{"task_input": "\nLeetCode Problem #218\nTitle: The Skyline Problem\nDescription:\nA city's skyline is the outer contour of the silhouette formed by all the buildings in that city when viewed from a distance. Given the locations and heights of all the buildings, return the skyline formed by these buildings collectively. The geometric information of each building is given in the array buildings where buildings[i] = [left i, right i, height i ] : left i is the x coordinate of the left edge of the i th building. right i is the x coordinate of the right edge of the i th building. height i is the height of the i th building. You may assume all buildings are perfect rectangles grounded on an absolutely flat surface at height 0. The skyline should be represented as a list of \"key points\" sorted by their x-coordinate in the form [[x 1, y 1 ], [x 2, y 2 ],. . . ]. Each key point is the left endpoint of some horizontal segment in the skyline except the last point in the list, which always has a y-coordinate 0 and is used to mark the skyline's termination where the rightmost building ends. Any ground between the leftmost and rightmost buildings should be part of the skyline's contour. Note: There must be no consecutive horizontal lines of equal height in the output skyline. For instance, [. . . , [2^3], [4^5], [7^5], [11^5], [12^7],. . . ] is not acceptable; the three lines of height 5 should be merged into one in the final output as such: [. . . , [2^3], [4^5], [12^7],. . . ] Example 1: Input: buildings = [[2, 9, 10], [3, 7, 15], [5, 12, 12], [15, 20, 10], [19, 24, 8]] Output: [[2, 10], [3, 15], [7, 12], [12, 0], [15, 10], [20, 8], [24, 0]] Explanation: Figure A shows the buildings of the input. Figure B shows the skyline formed by those buildings. The red points in figure B represent the key points in the output list. Example 2: Input: buildings = [[0, 2, 3], [2, 5, 3]] Output: [[0, 3], [5, 0]] Constraints: 1 <= buildings.length <= 10e4 0 <= left i < right i <= 2^31 - 1^1 <= height i <= 2^31 - 1 buildings is sorted by left i in non-decreasing order.\n", "code_prompt": "class Solution:\n    def getSkyline(self, buildings: List[List[int]]) -> List[List[int]]:\n        ", "raw_response": "class Solution:\n    def getSkyline(self, buildings: List[List[int]]) -> List[List[int]]:\n        # Initialize a list to store the key points\n        points = []\n        \n        # Create a list to store the left and right edges of each building with their respective heights\n        edges = []\n        for building in buildings:\n            left, right, height = building\n            edges.append((left, -height))  # -height represents that it is the left edge of the building\n            edges.append((right, height))  # height represents that it is the right edge of the building\n        \n        # Sort the edges based on the x-coordinate in non-decreasing order\n        edges.sort()\n        \n        # Create a heap (priority queue) to store the heights of active buildings\n        active_buildings = [(0, float('inf'))]  # Initialize with a dummy building\n        \n        # Iterate through the sorted edges\n        for x, h in edges:\n            # If it is the left edge of a building, add the height to the active buildings\n            if h < 0:\n                heapq.heappush(active_buildings, (h, -x))\n            # If it is the right edge of a building, remove the height from the active buildings\n            else:\n                active_buildings.remove((-h, x))\n                heapq.heapify(active_buildings)\n            \n            # Get the maximum height among the active buildings\n            max_height = -active_buildings[0][0]\n            \n            # If the maximum height has changed, it is a key point\n            if len(points) == 0 or max_height != points[-1][1]:\n                points.append([x, max_height])\n        \n        # Append the final key point where the rightmost building ends\n        points.append([edges[-1][0], 0])\n        \n        return points", "cleaned_response": "class Solution:\n    def getSkyline(self, buildings: List[List[int]]) -> List[List[int]]:\n        # Initialize a list to store the key points\n        points = []\n        \n        # Create a list to store the left and right edges of each building with their respective heights\n        edges = []\n        for building in buildings:\n            left, right, height = building\n            edges.append((left, -height))  # -height represents that it is the left edge of the building\n            edges.append((right, height))  # height represents that it is the right edge of the building\n        \n        # Sort the edges based on the x-coordinate in non-decreasing order\n        edges.sort()\n        \n        # Create a heap (priority queue) to store the heights of active buildings\n        active_buildings = [(0, float('inf'))]  # Initialize with a dummy building\n        \n        # Iterate through the sorted edges\n        for x, h in edges:\n            # If it is the left edge of a building, add the height to the active buildings\n            if h < 0:\n                heapq.heappush(active_buildings, (h, -x))\n            # If it is the right edge of a building, remove the height from the active buildings\n            else:\n                active_buildings.remove((-h, x))\n                heapq.heapify(active_buildings)\n            \n            # Get the maximum height among the active buildings\n            max_height = -active_buildings[0][0]\n            \n            # If the maximum height has changed, it is a key point\n            if len(points) == 0 or max_height != points[-1][1]:\n                points.append([x, max_height])\n        \n        # Append the final key point where the rightmost building ends\n        points.append([edges[-1][0], 0])\n        \n        return points", "n_pass": 1, "difficulty": 3.0, "frontend_question_id": 218.0, "loc": 193}
{"task_input": "\nLeetCode Problem #220\nTitle: Contains Duplicate III\nDescription:\nYou are given an integer array nums and two integers indexDiff and valueDiff. Find a pair of indices (i, j) such that: i != j, abs(i - j) <= indexDiff. abs(nums[i] - nums[j]) <= valueDiff, and Return true if such pair exists or false otherwise. Example 1: Input: nums = [1, 2, 3, 1], indexDiff = 3, valueDiff = 0 Output: true Explanation: We can choose (i, j) = (0, 3). We satisfy the three conditions: i != j --> 0 != 3 abs(i - j) <= indexDiff --> abs(0 - 3) <= 3 abs(nums[i] - nums[j]) <= valueDiff --> abs(1 - 1) <= 0 Example 2: Input: nums = [1, 5, 9, 1, 5, 9], indexDiff = 2, valueDiff = 3 Output: false Explanation: After trying all the possible pairs (i, j), we cannot satisfy the three conditions, so we return false. Constraints: 2 <= nums.length <= 10e5 -10e9 <= nums[i] <= 10e9 1 <= indexDiff <= nums.length 0 <= valueDiff <= 10e9\n", "code_prompt": "class Solution:\n    def containsNearbyAlmostDuplicate(self, nums: List[int], indexDiff: int, valueDiff: int) -> bool:\n        ", "raw_response": "The problem asks us to find a pair of indices (i, j) such that:\n1. i != j\n2. abs(i - j) <= indexDiff\n3. abs(nums[i] - nums[j]) <= valueDiff\n\nTo solve this problem, we can use a sliding window approach. We will maintain a window of size (indexDiff + 1) and keep track of the absolute difference between each element in the window and its index. If the difference is less than or equal to valueDiff, we return True. If no such pair is found, we return False.\n\nHere is the complete implementation of the solution:\n\n```python\nfrom typing import List\n\nclass Solution:\n    def containsNearbyAlmostDuplicate(self, nums: List[int], indexDiff: int, valueDiff: int) -> bool:\n        if indexDiff == 0:\n            return False\n        \n        # Use a sliding window approach\n        window = {}\n        \n        for i in range(len(nums)):\n            # Check if there is an element in the window within valueDiff range\n            if i > indexDiff:\n                del window[nums[i - indexDiff - 1] // (valueDiff or 1)]\n            \n            # Check if there is an element in the window that satisfies the conditions\n            for j in range((nums[i] // (valueDiff or 1)) - 1, (nums[i] // (valueDiff or 1)) + 2):\n                if j in window and abs(nums[i] - window[j]) <= valueDiff:\n                    return True\n            \n            # Add the element to the window\n            window[nums[i] // (valueDiff or 1)] = nums[i]\n        \n        return False\n```\n\nLet's test the solution with the provided test cases:\n\n```python\nsolution = Solution()\n\n# Test case 1\nnums = [1, 2, 3, 1]\nindexDiff = 3\nvalueDiff = 0\nprint(solution.containsNearbyAlmostDuplicate(nums, indexDiff, valueDiff))\n# Output: True\n\n# Test case 2\nnums = [1, 5, 9, 1, 5, 9]\nindexDiff = 2\nvalueDiff = 3\nprint(solution.containsNearbyAlmostDuplicate(nums, indexDiff, valueDiff))\n# Output: False\n```\n\nThe solution passes all the given test cases.", "cleaned_response": "\nfrom typing import List\n\nclass Solution:\n    def containsNearbyAlmostDuplicate(self, nums: List[int], indexDiff: int, valueDiff: int) -> bool:\n        if indexDiff == 0:\n            return False\n        \n        # Use a sliding window approach\n        window = {}\n        \n        for i in range(len(nums)):\n            # Check if there is an element in the window within valueDiff range\n            if i > indexDiff:\n                del window[nums[i - indexDiff - 1] // (valueDiff or 1)]\n            \n            # Check if there is an element in the window that satisfies the conditions\n            for j in range((nums[i] // (valueDiff or 1)) - 1, (nums[i] // (valueDiff or 1)) + 2):\n                if j in window and abs(nums[i] - window[j]) <= valueDiff:\n                    return True\n            \n            # Add the element to the window\n            window[nums[i] // (valueDiff or 1)] = nums[i]\n        \n        return False\n", "n_pass": 1, "difficulty": 3.0, "frontend_question_id": 220.0, "loc": 195}
{"task_input": "\nLeetCode Problem #224\nTitle: Basic Calculator\nDescription:\nGiven a string s representing a valid expression, implement a basic calculator to evaluate it, and return the result of the evaluation. Note: You are not allowed to use any built-in function which evaluates strings as mathematical expressions, such as eval(). Example 1: Input: s = \"1 + 1\" Output: 2 Example 2: Input: s = \" 2-1 + 2 \" Output: 3 Example 3: Input: s = \"(1+(4+5+2)-3)+(6+8)\" Output: 23 Constraints: 1 <= s.length <= 3 * 10e5 s consists of digits, '+', '-', '(', ')', and ' '. s represents a valid expression. '+' is not used as a unary operation (i. e. , \"+1\" and \"+(2 + 3)\" is invalid). '-' could be used as a unary operation (i. e. , \"-1\" and \"-(2 + 3)\" is valid). There will be no two consecutive operators in the input. Every number and running calculation will fit in a signed 32-bit integer.\n", "code_prompt": "class Solution:\n    def calculate(self, s: str) -> int:\n        ", "raw_response": "```python\nclass Solution:\n    def calculate(self, s: str) -> int:\n        stack = []\n        operand = 0\n        result = 0\n        sign = 1 # 1 represents positive sign, -1 represents negative sign\n        \n        for ch in s:\n            if ch.isdigit():\n                operand = operand * 10 + int(ch)\n                \n            elif ch == '+':\n                result += sign * operand\n                operand = 0\n                sign = 1\n                \n            elif ch == '-':\n                result += sign * operand\n                operand = 0\n                sign = -1\n                \n            elif ch == '(':\n                stack.append(result)\n                stack.append(sign)\n                result = 0\n                sign = 1\n                \n            elif ch == ')':\n                result += sign * operand\n                operand = 0\n                result *= stack.pop() # pop the sign before the parenthesis\n                result += stack.pop() # add the result before the parenthesis to the current result\n                \n        return result + sign * operand\n```\n\nThe approach to solve this problem is to use a stack to keep track of the operands and the signs. We iterate through the string character by character and perform the necessary operations based on the current character.\n\nInitially, we set `operand` to 0 to keep track of the current number we are parsing, `result` to 0 to hold the running sum, and `sign` to 1 to represent the positive sign. \n\nWhen we encounter a digit, we update the `operand` by multiplying it by 10 and adding the current digit.\n\nWhen we encounter a '+' sign, we add the previous number (based on the current sign) to the `result`, reset the `operand` to 0, and update the `sign` to 1.\n\nWhen we encounter a '-' sign, we add the previous number (based on the current sign) to the `result`, reset the `operand` to 0, and update the `sign` to -1.\n\nWhen we encounter a '(' sign, we push the current `result` and `sign` to the stack, reset the `result` to 0, and update the `sign` to 1. This is done to handle nested parentheses.\n\nWhen we encounter a ')' sign, we add the current `operand` to the `result`, reset the `operand` to 0, multiply the `result` by the sign stored in the stack (which is the sign before the parentheses), and add the result stored in the stack (which is the result before the parentheses) to the current `result`.\n\nFinally, we return the `result` plus the last number (based on the current sign stored in `sign`) since there are no more operators remaining.\n\nThe time complexity of this approach is O(n), where n is the length of the input string.", "cleaned_response": "\nclass Solution:\n    def calculate(self, s: str) -> int:\n        stack = []\n        operand = 0\n        result = 0\n        sign = 1 # 1 represents positive sign, -1 represents negative sign\n        \n        for ch in s:\n            if ch.isdigit():\n                operand = operand * 10 + int(ch)\n                \n            elif ch == '+':\n                result += sign * operand\n                operand = 0\n                sign = 1\n                \n            elif ch == '-':\n                result += sign * operand\n                operand = 0\n                sign = -1\n                \n            elif ch == '(':\n                stack.append(result)\n                stack.append(sign)\n                result = 0\n                sign = 1\n                \n            elif ch == ')':\n                result += sign * operand\n                operand = 0\n                result *= stack.pop() # pop the sign before the parenthesis\n                result += stack.pop() # add the result before the parenthesis to the current result\n                \n        return result + sign * operand\n", "n_pass": 1, "difficulty": 3.0, "frontend_question_id": 224.0, "loc": 199}
{"task_input": "\nLeetCode Problem #227\nTitle: Basic Calculator II\nDescription:\nGiven a string s which represents an expression, evaluate this expression and return its value. The integer division should truncate toward zero. You may assume that the given expression is always valid. All intermediate results will be in the range of [-2^31, 2^31 - 1]. Note: You are not allowed to use any built-in function which evaluates strings as mathematical expressions, such as eval(). Example 1: Input: s = \"3+22.\" Output: 7 Example 2: Input: s = \" 3/2 \" Output: 1 Example 3: Input: s = \" 3+5 / 2 \" Output: 5 Constraints: 1 <= s.length <= 3 * 10e5 s consists of integers and operators ('+', '-', '*', '/') separated by some number of spaces. s represents a valid expression. All the integers in the expression are non-negative integers in the range [0, 2^31 - 1]. The answer is guaranteed to fit in a 32-bit integer.\n", "code_prompt": "class Solution:\n    def calculate(self, s: str) -> int:\n        ", "raw_response": "```python\nclass Solution:\n    def calculate(self, s: str) -> int:\n        # Remove all whitespace characters\n        s = s.replace(\" \", \"\")\n        \n        # Initialize variables\n        num = 0\n        currNum = 0\n        result = 0\n        prevOperator = \"+\"\n        \n        # Iterate through the string\n        for i in range(len(s)):\n            currChar = s[i]\n            \n            # Build the number\n            if currChar.isdigit():\n                currNum = currNum * 10 + int(currChar)\n                \n            # Perform calculations when encountering an operator or at the end of the string\n            if currChar in \"+-*/\" or i == len(s) - 1:\n                if prevOperator == \"+\":\n                    num += currNum\n                elif prevOperator == \"-\":\n                    num -= currNum\n                elif prevOperator == \"*\":\n                    num *= currNum\n                elif prevOperator == \"/\":\n                    num = int(num / currNum)\n                \n                # Update result and reset current number\n                if currChar in \"+-\" or i == len(s) - 1:\n                    result += num\n                    num = 0\n                \n                # Update previous operator and reset current number\n                prevOperator = currChar\n                currNum = 0\n        \n        return result\n```", "cleaned_response": "\nclass Solution:\n    def calculate(self, s: str) -> int:\n        # Remove all whitespace characters\n        s = s.replace(\" \", \"\")\n        \n        # Initialize variables\n        num = 0\n        currNum = 0\n        result = 0\n        prevOperator = \"+\"\n        \n        # Iterate through the string\n        for i in range(len(s)):\n            currChar = s[i]\n            \n            # Build the number\n            if currChar.isdigit():\n                currNum = currNum * 10 + int(currChar)\n                \n            # Perform calculations when encountering an operator or at the end of the string\n            if currChar in \"+-*/\" or i == len(s) - 1:\n                if prevOperator == \"+\":\n                    num += currNum\n                elif prevOperator == \"-\":\n                    num -= currNum\n                elif prevOperator == \"*\":\n                    num *= currNum\n                elif prevOperator == \"/\":\n                    num = int(num / currNum)\n                \n                # Update result and reset current number\n                if currChar in \"+-\" or i == len(s) - 1:\n                    result += num\n                    num = 0\n                \n                # Update previous operator and reset current number\n                prevOperator = currChar\n                currNum = 0\n        \n        return result\n", "n_pass": 1, "difficulty": 2.0, "frontend_question_id": 227.0, "loc": 202}
{"task_input": "\nLeetCode Problem #229\nTitle: Majority Element II\nDescription:\nGiven an integer array of size n, find all elements that appear more than \u230a n/3 \u230b times. Example 1: Input: nums = [3, 2, 3] Output: [3] Example 2: Input: nums = [1] Output: [1] Example 3: Input: nums = [1, 2] Output: [1, 2] Constraints: 1 <= nums.length <= 5 * 10e4 -10e9 <= nums[i] <= 10e9 Follow up: Could you solve the problem in linear time and in O(1) space?\n", "code_prompt": "class Solution:\n    def majorityElement(self, nums: List[int]) -> List[int]:\n        ", "raw_response": "```python\nfrom typing import List\n\nclass Solution:\n    def majorityElement(self, nums: List[int]) -> List[int]:\n        n = len(nums)\n        threshold = n // 3\n        result = []\n        \n        # Boyer-Moore Voting Algorithm\n        # Find the potential candidates\n        candidate1 = None\n        candidate2 = None\n        count1 = 0\n        count2 = 0\n        \n        for num in nums:\n            if candidate1 is not None and num == candidate1:\n                count1 += 1\n            elif candidate2 is not None and num == candidate2:\n                count2 += 1\n            elif count1 == 0:\n                candidate1 = num\n                count1 = 1\n            elif count2 == 0:\n                candidate2 = num\n                count2 = 1\n            else:\n                count1 -= 1\n                count2 -= 1\n        \n        # Count the occurrences of the potential candidates\n        count1 = 0\n        count2 = 0\n        for num in nums:\n            if candidate1 is not None and num == candidate1:\n                count1 += 1\n            if candidate2 is not None and num == candidate2:\n                count2 += 1\n        \n        # Verify if the potential candidates appear more than n/3 times\n        if count1 > threshold:\n            result.append(candidate1)\n        if count2 > threshold:\n            result.append(candidate2)\n        \n        return result\n```", "cleaned_response": "\nfrom typing import List\n\nclass Solution:\n    def majorityElement(self, nums: List[int]) -> List[int]:\n        n = len(nums)\n        threshold = n // 3\n        result = []\n        \n        # Boyer-Moore Voting Algorithm\n        # Find the potential candidates\n        candidate1 = None\n        candidate2 = None\n        count1 = 0\n        count2 = 0\n        \n        for num in nums:\n            if candidate1 is not None and num == candidate1:\n                count1 += 1\n            elif candidate2 is not None and num == candidate2:\n                count2 += 1\n            elif count1 == 0:\n                candidate1 = num\n                count1 = 1\n            elif count2 == 0:\n                candidate2 = num\n                count2 = 1\n            else:\n                count1 -= 1\n                count2 -= 1\n        \n        # Count the occurrences of the potential candidates\n        count1 = 0\n        count2 = 0\n        for num in nums:\n            if candidate1 is not None and num == candidate1:\n                count1 += 1\n            if candidate2 is not None and num == candidate2:\n                count2 += 1\n        \n        # Verify if the potential candidates appear more than n/3 times\n        if count1 > threshold:\n            result.append(candidate1)\n        if count2 > threshold:\n            result.append(candidate2)\n        \n        return result\n", "n_pass": 1, "difficulty": 2.0, "frontend_question_id": 229.0, "loc": 204}
{"task_input": "\nLeetCode Problem #233\nTitle: Number of Digit One\nDescription:\nGiven an integer n, count the total number of digit 1 appearing in all non-negative integers less than or equal to n. Example 1: Input: n = 13 Output: 6 Example 2: Input: n = 0 Output: 0 Constraints: 0 <= n <= 10e9\n", "code_prompt": "class Solution:\n    def countDigitOne(self, n: int) -> int:\n        ", "raw_response": "```python\nclass Solution:\n    def countDigitOne(self, n: int) -> int:\n        count = 0\n        factor = 1\n        current = n\n        while current > 0:\n            digit = current % 10\n            current //= 10\n            \n            count += (current * factor)\n            \n            if digit == 1:\n                count += (n % factor) + 1\n            elif digit > 1:\n                count += factor\n                \n            factor *= 10\n            \n        return count\n```", "cleaned_response": "\nclass Solution:\n    def countDigitOne(self, n: int) -> int:\n        count = 0\n        factor = 1\n        current = n\n        while current > 0:\n            digit = current % 10\n            current //= 10\n            \n            count += (current * factor)\n            \n            if digit == 1:\n                count += (n % factor) + 1\n            elif digit > 1:\n                count += factor\n                \n            factor *= 10\n            \n        return count\n", "n_pass": 1, "difficulty": 3.0, "frontend_question_id": 233.0, "loc": 208}
{"task_input": "\nLeetCode Problem #235\nTitle: Lowest Common Ancestor of a Binary Search Tree\nDescription:\nGiven a binary search tree (BST), find the lowest common ancestor (LCA) node of two given nodes in the BST. According to the definition of LCA on Wikipedia : \u201cThe lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself ). \u201d Example 1: Input: root = [6, 2, 8, 0, 4, 7, 9, null, null, 3, 5], p = 2, q = 8 Output: 6 Explanation: The LCA of nodes 2 and 8 is 6. Example 2: Input: root = [6, 2, 8, 0, 4, 7, 9, null, null, 3, 5], p = 2, q = 4 Output: 2 Explanation: The LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself according to the LCA definition. Example 3: Input: root = [2, 1], p = 2, q = 1 Output: 2 Constraints: The number of nodes in the tree is in the range [2, 10e5 ]. -10e9 <= Node. val <= 10e9 All Node. val are unique. p != q p and q will exist in the BST.\n", "code_prompt": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':\n        ", "raw_response": "```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':\n        # Base case: if the root is null or one of the nodes is equal to the root, return the root\n        if not root or root == p or root == q:\n            return root\n        \n        # Recursively search for the lowest common ancestor in the left and right subtrees\n        left = self.lowestCommonAncestor(root.left, p, q)\n        right = self.lowestCommonAncestor(root.right, p, q)\n        \n        # If both nodes are found in the left and right subtrees, return the root\n        if left and right:\n            return root\n        \n        # If only one node is found, return that node\n        if left:\n            return left\n        if right:\n            return right\n        \n        # If neither node is found, return None\n        return None\n```\n\nThe approach used here is a recursive approach. We traverse through the binary search tree starting from the root. At each node, we check if the node is equal to either of the given nodes (`p` or `q`). If it is, we return the node itself as the lowest common ancestor. If it's not equal to any of the nodes, we recursively search for the lowest common ancestor in the left and right subtrees. If both nodes are found in the subtrees, then the current node is the lowest common ancestor. If only one node is found, we return that node. If neither node is found, we return None. This solution has a time complexity of O(N), where N is the number of nodes in the binary search tree. The space complexity is O(N) as well, due to the recursive calls on the stack.", "cleaned_response": "\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':\n        # Base case: if the root is null or one of the nodes is equal to the root, return the root\n        if not root or root == p or root == q:\n            return root\n        \n        # Recursively search for the lowest common ancestor in the left and right subtrees\n        left = self.lowestCommonAncestor(root.left, p, q)\n        right = self.lowestCommonAncestor(root.right, p, q)\n        \n        # If both nodes are found in the left and right subtrees, return the root\n        if left and right:\n            return root\n        \n        # If only one node is found, return that node\n        if left:\n            return left\n        if right:\n            return right\n        \n        # If neither node is found, return None\n        return None\n", "n_pass": 1, "difficulty": 2.0, "frontend_question_id": 235.0, "loc": 210}
{"task_input": "\nLeetCode Problem #239\nTitle: Sliding Window Maximum\nDescription:\nYou are given an array of integers nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position. Return the max sliding window. Example 1: Input: nums = [1, 3, -1, -3, 5, 3, 6, 7], k = 3 Output: [3, 3, 5, 5, 6, 7] Explanation: Window position Max --------------- ----- [1^3 -1] -3^5 3^6 7^3 1 [3 -1 -3] 5^3 6^7 3^1 3 [-1 -3^5] 3^6 7^5 1^3 -1 [-3^5 3] 6^7 5^1 3 -1 -3 [5^3 6] 7^6 1^3 -1 -3^5 [3^6 7] 7 Example 2: Input: nums = [1], k = 1 Output: [1] Constraints: 1 <= nums.length <= 10e5 -10e4 <= nums[i] <= 10e4 1 <= k <= nums.length\n", "code_prompt": "class Solution:\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\n        ", "raw_response": "```python\nfrom typing import List\n\nclass Solution:\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\n        result = []\n        window = []\n        \n        for i in range(len(nums)):\n            # Remove elements outside the current window\n            if i >= k and window[0] <= i - k:\n                window.pop(0)\n            \n            # Remove elements smaller than the current element\n            while window and nums[i] > nums[window[-1]]:\n                window.pop()\n                \n            # Add the current element to the window\n            window.append(i)\n            \n            # Add the maximum element in the current window to the result\n            if i >= k - 1:\n                result.append(nums[window[0]])\n        \n        return result\n```", "cleaned_response": "\nfrom typing import List\n\nclass Solution:\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\n        result = []\n        window = []\n        \n        for i in range(len(nums)):\n            # Remove elements outside the current window\n            if i >= k and window[0] <= i - k:\n                window.pop(0)\n            \n            # Remove elements smaller than the current element\n            while window and nums[i] > nums[window[-1]]:\n                window.pop()\n                \n            # Add the current element to the window\n            window.append(i)\n            \n            # Add the maximum element in the current window to the result\n            if i >= k - 1:\n                result.append(nums[window[0]])\n        \n        return result\n", "n_pass": 1, "difficulty": 3.0, "frontend_question_id": 239.0, "loc": 214}
{"task_input": "\nLeetCode Problem #242\nTitle: Valid Anagram\nDescription:\nGiven two strings s and t, return true if t is an anagram of s, and false otherwise. An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once. Example 1: Input: s = \"anagram\", t = \"nagaram\" Output: true Example 2: Input: s = \"rat\", t = \"car\" Output: false Constraints: 1 <= s.length, t.length <= 5 * 10e4 s and t consist of lowercase English letters. Follow up: What if the inputs contain Unicode characters? How would you adapt your solution to such a case?\n", "code_prompt": "class Solution:\n    def isAnagram(self, s: str, t: str) -> bool:\n        ", "raw_response": "class Solution:\n    def isAnagram(self, s: str, t: str) -> bool:\n        # Check if the lengths of the two strings are equal\n        if len(s) != len(t):\n            return False\n        \n        # Create two dictionaries to store the character frequency of each string\n        count_s = {}\n        count_t = {}\n        \n        # Count the frequency of each character in string s\n        for char in s:\n            if char in count_s:\n                count_s[char] += 1\n            else:\n                count_s[char] = 1\n        \n        # Count the frequency of each character in string t\n        for char in t:\n            if char in count_t:\n                count_t[char] += 1\n            else:\n                count_t[char] = 1\n        \n        # Compare the character frequencies in the two dictionaries\n        for char, freq in count_s.items():\n            if char not in count_t or count_t[char] != freq:\n                return False\n        \n        return True", "cleaned_response": "class Solution:\n    def isAnagram(self, s: str, t: str) -> bool:\n        # Check if the lengths of the two strings are equal\n        if len(s) != len(t):\n            return False\n        \n        # Create two dictionaries to store the character frequency of each string\n        count_s = {}\n        count_t = {}\n        \n        # Count the frequency of each character in string s\n        for char in s:\n            if char in count_s:\n                count_s[char] += 1\n            else:\n                count_s[char] = 1\n        \n        # Count the frequency of each character in string t\n        for char in t:\n            if char in count_t:\n                count_t[char] += 1\n            else:\n                count_t[char] = 1\n        \n        # Compare the character frequencies in the two dictionaries\n        for char, freq in count_s.items():\n            if char not in count_t or count_t[char] != freq:\n                return False\n        \n        return True", "n_pass": 1, "difficulty": 1.0, "frontend_question_id": 242.0, "loc": 217}
{"task_input": "\nLeetCode Problem #260\nTitle: Single Number III\nDescription:\nGiven an integer array nums, in which exactly two elements appear only once and all the other elements appear exactly twice. Find the two elements that appear only once. You can return the answer in any order. You must write an algorithm that runs in linear runtime complexity and uses only constant extra space. Example 1: Input: nums = [1, 2, 1, 3, 2, 5] Output: [3, 5] Explanation: [5, 3] is also a valid answer. Example 2: Input: nums = [-1, 0] Output: [-1, 0] Example 3: Input: nums = [0, 1] Output: [1, 0] Constraints: 2 <= nums.length <= 3 * 10e4 -2^31 <= nums[i] <= 2^31 - 1 Each integer in nums will appear twice, only two integers will appear once.\n", "code_prompt": "class Solution:\n    def singleNumber(self, nums: List[int]) -> List[int]:\n        ", "raw_response": "```python\nclass Solution:\n    def singleNumber(self, nums: List[int]) -> List[int]:\n        # Step 1: Find the XOR of all elements in nums\n        xor = 0\n        for num in nums:\n            xor ^= num\n        \n        # Step 2: Find the rightmost set bit in xor\n        rightmost_set_bit = xor & (-xor)\n        \n        # Step 3: Divide the numbers in nums into two groups based on the rightmost set bit\n        group1 = group2 = 0\n        for num in nums:\n            if num & rightmost_set_bit:\n                group1 ^= num\n            else:\n                group2 ^= num\n        \n        # Step 4: Return the two numbers that appear only once\n        return [group1, group2]\n```", "cleaned_response": "\nclass Solution:\n    def singleNumber(self, nums: List[int]) -> List[int]:\n        # Step 1: Find the XOR of all elements in nums\n        xor = 0\n        for num in nums:\n            xor ^= num\n        \n        # Step 2: Find the rightmost set bit in xor\n        rightmost_set_bit = xor & (-xor)\n        \n        # Step 3: Divide the numbers in nums into two groups based on the rightmost set bit\n        group1 = group2 = 0\n        for num in nums:\n            if num & rightmost_set_bit:\n                group1 ^= num\n            else:\n                group2 ^= num\n        \n        # Step 4: Return the two numbers that appear only once\n        return [group1, group2]\n", "n_pass": 1, "difficulty": 2.0, "frontend_question_id": 260.0, "loc": 220}
{"task_input": "\nLeetCode Problem #264\nTitle: Ugly Number II\nDescription:\nAn ugly number is a positive integer whose prime factors are limited to 2, 3, and 5. Given an integer n, return the n th ugly number. Example 1: Input: n = 10 Output: 12 Explanation: [1, 2, 3, 4, 5, 6, 8, 9, 10, 12] is the sequence of the first 10 ugly numbers. Example 2: Input: n = 1 Output: 1 Explanation: 1 has no prime factors, therefore all of its prime factors are limited to 2, 3, and 5. Constraints: 1 <= n <= 1690\n", "code_prompt": "class Solution:\n    def nthUglyNumber(self, n: int) -> int:\n        ", "raw_response": "```python\nclass Solution:\n    def nthUglyNumber(self, n: int) -> int:\n        ugly_nums = [1]  # Initialize with the first ugly number\n        \n        # Pointers for each prime factor\n        p2 = p3 = p5 = 0\n        \n        while len(ugly_nums) < n:\n            # Calculate the next ugly number by multiplying with the prime factors\n            next_num = min(ugly_nums[p2] * 2, ugly_nums[p3] * 3, ugly_nums[p5] * 5)\n            \n            # Move the pointers for the prime factors accordingly\n            if next_num == ugly_nums[p2] * 2:\n                p2 += 1\n            if next_num == ugly_nums[p3] * 3:\n                p3 += 1\n            if next_num == ugly_nums[p5] * 5:\n                p5 += 1\n            \n            # Add the next ugly number to the list\n            ugly_nums.append(next_num)\n        \n        return ugly_nums[-1]\n```\n\nThe above code defines a class Solution with a method nthUglyNumber that takes an integer n as input and returns the nth ugly number. The method solves the problem by using a dynamic programming approach.\n\nThe algorithm initializes the list ugly_nums with the first ugly number, which is 1. It also initializes three pointers, p2, p3, and p5, which will be used to keep track of the current indices for multiplying with the prime factors 2, 3, and 5.\n\nThe algorithm then enters a while loop which continues until the length of ugly_nums is equal to n. Inside the loop, the algorithm calculates the next ugly number by multiplying each of the prime factors with the corresponding number at the respective pointer indices. The minimum of these three products is then selected as the next ugly number.\n\nAfter calculating the next ugly number, the algorithm moves the pointers accordingly if the next ugly number matches the product of a prime factor. This ensures that each prime factor is multiplied with the correct number for generating the next ugly number.\n\nFinally, the algorithm appends the next ugly number to the list ugly_nums. When the loop finishes, the algorithm returns the last element of ugly_nums, which is the nth ugly number.\n\nThe time complexity of this algorithm is O(n) because we need to generate n ugly numbers. The space complexity is also O(n) because we need to store the ugly numbers in a list.", "cleaned_response": "\nclass Solution:\n    def nthUglyNumber(self, n: int) -> int:\n        ugly_nums = [1]  # Initialize with the first ugly number\n        \n        # Pointers for each prime factor\n        p2 = p3 = p5 = 0\n        \n        while len(ugly_nums) < n:\n            # Calculate the next ugly number by multiplying with the prime factors\n            next_num = min(ugly_nums[p2] * 2, ugly_nums[p3] * 3, ugly_nums[p5] * 5)\n            \n            # Move the pointers for the prime factors accordingly\n            if next_num == ugly_nums[p2] * 2:\n                p2 += 1\n            if next_num == ugly_nums[p3] * 3:\n                p3 += 1\n            if next_num == ugly_nums[p5] * 5:\n                p5 += 1\n            \n            # Add the next ugly number to the list\n            ugly_nums.append(next_num)\n        \n        return ugly_nums[-1]\n", "n_pass": 1, "difficulty": 2.0, "frontend_question_id": 264.0, "loc": 222}
{"task_input": "\nLeetCode Problem #268\nTitle: Missing Number\nDescription:\nGiven an array nums containing n distinct numbers in the range [0, n], return the only number in the range that is missing from the array. Example 1: Input: nums = [3, 0, 1] Output: 2 Explanation: n = 3 since there are 3 numbers, so all numbers are in the range [0, 3]. 2 is the missing number in the range since it does not appear in nums. Example 2: Input: nums = [0, 1] Output: 2 Explanation: n = 2 since there are 2 numbers, so all numbers are in the range [0, 2]. 2 is the missing number in the range since it does not appear in nums. Example 3: Input: nums = [9, 6, 4, 2, 3, 5, 7, 0, 1] Output: 8 Explanation: n = 9 since there are 9 numbers, so all numbers are in the range [0, 9]. 8 is the missing number in the range since it does not appear in nums. Constraints: n == nums.length 1 <= n <= 10e4 0 <= nums[i] <= n All the numbers of nums are unique. Follow up: Could you implement a solution using only O(1) extra space complexity and O(n) runtime complexity?\n", "code_prompt": "class Solution:\n    def missingNumber(self, nums: List[int]) -> int:\n        ", "raw_response": "```python\nfrom typing import List\n\nclass Solution:\n    def missingNumber(self, nums: List[int]) -> int:\n        n = len(nums)\n        expected_sum = (n * (n + 1)) // 2\n        actual_sum = sum(nums)\n        \n        return expected_sum - actual_sum\n```", "cleaned_response": "\nfrom typing import List\n\nclass Solution:\n    def missingNumber(self, nums: List[int]) -> int:\n        n = len(nums)\n        expected_sum = (n * (n + 1)) // 2\n        actual_sum = sum(nums)\n        \n        return expected_sum - actual_sum\n", "n_pass": 1, "difficulty": 1.0, "frontend_question_id": 268.0, "loc": 223}
{"task_input": "\nLeetCode Problem #273\nTitle: Integer to English Words\nDescription:\nConvert a non-negative integer num to its English words representation. Example 1: Input: num = 123 Output: \"One Hundred Twenty Three\" Example 2: Input: num = 12345 Output: \"Twelve Thousand Three Hundred Forty Five\" Example 3: Input: num = 1234567 Output: \"One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven\" Constraints: 0 <= num <= 2^31 - 1\n", "code_prompt": "class Solution:\n    def numberToWords(self, num: int) -> str:\n        ", "raw_response": "```python\nclass Solution:\n    def __init__(self):\n        self.less_than_20 = [\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\", \"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"]\n        self.tens = [\"\", \"Ten\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"]\n        self.thousands = [\"\", \"Thousand\", \"Million\", \"Billion\"]\n    \n    def numberToWords(self, num: int) -> str:\n        if num == 0:\n            return \"Zero\"\n        result = \"\"\n        i = 0\n        while num > 0:\n            if num % 1000 != 0:\n                result = self.helper(num % 1000) + self.thousands[i] + \" \" + result\n            num //= 1000\n            i += 1\n        return result.strip()\n    \n    def helper(self, num: int) -> str:\n        if num == 0:\n            return \"\"\n        elif num < 20:\n            return self.less_than_20[num] + \" \"\n        elif num < 100:\n            return self.tens[num // 10] + \" \" + self.helper(num % 10)\n        else:\n            return self.less_than_20[num // 100] + \" Hundred \" + self.helper(num % 100)\n```", "cleaned_response": "\nclass Solution:\n    def __init__(self):\n        self.less_than_20 = [\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\", \"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"]\n        self.tens = [\"\", \"Ten\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"]\n        self.thousands = [\"\", \"Thousand\", \"Million\", \"Billion\"]\n    \n    def numberToWords(self, num: int) -> str:\n        if num == 0:\n            return \"Zero\"\n        result = \"\"\n        i = 0\n        while num > 0:\n            if num % 1000 != 0:\n                result = self.helper(num % 1000) + self.thousands[i] + \" \" + result\n            num //= 1000\n            i += 1\n        return result.strip()\n    \n    def helper(self, num: int) -> str:\n        if num == 0:\n            return \"\"\n        elif num < 20:\n            return self.less_than_20[num] + \" \"\n        elif num < 100:\n            return self.tens[num // 10] + \" \" + self.helper(num % 10)\n        else:\n            return self.less_than_20[num // 100] + \" Hundred \" + self.helper(num % 100)\n", "n_pass": 1, "difficulty": 3.0, "frontend_question_id": 273.0, "loc": 224}
{"task_input": "\nLeetCode Problem #274\nTitle: H-Index\nDescription:\nGiven an array of integers citations where citations[i] is the number of citations a researcher received for their i th paper, return the researcher's h-index. According to the definition of h-index on Wikipedia : The h-index is defined as the maximum value of h such that the given researcher has published at least h papers that have each been cited at least h times. Example 1: Input: citations = [3, 0, 6, 1, 5] Output: 3 Explanation: [3, 0, 6, 1, 5] means the researcher has 5 papers in total and each of them had received 3, 0, 6, 1, 5 citations respectively. Since the researcher has 3 papers with at least 3 citations each and the remaining two with no more than 3 citations each, their h-index is 3. Example 2: Input: citations = [1, 3, 1] Output: 1 Constraints: n == citations.length 1 <= n <= 5000^0 <= citations[i] <= 1000\n", "code_prompt": "class Solution:\n    def hIndex(self, citations: List[int]) -> int:\n        ", "raw_response": "```python\nclass Solution:\n    def hIndex(self, citations: List[int]) -> int:\n        # Sort the citations array in descending order\n        citations.sort(reverse=True)\n        \n        n = len(citations)\n        h = 0\n        \n        # Iterate through the sorted array\n        for i in range(n):\n            # Check if the current citation is greater than or equal to the current index (i+1)\n            if citations[i] >= i+1:\n                h = i+1\n            else:\n                # If the current citation is less than the current index, there is no need to continue the loop\n                break\n        \n        return h\n```\n\nThe above code sorts the `citations` array in descending order and then iterates through it. For each element, it checks if the citation is greater than or equal to the current index (i+1). If it is, it updates the h-index to the current index. If it's not, it breaks out of the loop. At the end, it returns the h-index. This solution has a time complexity of O(nlogn) due to the sorting operation.", "cleaned_response": "\nclass Solution:\n    def hIndex(self, citations: List[int]) -> int:\n        # Sort the citations array in descending order\n        citations.sort(reverse=True)\n        \n        n = len(citations)\n        h = 0\n        \n        # Iterate through the sorted array\n        for i in range(n):\n            # Check if the current citation is greater than or equal to the current index (i+1)\n            if citations[i] >= i+1:\n                h = i+1\n            else:\n                # If the current citation is less than the current index, there is no need to continue the loop\n                break\n        \n        return h\n", "n_pass": 1, "difficulty": 2.0, "frontend_question_id": 274.0, "loc": 225}
{"task_input": "\nLeetCode Problem #279\nTitle: Perfect Squares\nDescription:\nGiven an integer n, return the least number of perfect square numbers that sum to n. A perfect square is an integer that is the square of an integer; in other words, it is the product of some integer with itself. For example, 1, 4, 9, and 16 are perfect squares while 3 and 11 are not. Example 1: Input: n = 12 Output: 3 Explanation: 12 = 4 + 4 + 4. Example 2: Input: n = 13 Output: 2 Explanation: 13 = 4 + 9. Constraints: 1 <= n <= 10e4\n", "code_prompt": "class Solution:\n    def numSquares(self, n: int) -> int:\n        ", "raw_response": "```python\nclass Solution:\n    def numSquares(self, n: int) -> int:\n        # Create a list to store the minimum number of perfect squares needed to sum up to each number from 0 to n\n        dp = [float('inf')] * (n + 1)\n        \n        # By definition, it only takes 0 perfect squares to sum up to 0\n        dp[0] = 0\n        \n        # Iterate through all numbers from 1 to n\n        for i in range(1, n + 1):\n            # Find the minimum number of perfect squares needed to sum up to i\n            j = 1\n            while j * j <= i:\n                # Update dp[i] by taking the minimum between its current value and dp[i - j*j] + 1\n                dp[i] = min(dp[i], dp[i - j*j] + 1)\n                j += 1\n        \n        # Return the minimum number of perfect squares needed to sum up to n\n        return dp[n]\n```\n\nThe time complexity of this solution is O(n * sqrt(n)), where n is the given input number. We iterate through all numbers from 1 to n, and for each number, we iterate through all possible perfect squares (up to sqrt(n)).", "cleaned_response": "\nclass Solution:\n    def numSquares(self, n: int) -> int:\n        # Create a list to store the minimum number of perfect squares needed to sum up to each number from 0 to n\n        dp = [float('inf')] * (n + 1)\n        \n        # By definition, it only takes 0 perfect squares to sum up to 0\n        dp[0] = 0\n        \n        # Iterate through all numbers from 1 to n\n        for i in range(1, n + 1):\n            # Find the minimum number of perfect squares needed to sum up to i\n            j = 1\n            while j * j <= i:\n                # Update dp[i] by taking the minimum between its current value and dp[i - j*j] + 1\n                dp[i] = min(dp[i], dp[i - j*j] + 1)\n                j += 1\n        \n        # Return the minimum number of perfect squares needed to sum up to n\n        return dp[n]\n", "n_pass": 1, "difficulty": 2.0, "frontend_question_id": 279.0, "loc": 228}
{"task_input": "\nLeetCode Problem #282\nTitle: Expression Add Operators\nDescription:\nGiven a string num that contains only digits and an integer target, return all possibilities to insert the binary operators '+', '-', and/or '*' between the digits of num so that the resultant expression evaluates to the target value. Note that operands in the returned expressions should not contain leading zeros. Example 1: Input: num = \"123\", target = 6 Output: [\"12.3.\", \"1+2+3\"] Explanation: Both \"12.3.\" and \"1+2+3\" evaluate to 6. Example 2: Input: num = \"232\", target = 8 Output: [\"23.+2\", \"2+32.\"] Explanation: Both \"23.+2\" and \"2+32.\" evaluate to 8. Example 3: Input: num = \"3456237490\", target = 9191 Output: [] Explanation: There are no expressions that can be created from \"3456237490\" to evaluate to 9191. Constraints: 1 <= num.length <= 10 num consists of only digits. -2^31 <= target <= 2^31 - 1\n", "code_prompt": "class Solution:\n    def addOperators(self, num: str, target: int) -> List[str]:\n        ", "raw_response": "```python\nfrom typing import List\n\nclass Solution:\n    def addOperators(self, num: str, target: int) -> List[str]:\n        result = []\n        self.dfs(num, target, 0, 0, 0, \"\", result)\n        return result\n    \n    def dfs(self, num, target, index, calc, tail, expr, result):\n        if index == len(num):\n            if calc == target:\n                result.append(expr)\n            return\n        \n        for i in range(index, len(num)):\n            if num[index] == '0' and i != index:\n                break\n            \n            curr = int(num[index:i+1])\n            \n            if index == 0:\n                self.dfs(num, target, i+1, curr, curr, expr+str(curr), result)\n            else:\n                self.dfs(num, target, i+1, calc+curr, curr, expr+\"+\"+str(curr), result)\n                \n                self.dfs(num, target, i+1, calc-curr, -curr, expr+\"-\"+str(curr), result)\n                \n                self.dfs(num, target, i+1, calc-tail+tail*curr, tail*curr, expr+\"*\"+str(curr), result)\n```\n\nThe solution uses backtracking to generate all possible expressions by inserting operators between the digits. We keep track of calculations, the accumulated value, and the tail value (the value that needs to be multiplied in case of multiplication operator). We iterate through the string and recursively explore different combinations, adding operators and updating the calculation. If the calculation is equal to the target, we add the expression to the result list.", "cleaned_response": "\nfrom typing import List\n\nclass Solution:\n    def addOperators(self, num: str, target: int) -> List[str]:\n        result = []\n        self.dfs(num, target, 0, 0, 0, \"\", result)\n        return result\n    \n    def dfs(self, num, target, index, calc, tail, expr, result):\n        if index == len(num):\n            if calc == target:\n                result.append(expr)\n            return\n        \n        for i in range(index, len(num)):\n            if num[index] == '0' and i != index:\n                break\n            \n            curr = int(num[index:i+1])\n            \n            if index == 0:\n                self.dfs(num, target, i+1, curr, curr, expr+str(curr), result)\n            else:\n                self.dfs(num, target, i+1, calc+curr, curr, expr+\"+\"+str(curr), result)\n                \n                self.dfs(num, target, i+1, calc-curr, -curr, expr+\"-\"+str(curr), result)\n                \n                self.dfs(num, target, i+1, calc-tail+tail*curr, tail*curr, expr+\"*\"+str(curr), result)\n", "n_pass": 1, "difficulty": 3.0, "frontend_question_id": 282.0, "loc": 229}
{"task_input": "\nLeetCode Problem #287\nTitle: Find the Duplicate Number\nDescription:\nGiven an array of integers nums containing n + 1 integers where each integer is in the range [1, n] inclusive. There is only one repeated number in nums, return this repeated number. You must solve the problem without modifying the array nums and uses only constant extra space. Example 1: Input: nums = [1, 3, 4, 2, 2] Output: 2 Example 2: Input: nums = [3, 1, 3, 4, 2] Output: 3 Constraints: 1 <= n <= 10e5 nums.length == n + 1^1 <= nums[i] <= n All the integers in nums appear only once except for precisely one integer which appears two or more times. Follow up: How can we prove that at least one duplicate number must exist in nums ? Can you solve the problem in linear runtime complexity?\n", "code_prompt": "class Solution:\n    def findDuplicate(self, nums: List[int]) -> int:\n        ", "raw_response": "```python\nfrom typing import List\n\nclass Solution:\n    def findDuplicate(self, nums: List[int]) -> int:\n        \"\"\"\n        Function to find the duplicate number in an array of integers.\n        \n        Parameters:\n            nums (List[int]): The input array of integers.\n            \n        Returns:\n            int: The duplicate number in the array.\n        \"\"\"\n        \n        # Perform binary search on the range of numbers\n        low = 1\n        high = len(nums) - 1\n        \n        while low < high:\n            mid = low + (high - low) // 2\n            count = 0\n            \n            # Count the numbers less than or equal to mid\n            for num in nums:\n                if num <= mid:\n                    count += 1\n            \n            # Duplicate number is in the range [low, mid]\n            if count > mid:\n                high = mid\n            \n            # Duplicate number is in the range [mid + 1, high]\n            else:\n                low = mid + 1\n        \n        # Return the duplicate number\n        return low\n```\n\nThe algorithm uses binary search to find the duplicate number in the array. It starts by setting the initial range from 1 to n (where n is the length of the array). Then, it counts the number of elements in the array that are less than or equal to the middle element of the range. If the count is greater than the middle element, then the duplicate number must be in the lower half of the range. Otherwise, it must be in the upper half of the range. This process is repeated until the range is reduced to a single element, which is the duplicate number. The algorithm has a time complexity of O(n log n) and uses constant extra space.", "cleaned_response": "\nfrom typing import List\n\nclass Solution:\n    def findDuplicate(self, nums: List[int]) -> int:\n        \"\"\"\n        Function to find the duplicate number in an array of integers.\n        \n        Parameters:\n            nums (List[int]): The input array of integers.\n            \n        Returns:\n            int: The duplicate number in the array.\n        \"\"\"\n        \n        # Perform binary search on the range of numbers\n        low = 1\n        high = len(nums) - 1\n        \n        while low < high:\n            mid = low + (high - low) // 2\n            count = 0\n            \n            # Count the numbers less than or equal to mid\n            for num in nums:\n                if num <= mid:\n                    count += 1\n            \n            # Duplicate number is in the range [low, mid]\n            if count > mid:\n                high = mid\n            \n            # Duplicate number is in the range [mid + 1, high]\n            else:\n                low = mid + 1\n        \n        # Return the duplicate number\n        return low\n", "n_pass": 1, "difficulty": 2.0, "frontend_question_id": 287.0, "loc": 232}
{"task_input": "\nLeetCode Problem #290\nTitle: Word Pattern\nDescription:\nGiven a pattern and a string s, find if s follows the same pattern. Here follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in s. Example 1: Input: pattern = \"abba\", s = \"dog cat cat dog\" Output: true Example 2: Input: pattern = \"abba\", s = \"dog cat cat fish\" Output: false Example 3: Input: pattern = \"aaaa\", s = \"dog cat cat dog\" Output: false Constraints: 1 <= pattern.length <= 300 pattern contains only lower-case English letters. 1 <= s.length <= 3000 s contains only lowercase English letters and spaces ' '. s does not contain any leading or trailing spaces. All the words in s are separated by a single space.\n", "code_prompt": "class Solution:\n    def wordPattern(self, pattern: str, s: str) -> bool:\n        ", "raw_response": "```python\nclass Solution:\n    def wordPattern(self, pattern: str, s: str) -> bool:\n        words = s.split()\n        if len(pattern) != len(words):\n            return False\n        \n        pattern_map = {} # stores mapping of characters in pattern to words in s\n        word_map = {} # stores mapping of words in s to characters in pattern\n        \n        for i in range(len(pattern)):\n            if pattern[i] not in pattern_map:\n                # if character in pattern is not mapped to any word yet\n                if words[i] in word_map:\n                    # if word is already mapped to a character in pattern\n                    return False\n                # create mapping of character to word and word to character\n                pattern_map[pattern[i]] = words[i]\n                word_map[words[i]] = pattern[i]\n            else:\n                # if character in pattern is already mapped to a word\n                if pattern_map[pattern[i]] != words[i]:\n                    return False\n                \n        return True\n```\nI would now test my solution with the provided test cases to see if it passes all of them.", "cleaned_response": "\nclass Solution:\n    def wordPattern(self, pattern: str, s: str) -> bool:\n        words = s.split()\n        if len(pattern) != len(words):\n            return False\n        \n        pattern_map = {} # stores mapping of characters in pattern to words in s\n        word_map = {} # stores mapping of words in s to characters in pattern\n        \n        for i in range(len(pattern)):\n            if pattern[i] not in pattern_map:\n                # if character in pattern is not mapped to any word yet\n                if words[i] in word_map:\n                    # if word is already mapped to a character in pattern\n                    return False\n                # create mapping of character to word and word to character\n                pattern_map[pattern[i]] = words[i]\n                word_map[words[i]] = pattern[i]\n            else:\n                # if character in pattern is already mapped to a word\n                if pattern_map[pattern[i]] != words[i]:\n                    return False\n                \n        return True\n", "n_pass": 1, "difficulty": 1.0, "frontend_question_id": 290.0, "loc": 234}
{"task_input": "\nLeetCode Problem #295\nTitle: Find Median from Data Stream\nDescription:\nThe median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value, and the median is the mean of the two middle values. For example, for arr = [2, 3, 4], the median is 3. For example, for arr = [2, 3], the median is (2 + 3) / 2 = 2. 5. Implement the MedianFinder class: MedianFinder() initializes the MedianFinder object. void addNum(int num) adds the integer num from the data stream to the data structure. double findMedian() returns the median of all elements so far. Answers within 10 -5 of the actual answer will be accepted. Example 1: Input [\"MedianFinder\", \"addNum\", \"addNum\", \"findMedian\", \"addNum\", \"findMedian\"] [[], [1], [2], [], [3], []] Output [null, null, null, 1. 5, null, 2. 0] Explanation MedianFinder medianFinder = new MedianFinder(); medianFinder. addNum(1); // arr = [1] medianFinder. addNum(2); // arr = [1, 2] medianFinder. findMedian(); // return 1. 5 (i. e. , (1 + 2) / 2) medianFinder. addNum(3); // arr[1, 2, 3] medianFinder. findMedian(); // return 2. 0 Constraints: -10e5 <= num <= 10e5 There will be at least one element in the data structure before calling findMedian. At most 5 * 10e4 calls will be made to addNum and findMedian. Follow up: If all integer numbers from the stream are in the range [0, 100], how would you optimize your solution? If 99% of all integer numbers from the stream are in the range [0, 100], how would you optimize your solution?\n", "code_prompt": "class MedianFinder:\n\n    def __init__(self):\n        \n\n    def addNum(self, num: int) -> None:\n        \n\n    def findMedian(self) -> float:\n        \n\n\n# Your MedianFinder object will be instantiated and called as such:\n# obj = MedianFinder()\n# obj.addNum(num)\n# param_2 = obj.findMedian()", "raw_response": "```python\nimport heapq\n\nclass MedianFinder:\n\n    def __init__(self):\n        self.small = [] # max heap for storing the smaller half of the numbers\n        self.large = [] # min heap for storing the larger half of the numbers\n\n    def addNum(self, num: int) -> None:\n        if len(self.small) == len(self.large):\n            # Add the number to the small heap\n            # Negate the number to create a max heap effect\n            heapq.heappush(self.small, -num)\n            # Pop the largest number from small heap and add it to the large heap\n            largest_small = -heapq.heappop(self.small)\n            heapq.heappush(self.large, largest_small)\n        else:\n            # Add the number to the large heap\n            heapq.heappush(self.large, num)\n            # Pop the smallest number from large heap and add it to the small heap\n            smallest_large = heapq.heappop(self.large)\n            heapq.heappush(self.small, -smallest_large)\n\n    def findMedian(self) -> float:\n        if len(self.small) == len(self.large):\n            # If both heaps have equal size, take the average of the top numbers\n            largest_small = -self.small[0]\n            smallest_large = self.large[0]\n            return (largest_small + smallest_large) / 2\n        else:\n            # If the heaps have different sizes, the median is the top of the large heap\n            return self.large[0]\n\n\n# Your MedianFinder object will be instantiated and called as such:\n# obj = MedianFinder()\n# obj.addNum(num)\n# param_2 = obj.findMedian()\n```", "cleaned_response": "\nimport heapq\n\nclass MedianFinder:\n\n    def __init__(self):\n        self.small = [] # max heap for storing the smaller half of the numbers\n        self.large = [] # min heap for storing the larger half of the numbers\n\n    def addNum(self, num: int) -> None:\n        if len(self.small) == len(self.large):\n            # Add the number to the small heap\n            # Negate the number to create a max heap effect\n            heapq.heappush(self.small, -num)\n            # Pop the largest number from small heap and add it to the large heap\n            largest_small = -heapq.heappop(self.small)\n            heapq.heappush(self.large, largest_small)\n        else:\n            # Add the number to the large heap\n            heapq.heappush(self.large, num)\n            # Pop the smallest number from large heap and add it to the small heap\n            smallest_large = heapq.heappop(self.large)\n            heapq.heappush(self.small, -smallest_large)\n\n    def findMedian(self) -> float:\n        if len(self.small) == len(self.large):\n            # If both heaps have equal size, take the average of the top numbers\n            largest_small = -self.small[0]\n            smallest_large = self.large[0]\n            return (largest_small + smallest_large) / 2\n        else:\n            # If the heaps have different sizes, the median is the top of the large heap\n            return self.large[0]\n\n\n# Your MedianFinder object will be instantiated and called as such:\n# obj = MedianFinder()\n# obj.addNum(num)\n# param_2 = obj.findMedian()\n", "n_pass": 1, "difficulty": 3.0, "frontend_question_id": 295.0, "loc": 236}
{"task_input": "\nLeetCode Problem #297\nTitle: Serialize and Deserialize Binary Tree\nDescription:\nSerialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment. Design an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure. Clarification: The input/output format is the same as how LeetCode serializes a binary tree. You do not necessarily need to follow this format, so please be creative and come up with different approaches yourself. Example 1: Input: root = [1, 2, 3, null, null, 4, 5] Output: [1, 2, 3, null, null, 4, 5] Example 2: Input: root = [] Output: [] Constraints: The number of nodes in the tree is in the range [0, 10e4 ]. -1000 <= Node. val <= 1000\n", "code_prompt": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Codec:\n\n    def serialize(self, root):\n        \"\"\"Encodes a tree to a single string.\n        \n        :type root: TreeNode\n        :rtype: str\n        \"\"\"\n        \n\n    def deserialize(self, data):\n        \"\"\"Decodes your encoded data to tree.\n        \n        :type data: str\n        :rtype: TreeNode\n        \"\"\"\n        \n\n# Your Codec object will be instantiated and called as such:\n# ser = Codec()\n# deser = Codec()\n# ans = deser.deserialize(ser.serialize(root))", "raw_response": "```python\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Codec:\n\n    def serialize(self, root):\n        \"\"\"Encodes a tree to a single string.\n        \n        :type root: TreeNode\n        :rtype: str\n        \"\"\"\n        if not root:\n            return \"\"\n        queue = [root]\n        result = []\n        while queue:\n            node = queue.pop(0)\n            if node:\n                result.append(str(node.val))\n                queue.append(node.left)\n                queue.append(node.right)\n            else:\n                result.append(\"null\")\n        return \",\".join(result)\n        \n\n    def deserialize(self, data):\n        \"\"\"Decodes your encoded data to tree.\n        \n        :type data: str\n        :rtype: TreeNode\n        \"\"\"\n        if not data:\n            return None\n        data = data.split(\",\")\n        root = TreeNode(int(data[0]))\n        queue = [root]\n        i = 1\n        while queue:\n            node = queue.pop(0)\n            if data[i] != \"null\":\n                left = TreeNode(int(data[i]))\n                node.left = left\n                queue.append(left)\n            i += 1\n            if data[i] != \"null\":\n                right = TreeNode(int(data[i]))\n                node.right = right\n                queue.append(right)\n            i += 1\n        return root\n\n# Your Codec object will be instantiated and called as such:\n# ser = Codec()\n# deser = Codec()\n# ans = deser.deserialize(ser.serialize(root))\n```", "cleaned_response": "\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Codec:\n\n    def serialize(self, root):\n        \"\"\"Encodes a tree to a single string.\n        \n        :type root: TreeNode\n        :rtype: str\n        \"\"\"\n        if not root:\n            return \"\"\n        queue = [root]\n        result = []\n        while queue:\n            node = queue.pop(0)\n            if node:\n                result.append(str(node.val))\n                queue.append(node.left)\n                queue.append(node.right)\n            else:\n                result.append(\"null\")\n        return \",\".join(result)\n        \n\n    def deserialize(self, data):\n        \"\"\"Decodes your encoded data to tree.\n        \n        :type data: str\n        :rtype: TreeNode\n        \"\"\"\n        if not data:\n            return None\n        data = data.split(\",\")\n        root = TreeNode(int(data[0]))\n        queue = [root]\n        i = 1\n        while queue:\n            node = queue.pop(0)\n            if data[i] != \"null\":\n                left = TreeNode(int(data[i]))\n                node.left = left\n                queue.append(left)\n            i += 1\n            if data[i] != \"null\":\n                right = TreeNode(int(data[i]))\n                node.right = right\n                queue.append(right)\n            i += 1\n        return root\n\n# Your Codec object will be instantiated and called as such:\n# ser = Codec()\n# deser = Codec()\n# ans = deser.deserialize(ser.serialize(root))\n", "n_pass": 1, "difficulty": 3.0, "frontend_question_id": 297.0, "loc": 237}
{"task_input": "\nLeetCode Problem #299\nTitle: Bulls and Cows\nDescription:\nYou are playing the Bulls and Cows game with your friend. You write down a secret number and ask your friend to guess what the number is. When your friend makes a guess, you provide a hint with the following info: The number of \"bulls\", which are digits in the guess that are in the correct position. The number of \"cows\", which are digits in the guess that are in your secret number but are located in the wrong position. Specifically, the non-bull digits in the guess that could be rearranged such that they become bulls. Given the secret number secret and your friend's guess guess, return the hint for your friend's guess. The hint should be formatted as \"xAyB\", where x is the number of bulls and y is the number of cows. Note that both secret and guess may contain duplicate digits. Example 1: Input: secret = \"1807\", guess = \"7810\" Output: \"1A3B\" Explanation: Bulls are connected with a '|' and cows are underlined: \"1807\" | \" 7^8 10 \" Example 2: Input: secret = \"1123\", guess = \"0111\" Output: \"1A1B\" Explanation: Bulls are connected with a '|' and cows are underlined: \"1123\" \"1123\" | or | \"01^1 1\" \"011^1 \" Note that only one of the two unmatched 1s is counted as a cow since the non-bull digits can only be rearranged to allow one 1 to be a bull. Constraints: 1 <= secret.length, guess.length <= 1000 secret.length == guess.length secret and guess consist of digits only.\n", "code_prompt": "class Solution:\n    def getHint(self, secret: str, guess: str) -> str:\n        ", "raw_response": "```python\nclass Solution:\n    def getHint(self, secret: str, guess: str) -> str:\n        bulls = 0\n        cows = 0\n\n        secret_count = [0] * 10\n        guess_count = [0] * 10\n\n        for i in range(len(secret)):\n            if secret[i] == guess[i]:\n                bulls += 1\n            else:\n                secret_count[int(secret[i])] += 1\n                guess_count[int(guess[i])] += 1\n\n        for i in range(10):\n            cows += min(secret_count[i], guess_count[i])\n\n        return str(bulls) + \"A\" + str(cows) + \"B\"\n```", "cleaned_response": "\nclass Solution:\n    def getHint(self, secret: str, guess: str) -> str:\n        bulls = 0\n        cows = 0\n\n        secret_count = [0] * 10\n        guess_count = [0] * 10\n\n        for i in range(len(secret)):\n            if secret[i] == guess[i]:\n                bulls += 1\n            else:\n                secret_count[int(secret[i])] += 1\n                guess_count[int(guess[i])] += 1\n\n        for i in range(10):\n            cows += min(secret_count[i], guess_count[i])\n\n        return str(bulls) + \"A\" + str(cows) + \"B\"\n", "n_pass": 1, "difficulty": 2.0, "frontend_question_id": 299.0, "loc": 238}
{"task_input": "\nLeetCode Problem #300\nTitle: Longest Increasing Subsequence\nDescription:\nGiven an integer array nums, return the length of the longest strictly increasing subsequence. Example 1: Input: nums = [10, 9, 2, 5, 3, 7, 101, 18] Output: 4 Explanation: The longest increasing subsequence is [2, 3, 7, 101], therefore the length is 4. Example 2: Input: nums = [0, 1, 0, 3, 2, 3] Output: 4 Example 3: Input: nums = [7, 7, 7, 7, 7, 7, 7] Output: 1 Constraints: 1 <= nums.length <= 2500 -10e4 <= nums[i] <= 10e4 Follow up: Can you come up with an algorithm that runs in O(n log(n)) time complexity?\n", "code_prompt": "class Solution:\n    def lengthOfLIS(self, nums: List[int]) -> int:\n        ", "raw_response": "```python\nfrom typing import List\n\nclass Solution:\n    def lengthOfLIS(self, nums: List[int]) -> int:\n        # Base case: If the array is empty, return 0\n        if len(nums) == 0:\n            return 0\n        \n        # Initialize a list to store the lengths of increasing subsequences\n        # The length of the longest increasing subsequence is initially 1 for each element in nums\n        dp = [1] * len(nums)\n        \n        # Iterate through each element, starting from the second element\n        for i in range(1, len(nums)):\n            # Check all previous elements to find the longest increasing subsequence\n            for j in range(i):\n                if nums[i] > nums[j]:\n                    # If nums[i] is greater than nums[j], update the length of the longest increasing subsequence of nums[i]\n                    dp[i] = max(dp[i], dp[j] + 1)\n        \n        # Return the maximum length of increasing subsequence\n        return max(dp)\n```\n\nThis algorithm iterates through each element in the input array `nums`, and for each element, it iterates through all previous elements to find the longest increasing subsequence. The `dp` array is used to store the lengths of the increasing subsequences. The time complexity of this algorithm is O(n^2), where n is the length of the input array `nums`.", "cleaned_response": "\nfrom typing import List\n\nclass Solution:\n    def lengthOfLIS(self, nums: List[int]) -> int:\n        # Base case: If the array is empty, return 0\n        if len(nums) == 0:\n            return 0\n        \n        # Initialize a list to store the lengths of increasing subsequences\n        # The length of the longest increasing subsequence is initially 1 for each element in nums\n        dp = [1] * len(nums)\n        \n        # Iterate through each element, starting from the second element\n        for i in range(1, len(nums)):\n            # Check all previous elements to find the longest increasing subsequence\n            for j in range(i):\n                if nums[i] > nums[j]:\n                    # If nums[i] is greater than nums[j], update the length of the longest increasing subsequence of nums[i]\n                    dp[i] = max(dp[i], dp[j] + 1)\n        \n        # Return the maximum length of increasing subsequence\n        return max(dp)\n", "n_pass": 1, "difficulty": 2.0, "frontend_question_id": 300.0, "loc": 239}
{"task_input": "\nLeetCode Problem #301\nTitle: Remove Invalid Parentheses\nDescription:\nGiven a string s that contains parentheses and letters, remove the minimum number of invalid parentheses to make the input string valid. Return a list of unique strings that are valid with the minimum number of removals. You may return the answer in any order. Example 1: Input: s = \"()())()\" Output: [\"(())()\", \"()()()\"] Example 2: Input: s = \"(a)())()\" Output: [\"(a())()\", \"(a)()()\"] Example 3: Input: s = \")(\" Output: [\"\"] Constraints: 1 <= s.length <= 25 s consists of lowercase English letters and parentheses '(' and ')'. There will be at most 20 parentheses in s.\n", "code_prompt": "class Solution:\n    def removeInvalidParentheses(self, s: str) -> List[str]:\n        ", "raw_response": "class Solution:\n    def removeInvalidParentheses(self, s: str) -> List[str]:\n        # Helper function to check if a string is valid\n        def isValid(s):\n            count = 0\n            for char in s:\n                if char == '(':\n                    count += 1\n                elif char == ')':\n                    count -= 1\n                    if count < 0:\n                        return False\n            return count == 0\n        \n        # Initialize variables\n        visited = set()\n        queue = [s]\n        found = False\n        result = []\n        \n        # BFS traversal\n        while queue:\n            current = queue.pop(0)\n            \n            # Check if the current string is valid\n            if isValid(current):\n                result.append(current)\n                found = True\n            \n            # If a valid string is found, we don't need to remove more characters\n            if found:\n                continue\n            \n            # Try removing each character in the current string\n            for i in range(len(current)):\n                if current[i] in ['(', ')']:\n                    new_string = current[:i] + current[i+1:]\n                    if new_string not in visited:\n                        visited.add(new_string)\n                        queue.append(new_string)\n        \n        return result", "cleaned_response": "class Solution:\n    def removeInvalidParentheses(self, s: str) -> List[str]:\n        # Helper function to check if a string is valid\n        def isValid(s):\n            count = 0\n            for char in s:\n                if char == '(':\n                    count += 1\n                elif char == ')':\n                    count -= 1\n                    if count < 0:\n                        return False\n            return count == 0\n        \n        # Initialize variables\n        visited = set()\n        queue = [s]\n        found = False\n        result = []\n        \n        # BFS traversal\n        while queue:\n            current = queue.pop(0)\n            \n            # Check if the current string is valid\n            if isValid(current):\n                result.append(current)\n                found = True\n            \n            # If a valid string is found, we don't need to remove more characters\n            if found:\n                continue\n            \n            # Try removing each character in the current string\n            for i in range(len(current)):\n                if current[i] in ['(', ')']:\n                    new_string = current[:i] + current[i+1:]\n                    if new_string not in visited:\n                        visited.add(new_string)\n                        queue.append(new_string)\n        \n        return result", "n_pass": 1, "difficulty": 3.0, "frontend_question_id": 301.0, "loc": 240}
{"task_input": "\nLeetCode Problem #304\nTitle: Range Sum Query 2D - Immutable\nDescription:\nGiven a 2D matrix matrix, handle multiple queries of the following type:...\n Calculate the sum of the elements of matrix inside the rectangle defined by its upper left corner (row1, col1) and lower right corner (row2, col2). Implement the NumMatrix class: NumMatrix(int[][] matrix) Initializes the object with the integer matrix matrix. int sumRegion(int row1, int col1, int row2, int col2) Returns the sum of the elements of matrix inside the rectangle defined by its upper left corner (row1, col1) and lower right corner (row2, col2). You must design an algorithm where sumRegion works on O(1) time complexity. Example 1: Input [\"NumMatrix\", \"sumRegion\", \"sumRegion\", \"sumRegion\"] [[[[3, 0, 1, 4, 2], [5, 6, 3, 2, 1], [1, 2, 0, 1, 5], [4, 1, 0, 1, 7], [1, 0, 3, 0, 5]]], [2, 1, 4, 3], [1, 1, 2, 2], [1, 2, 2, 4]] Output [null, 8, 11, 12] Explanation NumMatrix numMatrix = new NumMatrix([[3, 0, 1, 4, 2], [5, 6, 3, 2, 1], [1, 2, 0, 1, 5], [4, 1, 0, 1, 7], [1, 0, 3, 0, 5]]); numMatrix. sumRegion(2, 1, 4, 3); // return 8 (i. e sum of the red rectangle) numMatrix. sumRegion(1, 1, 2, 2); // return 11 (i. e sum of the green rectangle) numMatrix. sumRegion(1, 2, 2, 4); // return 12 (i. e sum of the blue rectangle) Constraints: m == matrix.length n == matrix[i].length 1 <= m, n <= 200 -10e4 <= matrix[i][j] <= 10e4 0 <= row1 <= row2 < m 0 <= col1 <= col2 < n At most 10e4 calls will be made to sumRegion.\n", "code_prompt": "class NumMatrix:\n\n    def __init__(self, matrix: List[List[int]]):\n        \n\n    def sumRegion(self, row1: int, col1: int, row2: int, col2: int) -> int:\n        \n\n\n# Your NumMatrix object will be instantiated and called as such:\n# obj = NumMatrix(matrix)\n# param_1 = obj.sumRegion(row1,col1,row2,col2)", "raw_response": "```python\nfrom typing import List\n\nclass NumMatrix:\n\n    def __init__(self, matrix: List[List[int]]):\n        if not matrix or not matrix[0]:\n            self.dp = None\n            return\n        \n        rows, cols = len(matrix), len(matrix[0])\n        self.dp = [[0] * (cols + 1) for _ in range(rows + 1)]\n        \n        for i in range(1, rows + 1):\n            for j in range(1, cols + 1):\n                self.dp[i][j] = matrix[i-1][j-1] + self.dp[i-1][j] + self.dp[i][j-1] - self.dp[i-1][j-1]\n\n    def sumRegion(self, row1: int, col1: int, row2: int, col2: int) -> int:\n        if self.dp is None:\n            return 0\n        \n        return self.dp[row2+1][col2+1] - self.dp[row1][col2+1] - self.dp[row2+1][col1] + self.dp[row1][col1]\n\n# Your NumMatrix object will be instantiated and called as such:\n# obj = NumMatrix(matrix)\n# param_1 = obj.sumRegion(row1,col1,row2,col2)\n```", "cleaned_response": "\nfrom typing import List\n\nclass NumMatrix:\n\n    def __init__(self, matrix: List[List[int]]):\n        if not matrix or not matrix[0]:\n            self.dp = None\n            return\n        \n        rows, cols = len(matrix), len(matrix[0])\n        self.dp = [[0] * (cols + 1) for _ in range(rows + 1)]\n        \n        for i in range(1, rows + 1):\n            for j in range(1, cols + 1):\n                self.dp[i][j] = matrix[i-1][j-1] + self.dp[i-1][j] + self.dp[i][j-1] - self.dp[i-1][j-1]\n\n    def sumRegion(self, row1: int, col1: int, row2: int, col2: int) -> int:\n        if self.dp is None:\n            return 0\n        \n        return self.dp[row2+1][col2+1] - self.dp[row1][col2+1] - self.dp[row2+1][col1] + self.dp[row1][col1]\n\n# Your NumMatrix object will be instantiated and called as such:\n# obj = NumMatrix(matrix)\n# param_1 = obj.sumRegion(row1,col1,row2,col2)\n", "n_pass": 1, "difficulty": 2.0, "frontend_question_id": 304.0, "loc": 242}
{"task_input": "\nLeetCode Problem #309\nTitle: Best Time to Buy and Sell Stock with Cooldown\nDescription:\nYou are given an array prices where prices[i] is the price of a given stock on the i th day. Find the maximum profit you can achieve. You may complete as many transactions as you like (i. e. , buy one and sell one share of the stock multiple times) with the following restrictions: After you sell your stock, you cannot buy stock on the next day (i. e. , cooldown one day). Note: You may not engage in multiple transactions simultaneously (i. e. , you must sell the stock before you buy again). Example 1: Input: prices = [1, 2, 3, 0, 2] Output: 3 Explanation: transactions = [buy, sell, cooldown, buy, sell] Example 2: Input: prices = [1] Output: 0 Constraints: 1 <= prices.length <= 5000^0 <= prices[i] <= 1000\n", "code_prompt": "class Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        ", "raw_response": "```python\nfrom typing import List\n\nclass Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        n = len(prices)\n        if n <= 1:\n            return 0\n        \n        # Initialize two lists to store the maximum profit of holding the stock and not holding the stock\n        hold_stock = [0] * n\n        not_hold_stock = [0] * n\n        \n        # Base cases\n        hold_stock[0] = -prices[0]\n        not_hold_stock[0] = 0\n        hold_stock[1] = max(hold_stock[0], -prices[1])\n        not_hold_stock[1] = max(not_hold_stock[0], hold_stock[0] + prices[1])\n        \n        for i in range(2, n):\n            # We have three options for every day: buy the stock, sell the stock, or do nothing (cooldown)\n            hold_stock[i] = max(hold_stock[i-1], not_hold_stock[i-2] - prices[i])\n            not_hold_stock[i] = max(not_hold_stock[i-1], hold_stock[i-1] + prices[i])\n        \n        # The maximum profit is the last element in the not_hold_stock list\n        return not_hold_stock[-1]\n```", "cleaned_response": "\nfrom typing import List\n\nclass Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        n = len(prices)\n        if n <= 1:\n            return 0\n        \n        # Initialize two lists to store the maximum profit of holding the stock and not holding the stock\n        hold_stock = [0] * n\n        not_hold_stock = [0] * n\n        \n        # Base cases\n        hold_stock[0] = -prices[0]\n        not_hold_stock[0] = 0\n        hold_stock[1] = max(hold_stock[0], -prices[1])\n        not_hold_stock[1] = max(not_hold_stock[0], hold_stock[0] + prices[1])\n        \n        for i in range(2, n):\n            # We have three options for every day: buy the stock, sell the stock, or do nothing (cooldown)\n            hold_stock[i] = max(hold_stock[i-1], not_hold_stock[i-2] - prices[i])\n            not_hold_stock[i] = max(not_hold_stock[i-1], hold_stock[i-1] + prices[i])\n        \n        # The maximum profit is the last element in the not_hold_stock list\n        return not_hold_stock[-1]\n", "n_pass": 1, "difficulty": 2.0, "frontend_question_id": 309.0, "loc": 245}
{"task_input": "\nLeetCode Problem #312\nTitle: Burst Balloons\nDescription:\nYou are given n balloons, indexed from 0 to n - 1. Each balloon is painted with a number on it represented by an array nums. You are asked to burst all the balloons. If you burst the i th balloon, you will get nums[i - 1] * nums[i] * nums[i + 1] coins. If i - 1 or i + 1 goes out of bounds of the array, then treat it as if there is a balloon with a 1 painted on it. Return the maximum coins you can collect by bursting the balloons wisely. Example 1: Input: nums = [3, 1, 5, 8] Output: 167 Explanation: nums = [3, 1, 5, 8] --> [3, 5, 8] --> [3, 8] --> [8] --> [] coins = 31.5. + 35.8. + 13.8. + 18.1. = 167 Example 2: Input: nums = [1, 5] Output: 10 Constraints: n == nums.length 1 <= n <= 300^0 <= nums[i] <= 100\n", "code_prompt": "class Solution:\n    def maxCoins(self, nums: List[int]) -> int:\n        ", "raw_response": "```python\nfrom typing import List\n\nclass Solution:\n    def maxCoins(self, nums: List[int]) -> int:\n        n = len(nums)\n        # Add 1 to beginning and end of nums to simulate\n        # the balloons on both sides that are treated as 1\n        nums = [1] + nums + [1]\n        \n        # Create a 2D dp table to store the maximum coins\n        # for bursting balloons from i to j\n        dp = [[0] * (n+2) for _ in range(n+2)]\n        \n        # Iterate over the dp table from bottom to top\n        for length in range(1, n+1):\n            for i in range(1, n+2-length):\n                j = i + length - 1\n                for k in range(i, j+1):\n                    # Burst balloon k and collect coins\n                    coins = nums[i-1] * nums[k] * nums[j+1]\n                    # Calculate the maximum coins by considering\n                    # the burst order and update the dp table\n                    dp[i][j] = max(dp[i][j], dp[i][k-1] + coins + dp[k+1][j])\n        \n        return dp[1][n]\n```\n\nAlgorithm Explanation:\n\n- To solve this problem, we use dynamic programming and create a 2D dp table to store maximum coins for bursting balloons from position i to j.\n- We start by adding 1 to the beginning and end of the 'nums' array to simulate the balloons on both sides that are treated as 1.\n- The dp table has dimensions (n+2) x (n+2), where n is the length of 'nums'.\n- We iterate over the dp table from bottom to top, considering different lengths of subarrays.\n- For each length, we iterate over all possible subarrays and calculate the maximum coins that can be collected.\n- The maximum coins for bursting balloons from position i to j is stored in dp[i][j].\n- To calculate dp[i][j], we consider all possible positions k to burst a balloon between i and j.\n- We calculate the coins collected by bursting balloon k and consider the maximum of the previous coins (dp[i][k-1]) and the coins collected in this case.\n- Finally, we return the maximum coins for bursting balloons from position 1 to n.\n\nThe time complexity of this algorithm is O(n^3), where n is the length of 'nums'. This is because we have three nested loops: one for the length, one for the start position, and one for the end position. \nThe space complexity is O(n^2) to store the dp table.", "cleaned_response": "\nfrom typing import List\n\nclass Solution:\n    def maxCoins(self, nums: List[int]) -> int:\n        n = len(nums)\n        # Add 1 to beginning and end of nums to simulate\n        # the balloons on both sides that are treated as 1\n        nums = [1] + nums + [1]\n        \n        # Create a 2D dp table to store the maximum coins\n        # for bursting balloons from i to j\n        dp = [[0] * (n+2) for _ in range(n+2)]\n        \n        # Iterate over the dp table from bottom to top\n        for length in range(1, n+1):\n            for i in range(1, n+2-length):\n                j = i + length - 1\n                for k in range(i, j+1):\n                    # Burst balloon k and collect coins\n                    coins = nums[i-1] * nums[k] * nums[j+1]\n                    # Calculate the maximum coins by considering\n                    # the burst order and update the dp table\n                    dp[i][j] = max(dp[i][j], dp[i][k-1] + coins + dp[k+1][j])\n        \n        return dp[1][n]\n", "n_pass": 1, "difficulty": 3.0, "frontend_question_id": 312.0, "loc": 247}
{"task_input": "\nLeetCode Problem #313\nTitle: Super Ugly Number\nDescription:\nA super ugly number is a positive integer whose prime factors are in the array primes. Given an integer n and an array of integers primes, return the n th super ugly number. The n th super ugly number is guaranteed to fit in a 32-bit signed integer. Example 1: Input: n = 12, primes = [2, 7, 13, 19] Output: 32 Explanation: [1, 2, 4, 7, 8, 13, 14, 16, 19, 26, 28, 32] is the sequence of the first 12 super ugly numbers given primes = [2, 7, 13, 19]. Example 2: Input: n = 1, primes = [2, 3, 5] Output: 1 Explanation: 1 has no prime factors, therefore all of its prime factors are in the array primes = [2, 3, 5]. Constraints: 1 <= n <= 10e5 1 <= primes.length <= 100^2 <= primes[i] <= 1000 primes[i] is guaranteed to be a prime number. All the values of primes are unique and sorted in ascending order.\n", "code_prompt": "class Solution:\n    def nthSuperUglyNumber(self, n: int, primes: List[int]) -> int:\n        ", "raw_response": "```python\nfrom typing import *\n\nclass Solution:\n    def nthSuperUglyNumber(self, n: int, primes: List[int]) -> int:\n        ugly = [1]\n        pointers = [0] * len(primes)\n        \n        for _ in range(1, n):\n            next_ugly = min(ugly[pointers[i]] * primes[i] for i in range(len(primes)))\n            ugly.append(next_ugly)\n            \n            for i in range(len(primes)):\n                if ugly[pointers[i]] * primes[i] == next_ugly:\n                    pointers[i] += 1\n        \n        return ugly[-1]\n```", "cleaned_response": "\nfrom typing import *\n\nclass Solution:\n    def nthSuperUglyNumber(self, n: int, primes: List[int]) -> int:\n        ugly = [1]\n        pointers = [0] * len(primes)\n        \n        for _ in range(1, n):\n            next_ugly = min(ugly[pointers[i]] * primes[i] for i in range(len(primes)))\n            ugly.append(next_ugly)\n            \n            for i in range(len(primes)):\n                if ugly[pointers[i]] * primes[i] == next_ugly:\n                    pointers[i] += 1\n        \n        return ugly[-1]\n", "n_pass": 1, "difficulty": 2.0, "frontend_question_id": 313.0, "loc": 248}
{"task_input": "\nLeetCode Problem #315\nTitle: Count of Smaller Numbers After Self\nDescription:\nGiven an integer array nums, return an integer array counts where counts[i] is the number of smaller elements to the right of nums[i]. Example 1: Input: nums = [5, 2, 6, 1] Output: [2, 1, 1, 0] Explanation: To the right of 5 there are 2 smaller elements (2 and 1). To the right of 2 there is only 1 smaller element (1). To the right of 6 there is 1 smaller element (1). To the right of 1 there is 0 smaller element. Example 2: Input: nums = [-1] Output: [0] Example 3: Input: nums = [-1, -1] Output: [0, 0] Constraints: 1 <= nums.length <= 10e5 -10e4 <= nums[i] <= 10e4\n", "code_prompt": "class Solution:\n    def countSmaller(self, nums: List[int]) -> List[int]:\n        ", "raw_response": "### Problem Analysis\n\nTo solve this problem, we can use a modified version of the merge sort algorithm. We will divide the input array into smaller subarrays, sort them, and then merge them back together while counting the number of smaller elements to the right of each element.\n\n### Plan\n\n1. Create a class `Solution` with a method `countSmaller` that takes in the `nums` array as input.\n2. Initialize an empty array `result` to store the counts of smaller elements.\n3. Create a helper function `mergeSort` that takes in the `nums` array and returns a sorted version of it.\n4. Inside the `mergeSort` function, if the length of the `nums` array is less than or equal to 1, return the `nums` array.\n5. Divide the `nums` array into two halves, and recursively call `mergeSort` on each half.\n6. Merge the two sorted halves and update the `result` array with the count of smaller elements.\n7. Return the merged and sorted array from the `mergeSort` function.\n8. Call the `mergeSort` function on the `nums` array and return the `result` array.\n\n### Complexity Analysis\n\nThe time complexity for this approach is O(N log N), where N is the length of the input array. This is because we divide the array into halves log N times and merge them in linear time.\n\nThe space complexity is O(N) because we create additional arrays to store the sorted and merged subarrays.\n\nLet's implement the code now.", "cleaned_response": "### Problem Analysis\n\nTo solve this problem, we can use a modified version of the merge sort algorithm. We will divide the input array into smaller subarrays, sort them, and then merge them back together while counting the number of smaller elements to the right of each element.\n\n### Plan\n\n1. Create a class `Solution` with a method `countSmaller` that takes in the `nums` array as input.\n2. Initialize an empty array `result` to store the counts of smaller elements.\n3. Create a helper function `mergeSort` that takes in the `nums` array and returns a sorted version of it.\n4. Inside the `mergeSort` function, if the length of the `nums` array is less than or equal to 1, return the `nums` array.\n5. Divide the `nums` array into two halves, and recursively call `mergeSort` on each half.\n6. Merge the two sorted halves and update the `result` array with the count of smaller elements.\n7. Return the merged and sorted array from the `mergeSort` function.\n8. Call the `mergeSort` function on the `nums` array and return the `result` array.\n\n### Complexity Analysis\n\nThe time complexity for this approach is O(N log N), where N is the length of the input array. This is because we divide the array into halves log N times and merge them in linear time.\n\nThe space complexity is O(N) because we create additional arrays to store the sorted and merged subarrays.\n\nLet's implement the code now.", "n_pass": 1, "difficulty": 3.0, "frontend_question_id": 315.0, "loc": 249}
{"task_input": "\nLeetCode Problem #321\nTitle: Create Maximum Number\nDescription:\nYou are given two integer arrays nums1 and nums2 of lengths m and n respectively. nums1 and nums2 represent the digits of two numbers. You are also given an integer k. Create the maximum number of length k <= m + n from digits of the two numbers. The relative order of the digits from the same array must be preserved. Return an array of the k digits representing the answer. Example 1: Input: nums1 = [3, 4, 6, 5], nums2 = [9, 1, 2, 5, 8, 3], k = 5 Output: [9, 8, 6, 5, 3] Example 2: Input: nums1 = [6, 7], nums2 = [6, 0, 4], k = 5 Output: [6, 7, 6, 0, 4] Example 3: Input: nums1 = [3, 9], nums2 = [8, 9], k = 3 Output: [9, 8, 9] Constraints: m == nums1.length n == nums2.length 1 <= m, n <= 500^0 <= nums1[i], nums2[i] <= 9^1 <= k <= m + n\n", "code_prompt": "class Solution:\n    def maxNumber(self, nums1: List[int], nums2: List[int], k: int) -> List[int]:\n        ", "raw_response": "```python\nfrom typing import List\n\nclass Solution:\n    def maxNumber(self, nums1: List[int], nums2: List[int], k: int) -> List[int]:\n        def merge(nums1: List[int], nums2: List[int]) -> List[int]:\n            result = []\n            while nums1 or nums2:\n                if nums1 > nums2:\n                    result.append(nums1[0])\n                    nums1 = nums1[1:]\n                else:\n                    result.append(nums2[0])\n                    nums2 = nums2[1:]\n            return result\n        \n        def getMaxSubsequence(nums: List[int], k: int) -> List[int]:\n            subsequence = []\n            to_delete = len(nums) - k\n            for num in nums:\n                while subsequence and to_delete and subsequence[-1] < num:\n                    subsequence.pop()\n                    to_delete -= 1\n                subsequence.append(num)\n            return subsequence[:k]\n        \n        n1, n2 = len(nums1), len(nums2)\n        result = []\n        \n        for i in range(k+1):\n            j = k - i\n            if i <= n1 and j <= n2:\n                max_subseq1 = getMaxSubsequence(nums1, i)\n                max_subseq2 = getMaxSubsequence(nums2, j)\n                merged = merge(max_subseq1, max_subseq2)\n                if merged > result:\n                    result = merged\n        \n        return result\n```", "cleaned_response": "\nfrom typing import List\n\nclass Solution:\n    def maxNumber(self, nums1: List[int], nums2: List[int], k: int) -> List[int]:\n        def merge(nums1: List[int], nums2: List[int]) -> List[int]:\n            result = []\n            while nums1 or nums2:\n                if nums1 > nums2:\n                    result.append(nums1[0])\n                    nums1 = nums1[1:]\n                else:\n                    result.append(nums2[0])\n                    nums2 = nums2[1:]\n            return result\n        \n        def getMaxSubsequence(nums: List[int], k: int) -> List[int]:\n            subsequence = []\n            to_delete = len(nums) - k\n            for num in nums:\n                while subsequence and to_delete and subsequence[-1] < num:\n                    subsequence.pop()\n                    to_delete -= 1\n                subsequence.append(num)\n            return subsequence[:k]\n        \n        n1, n2 = len(nums1), len(nums2)\n        result = []\n        \n        for i in range(k+1):\n            j = k - i\n            if i <= n1 and j <= n2:\n                max_subseq1 = getMaxSubsequence(nums1, i)\n                max_subseq2 = getMaxSubsequence(nums2, j)\n                merged = merge(max_subseq1, max_subseq2)\n                if merged > result:\n                    result = merged\n        \n        return result\n", "n_pass": 1, "difficulty": 3.0, "frontend_question_id": 321.0, "loc": 253}
{"task_input": "\nLeetCode Problem #324\nTitle: Wiggle Sort II\nDescription:\nGiven an integer array nums, reorder it such that nums[0] < nums[1] > nums[2] < nums[3]. . . . You may assume the input array always has a valid answer. Example 1: Input: nums = [1, 5, 1, 1, 6, 4] Output: [1, 6, 1, 5, 1, 4] Explanation: [1, 4, 1, 5, 1, 6] is also accepted. Example 2: Input: nums = [1, 3, 2, 2, 3, 1] Output: [2, 3, 1, 3, 1, 2] Constraints: 1 <= nums.length <= 5 * 10e4 0 <= nums[i] <= 5000 It is guaranteed that there will be an answer for the given input nums. Follow Up: Can you do it in O(n) time and/or in-place with O(1) extra space?\n", "code_prompt": "class Solution:\n    def wiggleSort(self, nums: List[int]) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        ", "raw_response": "```python\nfrom typing import List\n\nclass Solution:\n    def wiggleSort(self, nums: List[int]) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        n = len(nums)\n        nums.sort() # Sort the given array\n        \n        mid = n // 2 if n % 2 == 0 else n // 2 + 1 # Find mid index\n        \n        nums[::2], nums[1::2] = nums[:mid][::-1], nums[mid:][::-1] # Rearrange the sorted array\n        \n        return nums\n```", "cleaned_response": "\nfrom typing import List\n\nclass Solution:\n    def wiggleSort(self, nums: List[int]) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        n = len(nums)\n        nums.sort() # Sort the given array\n        \n        mid = n // 2 if n % 2 == 0 else n // 2 + 1 # Find mid index\n        \n        nums[::2], nums[1::2] = nums[:mid][::-1], nums[mid:][::-1] # Rearrange the sorted array\n        \n        return nums\n", "n_pass": 1, "difficulty": 2.0, "frontend_question_id": 324.0, "loc": 255}
{"task_input": "\nLeetCode Problem #327\nTitle: Count of Range Sum\nDescription:\nGiven an integer array nums and two integers lower and upper, return the number of range sums that lie in [lower, upper] inclusive. Range sum S(i, j) is defined as the sum of the elements in nums between indices i and j inclusive, where i <= j. Example 1: Input: nums = [-2, 5, -1], lower = -2, upper = 2 Output: 3 Explanation: The three ranges are: [0, 0], [2, 2], and [0, 2] and their respective sums are: -2, -1, 2. Example 2: Input: nums = [0], lower = 0, upper = 0 Output: 1 Constraints: 1 <= nums.length <= 10e5 -2^31 <= nums[i] <= 2^31 - 1 -10e5 <= lower <= upper <= 10e5 The answer is guaranteed to fit in a 32-bit integer.\n", "code_prompt": "class Solution:\n    def countRangeSum(self, nums: List[int], lower: int, upper: int) -> int:\n        ", "raw_response": "```python\nclass Solution:\n    def countRangeSum(self, nums: List[int], lower: int, upper: int) -> int:\n        def mergeSort(start, end):\n            if start >= end:\n                return 0\n            \n            mid = (start + end) // 2\n            count = mergeSort(start, mid) + mergeSort(mid+1, end)\n            \n            # Counting the number of valid ranges\n            i = j = mid + 1  # Right pointer to compare with left pointer\n            for left in preSum[start:mid+1]:\n                while i <= end and preSum[i] - left < lower:\n                    i += 1\n                while j <= end and preSum[j] - left <= upper:\n                    j += 1\n                count += j - i\n                \n            # Merging the sorted sub-arrays\n            temp = []\n            i, j = start, mid + 1\n            while i <= mid and j <= end:\n                if preSum[i] < preSum[j]:\n                    temp.append(preSum[i])\n                    i += 1\n                else:\n                    temp.append(preSum[j])\n                    j += 1\n            while i <= mid:\n                temp.append(preSum[i])\n                i += 1\n            while j <= end:\n                temp.append(preSum[j])\n                j += 1\n                \n            preSum[start:end+1] = temp  # Update the preSum array with sorted values\n            \n            return count\n        \n        n = len(nums)\n        preSum = [0] * (n + 1)\n        for i in range(1, n+1):\n            preSum[i] = preSum[i-1] + nums[i-1]\n        \n        return mergeSort(0, n)\n```", "cleaned_response": "\nclass Solution:\n    def countRangeSum(self, nums: List[int], lower: int, upper: int) -> int:\n        def mergeSort(start, end):\n            if start >= end:\n                return 0\n            \n            mid = (start + end) // 2\n            count = mergeSort(start, mid) + mergeSort(mid+1, end)\n            \n            # Counting the number of valid ranges\n            i = j = mid + 1  # Right pointer to compare with left pointer\n            for left in preSum[start:mid+1]:\n                while i <= end and preSum[i] - left < lower:\n                    i += 1\n                while j <= end and preSum[j] - left <= upper:\n                    j += 1\n                count += j - i\n                \n            # Merging the sorted sub-arrays\n            temp = []\n            i, j = start, mid + 1\n            while i <= mid and j <= end:\n                if preSum[i] < preSum[j]:\n                    temp.append(preSum[i])\n                    i += 1\n                else:\n                    temp.append(preSum[j])\n                    j += 1\n            while i <= mid:\n                temp.append(preSum[i])\n                i += 1\n            while j <= end:\n                temp.append(preSum[j])\n                j += 1\n                \n            preSum[start:end+1] = temp  # Update the preSum array with sorted values\n            \n            return count\n        \n        n = len(nums)\n        preSum = [0] * (n + 1)\n        for i in range(1, n+1):\n            preSum[i] = preSum[i-1] + nums[i-1]\n        \n        return mergeSort(0, n)\n", "n_pass": 1, "difficulty": 3.0, "frontend_question_id": 327.0, "loc": 257}
{"task_input": "\nLeetCode Problem #329\nTitle: Longest Increasing Path in a Matrix\nDescription:\nGiven an m x n integers matrix, return the length of the longest increasing path in matrix. From each cell, you can either move in four directions: left, right, up, or down. You may not move diagonally or move outside the boundary (i. e. , wrap-around is not allowed). Example 1: Input: matrix = [[9, 9, 4], [6, 6, 8], [2, 1, 1]] Output: 4 Explanation: The longest increasing path is [1, 2, 6, 9]. Example 2: Input: matrix = [[3, 4, 5], [3, 2, 6], [2, 2, 1]] Output: 4 Explanation: The longest increasing path is [3, 4, 5, 6]. Moving diagonally is not allowed. Example 3: Input: matrix = [[1]] Output: 1 Constraints: m == matrix.length n == matrix[i].length 1 <= m, n <= 200^0 <= matrix[i][j] <= 2^31 - 1\n", "code_prompt": "class Solution:\n    def longestIncreasingPath(self, matrix: List[List[int]]) -> int:\n        ", "raw_response": "```python\nfrom typing import List\n\nclass Solution:\n    def longestIncreasingPath(self, matrix: List[List[int]]) -> int:\n        if not matrix:\n            return 0\n        \n        # Initialize memoization dictionary\n        memo = {}\n        \n        # Initialize variables for matrix dimensions\n        m = len(matrix)\n        n = len(matrix[0])\n        \n        # Initialize maximum path length\n        max_length = 0\n        \n        # Define directions to move in the matrix\n        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n        \n        # Define the DFS function\n        def dfs(i, j):\n            # Check if length for current cell has been memoized\n            if (i, j) in memo:\n                return memo[(i, j)]\n            \n            # Initialize path length\n            path_length = 1\n            \n            # Iterate over the four directions\n            for direction in directions:\n                x = i + direction[0]\n                y = j + direction[1]\n                \n                # Check if next cell is within boundaries and increasing\n                if 0 <= x < m and 0 <= y < n and matrix[x][y] > matrix[i][j]:\n                    path_length = max(path_length, 1 + dfs(x, y))\n            \n            # Store the computed path length for current cell\n            memo[(i, j)] = path_length\n            \n            return path_length\n        \n        # Iterate over each cell in the matrix\n        for i in range(m):\n            for j in range(n):\n                max_length = max(max_length, dfs(i, j))\n        \n        return max_length\n```", "cleaned_response": "\nfrom typing import List\n\nclass Solution:\n    def longestIncreasingPath(self, matrix: List[List[int]]) -> int:\n        if not matrix:\n            return 0\n        \n        # Initialize memoization dictionary\n        memo = {}\n        \n        # Initialize variables for matrix dimensions\n        m = len(matrix)\n        n = len(matrix[0])\n        \n        # Initialize maximum path length\n        max_length = 0\n        \n        # Define directions to move in the matrix\n        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n        \n        # Define the DFS function\n        def dfs(i, j):\n            # Check if length for current cell has been memoized\n            if (i, j) in memo:\n                return memo[(i, j)]\n            \n            # Initialize path length\n            path_length = 1\n            \n            # Iterate over the four directions\n            for direction in directions:\n                x = i + direction[0]\n                y = j + direction[1]\n                \n                # Check if next cell is within boundaries and increasing\n                if 0 <= x < m and 0 <= y < n and matrix[x][y] > matrix[i][j]:\n                    path_length = max(path_length, 1 + dfs(x, y))\n            \n            # Store the computed path length for current cell\n            memo[(i, j)] = path_length\n            \n            return path_length\n        \n        # Iterate over each cell in the matrix\n        for i in range(m):\n            for j in range(n):\n                max_length = max(max_length, dfs(i, j))\n        \n        return max_length\n", "n_pass": 1, "difficulty": 3.0, "frontend_question_id": 329.0, "loc": 259}
{"task_input": "\nLeetCode Problem #330\nTitle: Patching Array\nDescription:\nGiven a sorted integer array nums and an integer n, add/patch elements to the array such that any number in the range [1, n] inclusive can be formed by the sum of some elements in the array. Return the minimum number of patches required. Example 1: Input: nums = [1, 3], n = 6 Output: 1 Explanation: Combinations of nums are [1], [3], [1, 3], which form possible sums of: 1, 3, 4. Now if we add/patch 2 to nums, the combinations are: [1], [2], [3], [1, 3], [2, 3], [1, 2, 3]. Possible sums are 1, 2, 3, 4, 5, 6, which now covers the range [1, 6]. So we only need 1 patch. Example 2: Input: nums = [1, 5, 10], n = 20 Output: 2 Explanation: The two patches can be [2, 4]. Example 3: Input: nums = [1, 2, 2], n = 5 Output: 0 Constraints: 1 <= nums.length <= 1000^1 <= nums[i] <= 10e4 nums is sorted in ascending order. 1 <= n <= 2^31 - 1\n", "code_prompt": "class Solution:\n    def minPatches(self, nums: List[int], n: int) -> int:\n        ", "raw_response": "```python\nfrom typing import List\n\nclass Solution:\n    def minPatches(self, nums: List[int], n: int) -> int:\n        patches = 0\n        curr_sum = 0\n        i = 0\n        \n        while curr_sum < n:\n            if i < len(nums) and nums[i] <= curr_sum + 1:\n                curr_sum += nums[i]\n                i += 1\n            else:\n                curr_sum += curr_sum + 1\n                patches += 1\n        \n        return patches\n```", "cleaned_response": "\nfrom typing import List\n\nclass Solution:\n    def minPatches(self, nums: List[int], n: int) -> int:\n        patches = 0\n        curr_sum = 0\n        i = 0\n        \n        while curr_sum < n:\n            if i < len(nums) and nums[i] <= curr_sum + 1:\n                curr_sum += nums[i]\n                i += 1\n            else:\n                curr_sum += curr_sum + 1\n                patches += 1\n        \n        return patches\n", "n_pass": 1, "difficulty": 3.0, "frontend_question_id": 330.0, "loc": 260}
{"task_input": "\nLeetCode Problem #332\nTitle: Reconstruct Itinerary\nDescription:\nYou are given a list of airline tickets where tickets[i] = [from i, to i ] represent the departure and the arrival airports of one flight. Reconstruct the itinerary in order and return it. All of the tickets belong to a man who departs from \"JFK\", thus, the itinerary must begin with \"JFK\". If there are multiple valid itineraries, you should return the itinerary that has the smallest lexical order when read as a single string. For example, the itinerary [\"JFK\", \"LGA\"] has a smaller lexical order than [\"JFK\", \"LGB\"]. You may assume all tickets form at least one valid itinerary. You must use all the tickets once and only once. Example 1: Input: tickets = [[\"MUC\", \"LHR\"], [\"JFK\", \"MUC\"], [\"SFO\", \"SJC\"], [\"LHR\", \"SFO\"]] Output: [\"JFK\", \"MUC\", \"LHR\", \"SFO\", \"SJC\"] Example 2: Input: tickets = [[\"JFK\", \"SFO\"], [\"JFK\", \"ATL\"], [\"SFO\", \"ATL\"], [\"ATL\", \"JFK\"], [\"ATL\", \"SFO\"]] Output: [\"JFK\", \"ATL\", \"JFK\", \"SFO\", \"ATL\", \"SFO\"] Explanation: Another possible reconstruction is [\"JFK\", \"SFO\", \"ATL\", \"JFK\", \"ATL\", \"SFO\"] but it is larger in lexical order. Constraints: 1 <= tickets.length <= 300 tickets[i].length == 2 from i.length == 3 to i.length == 3 from i and to i consist of uppercase English letters. from i != to i\n", "code_prompt": "class Solution:\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\n        ", "raw_response": "class Solution:\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\n        # Create a graph using a dict to represent destinations\n        graph = {}\n        for ticket in tickets:\n            src, dest = ticket\n            if src not in graph:\n                graph[src] = []\n            graph[src].append(dest)\n        \n        # Sort the destinations in reverse order to explore the smaller lexical order first\n        for src in graph:\n            graph[src].sort(reverse=True)\n        \n        # Perform a depth-first search to reconstruct the itinerary\n        itinerary = []\n        def dfs(src):\n            while src in graph and graph[src]:\n                dfs(graph[src].pop())\n            itinerary.append(src)\n        \n        dfs(\"JFK\")\n        \n        # Reverse the itinerary to get the correct order\n        itinerary.reverse()\n        return itinerary", "cleaned_response": "class Solution:\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\n        # Create a graph using a dict to represent destinations\n        graph = {}\n        for ticket in tickets:\n            src, dest = ticket\n            if src not in graph:\n                graph[src] = []\n            graph[src].append(dest)\n        \n        # Sort the destinations in reverse order to explore the smaller lexical order first\n        for src in graph:\n            graph[src].sort(reverse=True)\n        \n        # Perform a depth-first search to reconstruct the itinerary\n        itinerary = []\n        def dfs(src):\n            while src in graph and graph[src]:\n                dfs(graph[src].pop())\n            itinerary.append(src)\n        \n        dfs(\"JFK\")\n        \n        # Reverse the itinerary to get the correct order\n        itinerary.reverse()\n        return itinerary", "n_pass": 1, "difficulty": 3.0, "frontend_question_id": 332.0, "loc": 262}
{"task_input": "\nLeetCode Problem #335\nTitle: Self Crossing\nDescription:\nYou are given an array of integers distance. You start at the point (0, 0) on an X-Y plane, and you move distance[0] meters to the north, then distance[1] meters to the west, distance[2] meters to the south, distance[3] meters to the east, and so on. In other words, after each move, your direction changes counter-clockwise. Return true if your path crosses itself or false if it does not. Example 1: Input: distance = [2, 1, 1, 2] Output: true Explanation: The path crosses itself at the point (0, 1). Example 2: Input: distance = [1, 2, 3, 4] Output: false Explanation: The path does not cross itself at any point. Example 3: Input: distance = [1, 1, 1, 2, 1] Output: true Explanation: The path crosses itself at the point (0, 0). Constraints: 1 <= distance.length <= 10e5 1 <= distance[i] <= 10e5\n", "code_prompt": "class Solution:\n    def isSelfCrossing(self, distance: List[int]) -> bool:\n        ", "raw_response": "```python\nfrom typing import List\n\nclass Solution:\n    def isSelfCrossing(self, distance: List[int]) -> bool:\n        n = len(distance)\n        \n        if n <= 3:\n            return False\n        \n        for i in range(3, n):\n            if distance[i] >= distance[i-2] and distance[i-1] <= distance[i-3]:\n                return True\n            if i >= 4 and distance[i-1] == distance[i-3] and distance[i] + distance[i-4] >= distance[i-2]:\n                return True\n            if i >= 5 and distance[i-2] >= distance[i-4] and distance[i] + distance[i-4] >= distance[i-2] and distance[i-1] <= distance[i-3] and distance[i-1] + distance[i-5] >= distance[i-3]:\n                return True\n            \n        return False\n```\nThe solution checks if the path crosses itself by iterating through the distances and using different conditions to check for overlapping lines.", "cleaned_response": "\nfrom typing import List\n\nclass Solution:\n    def isSelfCrossing(self, distance: List[int]) -> bool:\n        n = len(distance)\n        \n        if n <= 3:\n            return False\n        \n        for i in range(3, n):\n            if distance[i] >= distance[i-2] and distance[i-1] <= distance[i-3]:\n                return True\n            if i >= 4 and distance[i-1] == distance[i-3] and distance[i] + distance[i-4] >= distance[i-2]:\n                return True\n            if i >= 5 and distance[i-2] >= distance[i-4] and distance[i] + distance[i-4] >= distance[i-2] and distance[i-1] <= distance[i-3] and distance[i-1] + distance[i-5] >= distance[i-3]:\n                return True\n            \n        return False\n", "n_pass": 1, "difficulty": 3.0, "frontend_question_id": 335.0, "loc": 264}
{"task_input": "\nLeetCode Problem #336\nTitle: Palindrome Pairs\nDescription:\nYou are given a 0-indexed array of unique strings words. A palindrome pair is a pair of integers (i, j) such that: 0 <= i, j < words.length, i != j, and words[i] + words[j] (the concatenation of the two strings) is a palindrome. Return an array of all the palindrome pairs of words. Example 1: Input: words = [\"abcd\", \"dcba\", \"lls\", \"s\", \"sssll\"] Output: [[0, 1], [1, 0], [3, 2], [2, 4]] Explanation: The palindromes are [\"abcddcba\", \"dcbaabcd\", \"slls\", \"llssssll\"] Example 2: Input: words = [\"bat\", \"tab\", \"cat\"] Output: [[0, 1], [1, 0]] Explanation: The palindromes are [\"battab\", \"tabbat\"] Example 3: Input: words = [\"a\", \"\"] Output: [[0, 1], [1, 0]] Explanation: The palindromes are [\"a\", \"a\"] Constraints: 1 <= words.length <= 5000^0 <= words[i].length <= 300 words[i] consists of lowercase English letters.\n", "code_prompt": "class Solution:\n    def palindromePairs(self, words: List[str]) -> List[List[int]]:\n        ", "raw_response": "class Solution:\n    def palindromePairs(self, words: List[str]) -> List[List[int]]:\n        def is_palindrome(word):\n            return word == word[::-1]\n        \n        pairs = []\n        word_mapping = {word: i for i, word in enumerate(words)}\n        \n        for i, word in enumerate(words):\n            for j in range(len(word) + 1):\n                prefix = word[:j]\n                suffix = word[j:]\n                \n                # Case 1: If prefix is a palindrome, find the reverse of the suffix\n                # in the word_mapping and check if the index is not the same as i\n                if is_palindrome(prefix):\n                    reverse_suffix = suffix[::-1]\n                    if reverse_suffix in word_mapping and word_mapping[reverse_suffix] != i:\n                        pairs.append([word_mapping[reverse_suffix], i])\n                \n                # Case 2: If suffix is a palindrome, find the reverse of the prefix\n                # in the word_mapping and check if the index is not the same as i\n                if is_palindrome(suffix):\n                    reverse_prefix = prefix[::-1]\n                    if reverse_prefix in word_mapping and word_mapping[reverse_prefix] != i and suffix != \"\":\n                        pairs.append([i, word_mapping[reverse_prefix]])\n                        \n        return pairs", "cleaned_response": "class Solution:\n    def palindromePairs(self, words: List[str]) -> List[List[int]]:\n        def is_palindrome(word):\n            return word == word[::-1]\n        \n        pairs = []\n        word_mapping = {word: i for i, word in enumerate(words)}\n        \n        for i, word in enumerate(words):\n            for j in range(len(word) + 1):\n                prefix = word[:j]\n                suffix = word[j:]\n                \n                # Case 1: If prefix is a palindrome, find the reverse of the suffix\n                # in the word_mapping and check if the index is not the same as i\n                if is_palindrome(prefix):\n                    reverse_suffix = suffix[::-1]\n                    if reverse_suffix in word_mapping and word_mapping[reverse_suffix] != i:\n                        pairs.append([word_mapping[reverse_suffix], i])\n                \n                # Case 2: If suffix is a palindrome, find the reverse of the prefix\n                # in the word_mapping and check if the index is not the same as i\n                if is_palindrome(suffix):\n                    reverse_prefix = prefix[::-1]\n                    if reverse_prefix in word_mapping and word_mapping[reverse_prefix] != i and suffix != \"\":\n                        pairs.append([i, word_mapping[reverse_prefix]])\n                        \n        return pairs", "n_pass": 1, "difficulty": 3.0, "frontend_question_id": 336.0, "loc": 265}
{"task_input": "\nLeetCode Problem #337\nTitle: House Robber III\nDescription:\nThe thief has found himself a new place for his thievery again. There is only one entrance to this area, called root. Besides the root, each house has one and only one parent house. After a tour, the smart thief realized that all houses in this place form a binary tree. It will automatically contact the police if two directly-linked houses were broken into on the same night. Given the root of the binary tree, return the maximum amount of money the thief can rob without alerting the police. Example 1: Input: root = [3, 2, 3, null, 3, null, 1] Output: 7 Explanation: Maximum amount of money the thief can rob = 3 + 3 + 1 = 7. Example 2: Input: root = [3, 4, 5, 1, 3, null, 1] Output: 9 Explanation: Maximum amount of money the thief can rob = 4 + 5 = 9. Constraints: The number of nodes in the tree is in the range [1, 10e4 ]. 0 <= Node. val <= 10e4\n", "code_prompt": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def rob(self, root: Optional[TreeNode]) -> int:\n        ", "raw_response": "```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def rob(self, root: Optional[TreeNode]) -> int:\n        def dfs(node):\n            if not node:\n                return (0, 0)\n            \n            left = dfs(node.left)\n            right = dfs(node.right)\n            \n            rob = node.val + left[1] + right[1]\n            not_rob = max(left) + max(right)\n            \n            return (rob, not_rob)\n        \n        return max(dfs(root))\n```\nAlgorithm Explanation:\nWe will use a depth-first search (DFS) algorithm to explore each node in the binary tree. For each node, we will calculate two values:\n\n1. rob: maximum amount of money that can be obtained if the current node is robbed. It is calculated by adding the value of the current node, the maximum amount of money that can be obtained from its left subtree if it is not robbed (left[1]), and the maximum amount of money that can be obtained from its right subtree if it is not robbed (right[1]).\n2. not_rob: maximum amount of money that can be obtained if the current node is not robbed. It is calculated by adding the maximum amount of money that can be obtained from its left subtree (max(left)) and the maximum amount of money that can be obtained from its right subtree (max(right)).\n\nWe will return the maximum value between rob and not_rob for the root node as the final result.", "cleaned_response": "\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def rob(self, root: Optional[TreeNode]) -> int:\n        def dfs(node):\n            if not node:\n                return (0, 0)\n            \n            left = dfs(node.left)\n            right = dfs(node.right)\n            \n            rob = node.val + left[1] + right[1]\n            not_rob = max(left) + max(right)\n            \n            return (rob, not_rob)\n        \n        return max(dfs(root))\n", "n_pass": 1, "difficulty": 2.0, "frontend_question_id": 337.0, "loc": 266}
{"task_input": "\nLeetCode Problem #338\nTitle: Counting Bits\nDescription:\nGiven an integer n, return an array ans of length n + 1 such that for each i ( 0 <= i <= n ), ans[i] is the number of 1 's in the binary representation of i. Example 1: Input: n = 2 Output: [0, 1, 1] Explanation: 0 --> 0^1 --> 1^2 --> 10 Example 2: Input: n = 5 Output: [0, 1, 1, 2, 1, 2] Explanation: 0 --> 0^1 --> 1^2 --> 10e3 --> 11^4 --> 100^5 --> 101 Constraints: 0 <= n <= 10e5 Follow up: It is very easy to come up with a solution with a runtime of O(n log n). Can you do it in linear time O(n) and possibly in a single pass? Can you do it without using any built-in function (i. e. , like __builtin_popcount in C++)?\n", "code_prompt": "class Solution:\n    def countBits(self, n: int) -> List[int]:\n        ", "raw_response": "```python\nfrom typing import List\n\nclass Solution:\n    def countBits(self, n: int) -> List[int]:\n        # Create a list to store the number of 1s in binary representation for each number from 0 to n\n        result = [0] * (n + 1)\n        \n        for i in range(1, n + 1):\n            # The number of 1s in binary representation of a number is equal to the number of 1s in its rightmost bit (i & 1)\n            # plus the number of 1s in its remaining bits (result[i >> 1])\n            result[i] = result[i >> 1] + (i & 1)\n        \n        return result\n```\n\nExplanation:\n- We initialize a list `result` with length `n + 1` to store the number of 1s in the binary representation for each number from 0 to n.\n- For each number `i` from 1 to n, we calculate the number of 1s in its binary representation by adding the number of 1s in its rightmost bit (`i & 1`) with the number of 1s in its remaining bits (`result[i >> 1]`). \n- We use bitwise AND (`&`) to check if the rightmost bit is 1 or 0, and we use right shift (`>>`) to calculate the remaining bits.\n- Finally, we return the resulting list `result` containing the count of 1s for each number from 0 to n.", "cleaned_response": "\nfrom typing import List\n\nclass Solution:\n    def countBits(self, n: int) -> List[int]:\n        # Create a list to store the number of 1s in binary representation for each number from 0 to n\n        result = [0] * (n + 1)\n        \n        for i in range(1, n + 1):\n            # The number of 1s in binary representation of a number is equal to the number of 1s in its rightmost bit (i & 1)\n            # plus the number of 1s in its remaining bits (result[i >> 1])\n            result[i] = result[i >> 1] + (i & 1)\n        \n        return result\n", "n_pass": 1, "difficulty": 1.0, "frontend_question_id": 338.0, "loc": 267}
{"task_input": "\nLeetCode Problem #341\nTitle: Flatten Nested List Iterator\nDescription:\nYou are given a nested list of integers nestedList. Each element is either an integer or a list whose elements may also be integers or other lists. Implement an iterator to flatten it. Implement the NestedIterator class: NestedIterator(List<NestedInteger> nestedList) Initializes the iterator with the nested list nestedList. int next() Returns the next integer in the nested list. boolean hasNext() Returns true if there are still some integers in the nested list and false otherwise. Your code will be tested with the following pseudocode: initialize iterator with nestedList res = [] while iterator. hasNext() append iterator. next() to the end of res return res If res matches the expected flattened list, then your code will be judged as correct. Example 1: Input: nestedList = [[1, 1], 2, [1, 1]] Output: [1, 1, 2, 1, 1] Explanation: By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1, 1, 2, 1, 1]. Example 2: Input: nestedList = [1, [4, [6]]] Output: [1, 4, 6] Explanation: By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1, 4, 6]. Constraints: 1 <= nestedList.length <= 500 The values of the integers in the nested list is in the range [-10e6, 10e6 ].\n", "code_prompt": "# \"\"\"\n# This is the interface that allows for creating nested lists.\n# You should not implement it, or speculate about its implementation\n# \"\"\"\n#class NestedInteger:\n#    def isInteger(self) -> bool:\n#        \"\"\"\n#        @return True if this NestedInteger holds a single integer, rather than a nested list.\n#        \"\"\"\n#\n#    def getInteger(self) -> int:\n#        \"\"\"\n#        @return the single integer that this NestedInteger holds, if it holds a single integer\n#        Return None if this NestedInteger holds a nested list\n#        \"\"\"\n#\n#    def getList(self) -> [NestedInteger]:\n#        \"\"\"\n#        @return the nested list that this NestedInteger holds, if it holds a nested list\n#        Return None if this NestedInteger holds a single integer\n#        \"\"\"\n\nclass NestedIterator:\n    def __init__(self, nestedList: [NestedInteger]):\n        \n    \n    def next(self) -> int:\n        \n    \n    def hasNext(self) -> bool:\n         \n\n# Your NestedIterator object will be instantiated and called as such:\n# i, v = NestedIterator(nestedList), []\n# while i.hasNext(): v.append(i.next())", "raw_response": "```python\nclass NestedIterator:\n    def __init__(self, nestedList: [NestedInteger]):\n        self.stack = []\n        self.flatten(nestedList)\n    \n    def flatten(self, nestedList: [NestedInteger]) -> None:\n        for i in range(len(nestedList) - 1, -1, -1):\n            if nestedList[i].isInteger():\n                self.stack.append(nestedList[i].getInteger())\n            else:\n                self.flatten(nestedList[i].getList())\n    \n    def next(self) -> int:\n        return self.stack.pop()\n    \n    def hasNext(self) -> bool:\n        return len(self.stack) > 0\n```\n\nNote:\n- The `NestedIterator` class takes a nested list as input and initializes the `stack` attribute to store the flattened list.\n- The `flatten` method recursively flattens the nested list by iterating through it backwards. If an element is an integer, it is added to the `stack`. If it is a nested list, the `flatten` method is called recursively on that list.\n- The `next` method pops and returns the last element from the `stack`.\n- The `hasNext` method checks if the `stack` is empty. If it is not empty, it means there are still integers in the nested list, so it returns `True`. Otherwise, it returns `False`.", "cleaned_response": "\nclass NestedIterator:\n    def __init__(self, nestedList: [NestedInteger]):\n        self.stack = []\n        self.flatten(nestedList)\n    \n    def flatten(self, nestedList: [NestedInteger]) -> None:\n        for i in range(len(nestedList) - 1, -1, -1):\n            if nestedList[i].isInteger():\n                self.stack.append(nestedList[i].getInteger())\n            else:\n                self.flatten(nestedList[i].getList())\n    \n    def next(self) -> int:\n        return self.stack.pop()\n    \n    def hasNext(self) -> bool:\n        return len(self.stack) > 0\n", "n_pass": 1, "difficulty": 2.0, "frontend_question_id": 341.0, "loc": 268}
{"task_input": "\nLeetCode Problem #347\nTitle: Top K Frequent Elements\nDescription:\nGiven an integer array nums and an integer k, return the k most frequent elements. You may return the answer in any order. Example 1: Input: nums = [1, 1, 1, 2, 2, 3], k = 2 Output: [1, 2] Example 2: Input: nums = [1], k = 1 Output: [1] Constraints: 1 <= nums.length <= 10e5 -10e4 <= nums[i] <= 10e4 k is in the range [1, the number of unique elements in the array]. It is guaranteed that the answer is unique. Follow up: Your algorithm's time complexity must be better than O(n log n), where n is the array's size.\n", "code_prompt": "class Solution:\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\n        ", "raw_response": "```python\nfrom typing import List\nfrom collections import Counter\nimport heapq\n\nclass Solution:\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\n        # Step 1: Count the frequency of each element\n        counts = Counter(nums)\n        \n        # Step 2: Create a min heap to store the k most frequent elements\n        heap = []\n        for num, count in counts.items():\n            heapq.heappush(heap, (count, num))\n            if len(heap) > k:\n                heapq.heappop(heap)\n        \n        # Step 3: Return the k most frequent elements from the heap\n        result = []\n        while heap:\n            result.append(heapq.heappop(heap)[1])\n        \n        return result[::-1]\n```", "cleaned_response": "\nfrom typing import List\nfrom collections import Counter\nimport heapq\n\nclass Solution:\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\n        # Step 1: Count the frequency of each element\n        counts = Counter(nums)\n        \n        # Step 2: Create a min heap to store the k most frequent elements\n        heap = []\n        for num, count in counts.items():\n            heapq.heappush(heap, (count, num))\n            if len(heap) > k:\n                heapq.heappop(heap)\n        \n        # Step 3: Return the k most frequent elements from the heap\n        result = []\n        while heap:\n            result.append(heapq.heappop(heap)[1])\n        \n        return result[::-1]\n", "n_pass": 1, "difficulty": 2.0, "frontend_question_id": 347.0, "loc": 273}
{"task_input": "\nLeetCode Problem #349\nTitle: Intersection of Two Arrays\nDescription:\nGiven two integer arrays nums1 and nums2, return an array of their intersection. Each element in the result must be unique and you may return the result in any order. Example 1: Input: nums1 = [1, 2, 2, 1], nums2 = [2, 2] Output: [2] Example 2: Input: nums1 = [4, 9, 5], nums2 = [9, 4, 9, 8, 4] Output: [9, 4] Explanation: [4, 9] is also accepted. Constraints: 1 <= nums1.length, nums2.length <= 1000^0 <= nums1[i], nums2[i] <= 1000\n", "code_prompt": "class Solution:\n    def intersection(self, nums1: List[int], nums2: List[int]) -> List[int]:\n        ", "raw_response": "```python\nclass Solution:\n    def intersection(self, nums1: List[int], nums2: List[int]) -> List[int]:\n        # Convert the input lists to sets for efficient intersection operation\n        set1 = set(nums1)\n        set2 = set(nums2)\n        \n        # Calculate the intersection of the two sets\n        result_set = set1.intersection(set2)\n        \n        # Convert the result set to a list\n        result_list = list(result_set)\n        \n        return result_list\n```", "cleaned_response": "\nclass Solution:\n    def intersection(self, nums1: List[int], nums2: List[int]) -> List[int]:\n        # Convert the input lists to sets for efficient intersection operation\n        set1 = set(nums1)\n        set2 = set(nums2)\n        \n        # Calculate the intersection of the two sets\n        result_set = set1.intersection(set2)\n        \n        # Convert the result set to a list\n        result_list = list(result_set)\n        \n        return result_list\n", "n_pass": 1, "difficulty": 1.0, "frontend_question_id": 349.0, "loc": 274}
{"task_input": "\nLeetCode Problem #352\nTitle: Data Stream as Disjoint Intervals\nDescription:\nGiven a data stream input of non-negative integers a 1, a 2,. . . , a n, summarize the numbers seen so far as a list of disjoint intervals. Implement the SummaryRanges class: SummaryRanges() Initializes the object with an empty stream. void addNum(int value) Adds the integer value to the stream. int[][] getIntervals() Returns a summary of the integers in the stream currently as a list of disjoint intervals [start i, end i ]. The answer should be sorted by start i. Example 1: Input [\"SummaryRanges\", \"addNum\", \"getIntervals\", \"addNum\", \"getIntervals\", \"addNum\", \"getIntervals\", \"addNum\", \"getIntervals\", \"addNum\", \"getIntervals\"] [[], [1], [], [3], [], [7], [], [2], [], [6], []] Output [null, null, [[1, 1]], null, [[1, 1], [3, 3]], null, [[1, 1], [3, 3], [7, 7]], null, [[1, 3], [7, 7]], null, [[1, 3], [6, 7]]] Explanation SummaryRanges summaryRanges = new SummaryRanges(); summaryRanges. addNum(1); // arr = [1] summaryRanges. getIntervals(); // return [[1, 1]] summaryRanges. addNum(3); // arr = [1, 3] summaryRanges. getIntervals(); // return [[1, 1], [3, 3]] summaryRanges. addNum(7); // arr = [1, 3, 7] summaryRanges. getIntervals(); // return [[1, 1], [3, 3], [7, 7]] summaryRanges. addNum(2); // arr = [1, 2, 3, 7] summaryRanges. getIntervals(); // return [[1, 3], [7, 7]] summaryRanges. addNum(6); // arr = [1, 2, 3, 6, 7] summaryRanges. getIntervals(); // return [[1, 3], [6, 7]] Constraints: 0 <= value <= 10e4 At most 3 * 10e4 calls will be made to addNum and getIntervals. At most 10e2 calls will be made to getIntervals. Follow up: What if there are lots of merges and the number of disjoint intervals is small compared to the size of the data stream?\n", "code_prompt": "class SummaryRanges:\n\n    def __init__(self):\n        \n\n    def addNum(self, value: int) -> None:\n        \n\n    def getIntervals(self) -> List[List[int]]:\n        \n\n\n# Your SummaryRanges object will be instantiated and called as such:\n# obj = SummaryRanges()\n# obj.addNum(value)\n# param_2 = obj.getIntervals()", "raw_response": "```python\n# We can solve this problem by using a list to store the intervals.\n# Every time a new number is added, we need to check if it can be merged with an existing interval or if it forms a new interval on its own.\n\nfrom typing import List\n\nclass SummaryRanges:\n\n    def __init__(self):\n        self.intervals = []\n\n    def addNum(self, value: int) -> None:\n        # Check if the value can be merged with an existing interval\n        for i in range(len(self.intervals)):\n            if self.intervals[i][0] <= value <= self.intervals[i][1]:\n                return\n            \n            # Check if the value is smaller than the start of the current interval\n            if self.intervals[i][0] > value:\n                # Check if the value is exactly one less than the start of the current interval\n                if self.intervals[i][0] - value == 1:\n                    self.intervals[i][0] = value\n                    return\n                # Otherwise, create a new interval before the current interval\n                else:\n                    self.intervals.insert(i, [value, value])\n                    return\n        \n        # Check if the value is larger than the end of the last interval\n        if len(self.intervals) > 0 and self.intervals[-1][1] < value:\n            # Check if the value is exactly one greater than the end of the last interval\n            if value - self.intervals[-1][1] == 1:\n                self.intervals[-1][1] = value\n                return\n        \n        # If no merging or creating new interval is possible, create a new interval at the end\n        self.intervals.append([value, value])\n\n    def getIntervals(self) -> List[List[int]]:\n        return self.intervals\n\n\n# Your SummaryRanges object will be instantiated and called as such:\n# obj = SummaryRanges()\n# obj.addNum(value)\n# param_2 = obj.getIntervals()\n```\n\nThe algorithm maintains a list of disjoint intervals. The `addNum` function checks if the new number can be merged with an existing interval or if it forms a new interval on its own. The `getIntervals` function returns the current list of intervals.\n\nThe time complexity of the algorithm is O(n) for the `addNum` function, as we may need to iterate through the intervals list to find the correct position to insert the new interval. The `getIntervals` function has a time complexity of O(1) as it simply returns the current intervals list.", "cleaned_response": "\n# We can solve this problem by using a list to store the intervals.\n# Every time a new number is added, we need to check if it can be merged with an existing interval or if it forms a new interval on its own.\n\nfrom typing import List\n\nclass SummaryRanges:\n\n    def __init__(self):\n        self.intervals = []\n\n    def addNum(self, value: int) -> None:\n        # Check if the value can be merged with an existing interval\n        for i in range(len(self.intervals)):\n            if self.intervals[i][0] <= value <= self.intervals[i][1]:\n                return\n            \n            # Check if the value is smaller than the start of the current interval\n            if self.intervals[i][0] > value:\n                # Check if the value is exactly one less than the start of the current interval\n                if self.intervals[i][0] - value == 1:\n                    self.intervals[i][0] = value\n                    return\n                # Otherwise, create a new interval before the current interval\n                else:\n                    self.intervals.insert(i, [value, value])\n                    return\n        \n        # Check if the value is larger than the end of the last interval\n        if len(self.intervals) > 0 and self.intervals[-1][1] < value:\n            # Check if the value is exactly one greater than the end of the last interval\n            if value - self.intervals[-1][1] == 1:\n                self.intervals[-1][1] = value\n                return\n        \n        # If no merging or creating new interval is possible, create a new interval at the end\n        self.intervals.append([value, value])\n\n    def getIntervals(self) -> List[List[int]]:\n        return self.intervals\n\n\n# Your SummaryRanges object will be instantiated and called as such:\n# obj = SummaryRanges()\n# obj.addNum(value)\n# param_2 = obj.getIntervals()\n", "n_pass": 1, "difficulty": 3.0, "frontend_question_id": 352.0, "loc": 276}
{"task_input": "\nLeetCode Problem #354\nTitle: Russian Doll Envelopes\nDescription:\nYou are given a 2D array of integers envelopes where envelopes[i] = [w i, h i ] represents the width and the height of an envelope. One envelope can fit into another if and only if both the width and height of one envelope are greater than the other envelope's width and height. Return the maximum number of envelopes you can Russian doll (i. e. , put one inside the other). Note: You cannot rotate an envelope. Example 1: Input: envelopes = [[5, 4], [6, 4], [6, 7], [2, 3]] Output: 3 Explanation: The maximum number of envelopes you can Russian doll is 3 ([2, 3] => [5, 4] => [6, 7]). Example 2: Input: envelopes = [[1, 1], [1, 1], [1, 1]] Output: 1 Constraints: 1 <= envelopes.length <= 10e5 envelopes[i].length == 2^1 <= w i, h i <= 10e5\n", "code_prompt": "class Solution:\n    def maxEnvelopes(self, envelopes: List[List[int]]) -> int:\n        ", "raw_response": "```python\nfrom typing import List\n\nclass Solution:\n    def maxEnvelopes(self, envelopes: List[List[int]]) -> int:\n        # Sort the envelopes based on the width in ascending order\n        # If the widths are the same, sort based on height in descending order\n        envelopes.sort(key=lambda x: (x[0], -x[1]))\n        \n        n = len(envelopes)\n        dp = [1] * n\n        \n        # Iterate through each envelope and check if it can be nested inside any previous envelopes\n        for i in range(n):\n            for j in range(i):\n                if envelopes[i][1] > envelopes[j][1]:\n                    dp[i] = max(dp[i], dp[j] + 1)\n        \n        return max(dp)\n```\n\nThe solution uses dynamic programming to solve the problem. It first sorts the envelopes based on width in ascending order. If the widths are the same, it sorts based on height in descending order. This ensures that any nested envelopes are adjacent in the sorted array.\n\nThen, the solution initializes a dynamic programming array `dp` of length `n` (number of envelopes) and sets all elements to 1. The value at `dp[i]` represents the maximum number of nested envelopes that can be achieved by considering the ith envelope.\n\nThe solution iterates through each envelope in the sorted array. For each envelope `envelopes[i]`, it checks if it can be nested inside any previous envelopes `envelopes[j]`. If the height of `envelopes[i]` is greater than the height of `envelopes[j]`, it means `envelopes[i]` can be nested inside `envelopes[j]`. In such case, the solution updates the value at `dp[i]` by taking the maximum of the current value and `dp[j] + 1`.\n\nFinally, the solution returns the maximum value in the `dp` array, which represents the maximum number of envelopes that can be nested.", "cleaned_response": "\nfrom typing import List\n\nclass Solution:\n    def maxEnvelopes(self, envelopes: List[List[int]]) -> int:\n        # Sort the envelopes based on the width in ascending order\n        # If the widths are the same, sort based on height in descending order\n        envelopes.sort(key=lambda x: (x[0], -x[1]))\n        \n        n = len(envelopes)\n        dp = [1] * n\n        \n        # Iterate through each envelope and check if it can be nested inside any previous envelopes\n        for i in range(n):\n            for j in range(i):\n                if envelopes[i][1] > envelopes[j][1]:\n                    dp[i] = max(dp[i], dp[j] + 1)\n        \n        return max(dp)\n", "n_pass": 1, "difficulty": 3.0, "frontend_question_id": 354.0, "loc": 277}
{"task_input": "\nLeetCode Problem #357\nTitle: Count Numbers with Unique Digits\nDescription:\nGiven an integer n, return the count of all numbers with unique digits, x, where 0 <= x < 10 n. Example 1: Input: n = 2 Output: 91 Explanation: The answer should be the total numbers in the range of 0 \u2264 x < 100, excluding 11, 22, 33, 44, 55, 66, 77, 88, 99 Example 2: Input: n = 0 Output: 1 Constraints: 0 <= n <= 8\n", "code_prompt": "class Solution:\n    def countNumbersWithUniqueDigits(self, n: int) -> int:\n        ", "raw_response": "```python\nclass Solution:\n    def countNumbersWithUniqueDigits(self, n: int) -> int:\n        if n == 0:\n            return 1\n        \n        total = 10\n        unique_digits = 9\n        available_digits = 9\n        \n        for i in range(1, n):\n            unique_digits *= available_digits\n            total += unique_digits\n            available_digits -= 1\n        \n        return total\n```", "cleaned_response": "\nclass Solution:\n    def countNumbersWithUniqueDigits(self, n: int) -> int:\n        if n == 0:\n            return 1\n        \n        total = 10\n        unique_digits = 9\n        available_digits = 9\n        \n        for i in range(1, n):\n            unique_digits *= available_digits\n            total += unique_digits\n            available_digits -= 1\n        \n        return total\n", "n_pass": 1, "difficulty": 2.0, "frontend_question_id": 357.0, "loc": 279}
{"task_input": "\nLeetCode Problem #363\nTitle: Max Sum of Rectangle No Larger Than K\nDescription:\nGiven an m x n matrix matrix and an integer k, return the max sum of a rectangle in the matrix such that its sum is no larger than k. It is guaranteed that there will be a rectangle with a sum no larger than k. Example 1: Input: matrix = [[1, 0, 1], [0, -2, 3]], k = 2 Output: 2 Explanation: Because the sum of the blue rectangle [[0, 1], [-2, 3]] is 2, and 2 is the max number no larger than k (k = 2). Example 2: Input: matrix = [[2, 2, -1]], k = 3 Output: 3 Constraints: m == matrix.length n == matrix[i].length 1 <= m, n <= 100 -100 <= matrix[i][j] <= 100 -10e5 <= k <= 10e5 Follow up: What if the number of rows is much larger than the number of columns?\n", "code_prompt": "class Solution:\n    def maxSumSubmatrix(self, matrix: List[List[int]], k: int) -> int:\n        ", "raw_response": "```python\nclass Solution:\n    def maxSumSubmatrix(self, matrix: List[List[int]], k: int) -> int:\n        rows = len(matrix)\n        cols = len(matrix[0])\n        result = float('-inf')\n        \n        for left in range(cols):\n            sums = [0] * rows\n            for right in range(left, cols):\n                for i in range(rows):\n                    sums[i] += matrix[i][right]\n                \n                # Kadane's algorithm to find max subarray sum no larger than k\n                sub_array_sum = [0]\n                curr_sum = 0\n                curr_max = float('-inf')\n                for num in sums:\n                    curr_sum += num\n                    i = bisect_left(sub_array_sum, curr_sum - k)\n                    if i < len(sub_array_sum):\n                        curr_max = max(curr_max, curr_sum - sub_array_sum[i])\n                    bisect.insort(sub_array_sum, curr_sum)\n                \n                result = max(result, curr_max)\n        \n        return result\n```", "cleaned_response": "\nclass Solution:\n    def maxSumSubmatrix(self, matrix: List[List[int]], k: int) -> int:\n        rows = len(matrix)\n        cols = len(matrix[0])\n        result = float('-inf')\n        \n        for left in range(cols):\n            sums = [0] * rows\n            for right in range(left, cols):\n                for i in range(rows):\n                    sums[i] += matrix[i][right]\n                \n                # Kadane's algorithm to find max subarray sum no larger than k\n                sub_array_sum = [0]\n                curr_sum = 0\n                curr_max = float('-inf')\n                for num in sums:\n                    curr_sum += num\n                    i = bisect_left(sub_array_sum, curr_sum - k)\n                    if i < len(sub_array_sum):\n                        curr_max = max(curr_max, curr_sum - sub_array_sum[i])\n                    bisect.insort(sub_array_sum, curr_sum)\n                \n                result = max(result, curr_max)\n        \n        return result\n", "n_pass": 1, "difficulty": 3.0, "frontend_question_id": 363.0, "loc": 280}
{"task_input": "\nLeetCode Problem #365\nTitle: Water and Jug Problem\nDescription:\nYou are given two jugs with capacities jug1Capacity and jug2Capacity liters. There is an infinite amount of water supply available. Determine whether it is possible to measure exactly targetCapacity liters using these two jugs. If targetCapacity liters of water are measurable, you must have targetCapacity liters of water contained within one or both buckets by the end. Operations allowed: Fill any of the jugs with water. Empty any of the jugs. Pour water from one jug into another till the other jug is completely full, or the first jug itself is empty. Example 1: Input: jug1Capacity = 3, jug2Capacity = 5, targetCapacity = 4 Output: true Explanation: The famous Die Hard example Example 2: Input: jug1Capacity = 2, jug2Capacity = 6, targetCapacity = 5 Output: false Example 3: Input: jug1Capacity = 1, jug2Capacity = 2, targetCapacity = 3 Output: true Constraints: 1 <= jug1Capacity, jug2Capacity, targetCapacity <= 10e6\n", "code_prompt": "class Solution:\n    def canMeasureWater(self, jug1Capacity: int, jug2Capacity: int, targetCapacity: int) -> bool:\n        ", "raw_response": "class Solution:\n    def canMeasureWater(self, jug1Capacity: int, jug2Capacity: int, targetCapacity: int) -> bool:\n        # If the targetCapacity is greater than the sum of the jug capacities, it is not possible to measure the targetCapacity\n        if targetCapacity > jug1Capacity + jug2Capacity:\n            return False\n        \n        # If one of the jugs has the targetCapacity, it is possible to measure the targetCapacity\n        if targetCapacity == jug1Capacity or targetCapacity == jug2Capacity:\n            return True\n        \n        # If the targetCapacity is divisible by the Greatest Common Divisor (GCD) of the jug capacities, it is possible to measure the targetCapacity\n        # Using the property of Bezout's Identity, we can find the GCD of jug1Capacity and jug2Capacity and see if targetCapacity is divisible by GCD\n        def gcd(a, b):\n            while b != 0:\n                temp = b\n                b = a % b\n                a = temp\n            return a\n        \n        if targetCapacity % gcd(jug1Capacity, jug2Capacity) == 0:\n            return True\n        \n        return False", "cleaned_response": "class Solution:\n    def canMeasureWater(self, jug1Capacity: int, jug2Capacity: int, targetCapacity: int) -> bool:\n        # If the targetCapacity is greater than the sum of the jug capacities, it is not possible to measure the targetCapacity\n        if targetCapacity > jug1Capacity + jug2Capacity:\n            return False\n        \n        # If one of the jugs has the targetCapacity, it is possible to measure the targetCapacity\n        if targetCapacity == jug1Capacity or targetCapacity == jug2Capacity:\n            return True\n        \n        # If the targetCapacity is divisible by the Greatest Common Divisor (GCD) of the jug capacities, it is possible to measure the targetCapacity\n        # Using the property of Bezout's Identity, we can find the GCD of jug1Capacity and jug2Capacity and see if targetCapacity is divisible by GCD\n        def gcd(a, b):\n            while b != 0:\n                temp = b\n                b = a % b\n                a = temp\n            return a\n        \n        if targetCapacity % gcd(jug1Capacity, jug2Capacity) == 0:\n            return True\n        \n        return False", "n_pass": 1, "difficulty": 2.0, "frontend_question_id": 365.0, "loc": 281}
{"task_input": "\nLeetCode Problem #367\nTitle: Valid Perfect Square\nDescription:\nGiven a positive integer num, return true if num is a perfect square or false otherwise. A perfect square is an integer that is the square of an integer. In other words, it is the product of some integer with itself. You must not use any built-in library function, such as sqrt. Example 1: Input: num = 16 Output: true Explanation: We return true because 4 * 4 = 16 and 4 is an integer. Example 2: Input: num = 14 Output: false Explanation: We return false because 3. 742 * 3. 742 = 14 and 3. 742 is not an integer. Constraints: 1 <= num <= 2^31 - 1\n", "code_prompt": "class Solution:\n    def isPerfectSquare(self, num: int) -> bool:\n        ", "raw_response": "```python\nclass Solution:\n    def isPerfectSquare(self, num: int) -> bool:\n        if num == 1:\n            return True\n        \n        left = 1\n        right = num // 2\n        \n        while left <= right:\n            mid = left + (right - left) // 2\n            square = mid * mid\n            \n            if square == num:\n                return True\n            elif square < num:\n                left = mid + 1\n            else:\n                right = mid - 1\n        \n        return False\n```\n\nThe given solution uses binary search to efficiently find whether a number is a perfect square or not. We start by initializing `left` to 1 and `right` to `num // 2`. Then, we iteratively calculate the midpoint `mid` using the formula `mid = left + (right - left) // 2`. \n\nIf the square of `mid` is equal to `num`, we return True. If the square of `mid` is less than `num`, we update `left` to `mid + 1` and continue the binary search on the right half of the range. If the square of `mid` is greater than `num`, we update `right` to `mid - 1` and continue the binary search on the left half of the range.\n\nIf a perfect square is not found within the range, we return False.", "cleaned_response": "\nclass Solution:\n    def isPerfectSquare(self, num: int) -> bool:\n        if num == 1:\n            return True\n        \n        left = 1\n        right = num // 2\n        \n        while left <= right:\n            mid = left + (right - left) // 2\n            square = mid * mid\n            \n            if square == num:\n                return True\n            elif square < num:\n                left = mid + 1\n            else:\n                right = mid - 1\n        \n        return False\n", "n_pass": 1, "difficulty": 1.0, "frontend_question_id": 367.0, "loc": 282}
{"task_input": "\nLeetCode Problem #368\nTitle: Largest Divisible Subset\nDescription:\nGiven a set of distinct positive integers nums, return the largest subset answer such that every pair (answer[i], answer[j]) of elements in this subset satisfies:...\n answer[i] % answer[j] == 0, or answer[j] % answer[i] == 0 If there are multiple solutions, return any of them. Example 1: Input: nums = [1, 2, 3] Output: [1, 2] Explanation: [1, 3] is also accepted. Example 2: Input: nums = [1, 2, 4, 8] Output: [1, 2, 4, 8] Constraints: 1 <= nums.length <= 1000^1 <= nums[i] <= 2 * 10e9 All the integers in nums are unique.\n", "code_prompt": "class Solution:\n    def largestDivisibleSubset(self, nums: List[int]) -> List[int]:\n        ", "raw_response": "The problem is asking us to find the largest subset of distinct positive integers in which every pair of elements satisfies the condition that `answer[i] % answer[j] == 0` or `answer[j] % answer[i] == 0`.\n\nTo solve this problem, we can use dynamic programming.\n\nFirst, we need to sort the input array `nums` in ascending order. This is important because any number that is divisible by another number can only appear after it in the sorted array.\n\nNext, we need to keep track of two arrays: `dp` and `prev`.\n\n- `dp` is an array that stores the length of the largest divisible subset ending at `nums[i]`.\n- `prev` is an array that stores the index of the previous number in the largest divisible subset ending at `nums[i]`.\n\nWe initialize `dp` and `prev` arrays with 1s, as the minimum length of a subset is always 1 (the number itself).\n\nThen, we iterate through the sorted array `nums` from left to right. For each number at index `i`, we iterate from index 0 to `i-1` to check if `nums[i]` is divisible by `nums[j]`. If it is divisible and the length of the divisible subset ending at `nums[j]` plus 1 is greater than the current length at `dp[i]`, we update `dp[i]` and `prev[i]`.\n\nAfter the iteration, we find the maximum value in the `dp` array and its corresponding index `max_index`. This index will represent the last element of the largest divisible subset.\n\nFinally, we use the `prev` array to backtrack and construct the largest divisible subset by starting from `max_index` and adding the corresponding element to the subset. We repeat this process until we reach the first element.\n\nHere is the final implementation:\n\n```python\nclass Solution:\n    def largestDivisibleSubset(self, nums: List[int]) -> List[int]:\n        nums.sort() # Sort the input array in ascending order\n        \n        n = len(nums)\n        dp = [1] * n\n        prev = [-1] * n\n        \n        for i in range(n):\n            for j in range(i):\n                if nums[i] % nums[j] == 0:\n                    if dp[j] + 1 > dp[i]:\n                        dp[i] = dp[j] + 1\n                        prev[i] = j\n        \n        max_len = max(dp)\n        max_index = dp.index(max_len)\n        \n        subset = []\n        while max_index != -1:\n            subset.append(nums[max_index])\n            max_index = prev[max_index]\n        \n        return subset[::-1] # Reverse the subset to get the correct order\n```\n\nThis solution has a time complexity of O(n^2) due to the nested loop, where n is the length of the input array `nums`.", "cleaned_response": "\nclass Solution:\n    def largestDivisibleSubset(self, nums: List[int]) -> List[int]:\n        nums.sort() # Sort the input array in ascending order\n        \n        n = len(nums)\n        dp = [1] * n\n        prev = [-1] * n\n        \n        for i in range(n):\n            for j in range(i):\n                if nums[i] % nums[j] == 0:\n                    if dp[j] + 1 > dp[i]:\n                        dp[i] = dp[j] + 1\n                        prev[i] = j\n        \n        max_len = max(dp)\n        max_index = dp.index(max_len)\n        \n        subset = []\n        while max_index != -1:\n            subset.append(nums[max_index])\n            max_index = prev[max_index]\n        \n        return subset[::-1] # Reverse the subset to get the correct order\n", "n_pass": 1, "difficulty": 2.0, "frontend_question_id": 368.0, "loc": 283}
{"task_input": "\nLeetCode Problem #372\nTitle: Super Pow\nDescription:\nYour task is to calculate a b mod 1337 where a is a positive integer and b is an extremely large positive integer given in the form of an array. Example 1: Input: a = 2, b = [3] Output: 8 Example 2: Input: a = 2, b = [1, 0] Output: 1024 Example 3: Input: a = 1, b = [4, 3, 3, 8, 5, 2] Output: 1 Constraints: 1 <= a <= 2^31 - 1^1 <= b.length <= 2000^0 <= b[i] <= 9 b does not contain leading zeros.\n", "code_prompt": "class Solution:\n    def superPow(self, a: int, b: List[int]) -> int:\n        ", "raw_response": "class Solution:\n    def superPow(self, a: int, b: List[int]) -> int:\n        mod = 1337\n        \n        # Calculate the power of a using modular exponentiation\n        def fast_power(a, n):\n            if n == 0:\n                return 1\n            if n % 2 == 1:\n                return (a % mod) * fast_power(a, n - 1) % mod\n            else:\n                sqrt = fast_power(a, n // 2)\n                return (sqrt * sqrt) % mod\n        \n        # Convert the array b to an integer\n        num = 0\n        for digit in b:\n            num = (num * 10 + digit) % (mod - 1)\n        \n        return fast_power(a, num) % mod", "cleaned_response": "class Solution:\n    def superPow(self, a: int, b: List[int]) -> int:\n        mod = 1337\n        \n        # Calculate the power of a using modular exponentiation\n        def fast_power(a, n):\n            if n == 0:\n                return 1\n            if n % 2 == 1:\n                return (a % mod) * fast_power(a, n - 1) % mod\n            else:\n                sqrt = fast_power(a, n // 2)\n                return (sqrt * sqrt) % mod\n        \n        # Convert the array b to an integer\n        num = 0\n        for digit in b:\n            num = (num * 10 + digit) % (mod - 1)\n        \n        return fast_power(a, num) % mod", "n_pass": 1, "difficulty": 2.0, "frontend_question_id": 372.0, "loc": 285}
{"task_input": "\nLeetCode Problem #373\nTitle: Find K Pairs with Smallest Sums\nDescription:\nYou are given two integer arrays nums1 and nums2 sorted in non-decreasing order and an integer k. Define a pair (u, v) which consists of one element from the first array and one element from the second array. Return the k pairs (u 1, v 1 ), (u 2, v 2 ),. . . , (u k, v k ) with the smallest sums. Example 1: Input: nums1 = [1, 7, 11], nums2 = [2, 4, 6], k = 3 Output: [[1, 2], [1, 4], [1, 6]] Explanation: The first 3 pairs are returned from the sequence: [1, 2], [1, 4], [1, 6], [7, 2], [7, 4], [11, 2], [7, 6], [11, 4], [11, 6] Example 2: Input: nums1 = [1, 1, 2], nums2 = [1, 2, 3], k = 2 Output: [[1, 1], [1, 1]] Explanation: The first 2 pairs are returned from the sequence: [1, 1], [1, 1], [1, 2], [2, 1], [1, 2], [2, 2], [1, 3], [1, 3], [2, 3] Example 3: Input: nums1 = [1, 2], nums2 = [3], k = 3 Output: [[1, 3], [2, 3]] Explanation: All possible pairs are returned from the sequence: [1, 3], [2, 3] Constraints: 1 <= nums1.length, nums2.length <= 10e5 -10e9 <= nums1[i], nums2[i] <= 10e9 nums1 and nums2 both are sorted in non-decreasing order. 1 <= k <= 10e4\n", "code_prompt": "class Solution:\n    def kSmallestPairs(self, nums1: List[int], nums2: List[int], k: int) -> List[List[int]]:\n        ", "raw_response": "```python\nfrom typing import List\n\nclass Solution:\n    def kSmallestPairs(self, nums1: List[int], nums2: List[int], k: int) -> List[List[int]]:\n        if not nums1 or not nums2:\n            return []\n        \n        # Create a min heap to store the pairs with the smallest sums\n        heap = []\n        \n        # Add the first k pairs (nums1[i], nums2[0]) to the heap\n        for i in range(min(k, len(nums1))):\n            # Push the pair (nums1[i], nums2[0]) onto the min heap\n            # Sum of the pair is nums1[i] + nums2[0]\n            # Store the sum as the first element, followed by the pair [nums1[i], nums2[0]]\n            heapq.heappush(heap, [nums1[i] + nums2[0], nums1[i], nums2[0], 0])\n        \n        # Iterate until we find k smallest pairs or there are no more pairs left\n        result = []\n        while k > 0 and heap:\n            # Pop the smallest pair (sum, nums1[i], nums2[j], j) from the heap\n            # where i is fixed and j is the index of the next element in nums2\n            smallest = heapq.heappop(heap)\n            result.append([smallest[1], smallest[2]])\n            \n            # Check if there are more pairs to explore in nums2\n            if smallest[3] + 1 < len(nums2):\n                # Push the next pair (nums1[i], nums2[j+1]) onto the min heap\n                # Sum of the pair is nums1[i] + nums2[j+1]\n                # Store the sum as the first element, followed by the pair [nums1[i], nums2[j+1]]\n                heapq.heappush(heap, [smallest[1] + nums2[smallest[3] + 1], smallest[1], nums2[smallest[3] + 1], smallest[3] + 1])\n            \n            # Decrease the count of remaining pairs to find\n            k -= 1\n        \n        return result\n```", "cleaned_response": "\nfrom typing import List\n\nclass Solution:\n    def kSmallestPairs(self, nums1: List[int], nums2: List[int], k: int) -> List[List[int]]:\n        if not nums1 or not nums2:\n            return []\n        \n        # Create a min heap to store the pairs with the smallest sums\n        heap = []\n        \n        # Add the first k pairs (nums1[i], nums2[0]) to the heap\n        for i in range(min(k, len(nums1))):\n            # Push the pair (nums1[i], nums2[0]) onto the min heap\n            # Sum of the pair is nums1[i] + nums2[0]\n            # Store the sum as the first element, followed by the pair [nums1[i], nums2[0]]\n            heapq.heappush(heap, [nums1[i] + nums2[0], nums1[i], nums2[0], 0])\n        \n        # Iterate until we find k smallest pairs or there are no more pairs left\n        result = []\n        while k > 0 and heap:\n            # Pop the smallest pair (sum, nums1[i], nums2[j], j) from the heap\n            # where i is fixed and j is the index of the next element in nums2\n            smallest = heapq.heappop(heap)\n            result.append([smallest[1], smallest[2]])\n            \n            # Check if there are more pairs to explore in nums2\n            if smallest[3] + 1 < len(nums2):\n                # Push the next pair (nums1[i], nums2[j+1]) onto the min heap\n                # Sum of the pair is nums1[i] + nums2[j+1]\n                # Store the sum as the first element, followed by the pair [nums1[i], nums2[j+1]]\n                heapq.heappush(heap, [smallest[1] + nums2[smallest[3] + 1], smallest[1], nums2[smallest[3] + 1], smallest[3] + 1])\n            \n            # Decrease the count of remaining pairs to find\n            k -= 1\n        \n        return result\n", "n_pass": 1, "difficulty": 2.0, "frontend_question_id": 373.0, "loc": 286}
